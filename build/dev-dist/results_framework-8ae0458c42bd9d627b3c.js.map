{"version":3,"file":"results_framework-8ae0458c42bd9d627b3c.js","sources":["webpack:///./js/pages/results_framework/components/leveltier_picker.js","webpack:///./js/components/helpPopover.js","webpack:///./js/components/changesetNotice.js","webpack:///./js/pages/results_framework/components/level_cards.js","webpack:///./js/components/selectWidgets.js","webpack:///./js/pages/results_framework/models.js","webpack:///./js/formUtils.js","webpack:///./js/pages/results_framework/components/level_tier_lists.js","webpack:///./js/components/actionButtons.js","webpack:///./js/pages/results_framework/index.js","webpack:///./js/general_utilities.js","webpack:///./js/api.js","webpack:///./js/components/indicatorModalComponents.js","webpack:///./js/eventbus.js","webpack:///./js/pages/results_framework/components/level_list.js","webpack:///./js/constants.js"],"sourcesContent":["import React from 'react';\nimport { observer, inject } from \"mobx-react\";\nimport { toJS } from \"mobx\";\n\nimport Select from 'react-select';\nimport HelpPopover from \"../../../components/helpPopover\";\nimport { EditableLevelTierList, StaticLevelTierList } from './level_tier_lists'\n\n@inject('rootStore')\n@observer\nclass Picker extends React.Component {\n    handleChange = selectedTemplate => {\n        this.props.rootStore.levelStore.changeTierSet(selectedTemplate.value);\n    };\n\n    componentDidUpdate() {\n        // Enable popovers after update (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n    render() {\n        let helpIcon = null;\n        if (this.props.rootStore.uiStore.tierLockStatus == \"locked\"){\n            let firstTier = this.props.rootStore.levelStore.chosenTierSet[0];\n            let secondTier = this.props.rootStore.levelStore.chosenTierSet[1];\n            helpIcon = <HelpPopover\n                key={1}\n                // # Translators: Warning message displayed to users explaining why they can't change a setting they could change before.\n                content={interpolate(gettext('<span class=\"text-danger\"><strong>The results framework template is locked as soon as the first %(secondTier)s is saved.</strong></span> To change templates, all saved levels must be deleted except for the original %(firstTier)s. A level can only be deleted when it has no sub-levels and no linked indicators.'), {secondTier: secondTier, firstTier: firstTier}, true)}\n            />\n\n        }\n        else if (this.props.rootStore.uiStore.tierLockStatus == \"primed\"){\n\n            helpIcon = <HelpPopover\n                key={2}\n                content={this.props.rootStore.uiStore.splashWarning}\n            />\n        }\n\n        const tierTemplates = this.props.rootStore.levelStore.tierTemplates;\n\n        const { custom, ...templateVals } = tierTemplates;\n        let options = Object.keys(templateVals).sort().map(key => {\n            return {value:key, label:tierTemplates[key]['name']};\n        });\n\n        options.push({\n            label: \"-----------------------------------------------------------\",\n            options: [{\n                value: this.props.rootStore.levelStore.customTierSetKey,\n                label: custom['name']\n            }]\n        });\n\n        const selectedOption = {value:this.props.rootStore.levelStore.chosenTierSetKey, label: this.props.rootStore.levelStore.chosenTierSetName};\n\n        let classes = \"leveltier-picker__selectbox \";\n        classes += this.props.rootStore.uiStore.tierLockStatus == \"locked\" ? \"leveltier-picker__selectbox--disabled\" : \"\";\n\n        return (\n              <div className={classes}>\n                  <div className=\"form-group\">\n                    <label>{gettext('Results framework template')}</label>&nbsp;<small>{helpIcon}</small>\n                    <Select\n                        maxMenuHeight={350}\n                        options={options}\n                        value={selectedOption}\n                        isDisabled={this.props.rootStore.uiStore.tierLockStatus == \"locked\"}\n                        isSearchable={false}\n                        onChange={this.handleChange}\n                    />\n                </div>\n            </div>\n        )\n    }\n}\n\nconst ChangeLogLink = ({programId}) => {\n    const url = `/tola_management/audit_log/${programId}/`;\n\n    return <div className=\"leveltier-picker__change-log-link-box\">\n        <a href={url} className=\"btn-link\">\n            <i className=\"fas fa-history\" /> {gettext('Change log')}\n        </a>\n    </div>\n};\n\nexport const LevelTierPicker = inject(\"rootStore\")(observer(function (props) {\n    let tierListType = <StaticLevelTierList />;\n    if (this.props.rootStore.levelStore.chosenTierSetKey == this.props.rootStore.levelStore.customTierSetKey &&\n        !this.props.rootStore.levelStore.useStaticTierList &&\n        this.props.rootStore.levelStore.hasEditPermissions){\n        tierListType = <EditableLevelTierList />;\n    }\n\n    return (\n        <div id=\"leveltier-picker\" className=\"leveltier-picker\">\n            <div className=\"leveltier-picker__panel\">\n                <Picker />\n                {tierListType}\n            </div>\n\n            <ChangeLogLink programId={props.rootStore.levelStore.program_id} />\n        </div>\n    )\n}));\n","import React from 'react'\nimport ReactDOM from 'react-dom';\n\nexport default class HelpPopover extends React.Component {\n    constructor(props) {\n        super(props)\n        this.placement = props.placement || null;\n        this.popoverRef = props.innerRef || React.createRef();\n        this.iconClass = props.iconClass || \"far fa-question-circle\";\n        this.iconStyle = props.iconStyle || {};\n        this.linkStyle = {};\n        if (props.linkHeight) {\n            this.linkStyle.height = props.linkHeight;\n        }\n    }\n\n    render() {\n        return (\n            <a\n                tabIndex=\"0\"\n                style={ this.linkStyle }\n                data-toggle=\"popover\"\n                data-trigger=\"focus\"\n                data-html=\"true\"\n                data-placement={this.placement}\n                data-content={this.props.content}\n                className={this.props.className}\n                ref={this.popoverRef}\n                >\n            <i aria-label={ this.props.ariaText } style={ this.iconStyle } className={ this.iconClass }></i></a>\n        )\n    }\n}\n\nexport class BootstrapPopoverButton extends React.Component {\n    popoverName = 'base';\n\n    componentDidMount = () => {\n        // make a cancelable (class method) function so clicking out of the popover will close it:\n        this.bodyClickHandler = (ev) => {\n            if ($(`#${this.popoverName}_popover_content`).parent().find($(ev.target)).length == 0) {\n                $(this.refs.target).popover('hide');\n            }\n        }\n        const popoverOpenHandler = () => {\n            // first make it so any click outside of the popover will hide it:\n            $('body').on('click', this.bodyClickHandler);\n            // update position (it's had content loaded):\n            $(this.refs.target).popover('update')\n                //when it hides destroy the body clickhandler:\n                .on('hide.bs.popover', () => {$('body').off('click', this.bodyClickHandler);});\n        };\n        const shownFn = (ev) => {\n            ReactDOM.render(\n                this.getPopoverContent(),\n                document.querySelector(`#${this.popoverName}_popover_content`),\n                popoverOpenHandler\n            );\n        };\n        $(this.refs.target).popover({\n            content: `<div id=\"${this.popoverName}_popover_content\"></div>`,\n            html: true,\n            placement: 'bottom'\n        }).on('shown.bs.popover', shownFn);\n    }\n\n    getPopoverContent = () => {\n        throw new Error('not implemented');\n    }\n}\n","import { RFC_OPTIONS } from '../constants';\n//import PNotify from 'pnotify/dist/es/PNotify.js'; // needed for jest teseting, leaving in for future testing attempts\n//import 'pnotify/dist/es/PNotifyCallbacks.js';\n//import 'pnotify/dist/es/PNotifyButtons.js';\n\nconst create_rfc_dropdown = ({\n    custom_rfc_options = null,\n} = {}) => {\n    let options = custom_rfc_options || RFC_OPTIONS;\n    if (!options) {\n        return '';\n    }\n    let rfc_section = document.createElement('section');\n    rfc_section.classList.add('pnotify__reason-for-change');\n    let form_div = document.createElement('div');\n    form_div.classList.add('form-group');\n    let label = document.createElement('label');\n    // # Translators: This is a label for a dropdown that presents several possible justifications for changing a value\n    label.appendChild(document.createTextNode(gettext('Reason for change')));\n    label.htmlFor = 'reasons_for_change_select';\n    form_div.appendChild(label);\n    let select = document.createElement('select');\n    select.name = 'reasons_for_change';\n    select.id = 'reasons_for_change_select';\n    select.setAttribute('multiple', '');\n    select.classList.add('form-control');\n    for (let i=0; i<options.length; i++) {\n        let optionElement = document.createElement('option');\n        optionElement.value = options[i].value;\n        optionElement.label = options[i].label;\n        optionElement.text = options[i].label;\n        if (i == options.length-1) {\n            let divider = document.createElement('option');\n            divider.setAttribute('data-role', 'divider');\n            select.appendChild(divider);\n        }\n        select.appendChild(optionElement);\n    }\n    form_div.appendChild(select);\n    rfc_section.appendChild(form_div);\n    return rfc_section;\n}\n\n/*\n* Consider using this notification function rather than the more specific ones above.  It should be able to\n* everything they can do. The configurable parameters are for the 4 sections of the notification and\n* for other visual and functional elements. Leave any of these null or false to omit them.\n* There is NO DEFAULT TEXT. You must explicitly provide text to text elements.\n*/\n\nconst create_unified_changeset_notice = ({\n    header = null, // text for the header\n    show_icon = true, // show an appropriate icon in the header\n    message_text = null, // appears in black (body color) text\n    preamble = null, // appears in colored text below the header\n    on_submit = () => {}, // action to trigger on submit\n    on_cancel = () => {}, // action to trigger on cancel\n    rfc_required = true, // is reason for change required (can be overridden by validation_type)\n    rfc_options = null, // reason for change dropdown options or true for default\n    rationale_required = true, // do not allow submission without writing a rationale (can be overridden by validation_type)\n    include_rationale = false, // shows rationale textarea\n    validation_type = 0, // Types - 0: use paramaters/defaults, 1: rationale is optional if rfc is chosen, unless rfc value is other\n    showCloser = true, // show close box\n    // # Translators: Button to approve a form\n    confirm_text = gettext('Ok'),\n    // # Translators: Button to cancel a form submission\n    cancel_text = gettext('Cancel'),\n    context = null,\n    notice_type = 'notice', // possible values: error (danger/red), info (blue), success (green), notice (warning/yellow)\n    blocking = true,\n    self_dismissing = false, // automatically hides the notice after 8000 ms (default). NOTE: this is the OPPOSITE behavior as default PNotify\n    dismiss_delay = 8000, // also PNotify default\n} = {}) => {\n    let header_icons = {\n        'error': 'fa-exclamation-triangle',\n        'info': 'fa-info-circle',\n        'success': 'fa-check-circle',\n        'notice': 'fa-exclamation-triangle',\n    };\n    let color_classes = {\n        'error': 'danger',\n        'info': 'info',\n        'success': 'success',\n        'notice': 'primary',\n    };\n\n    let icon = '';\n\n    if (show_icon) {\n        icon = `<i class=\"fas ${header_icons[notice_type]}\"></i>`\n    }\n\n    const header_section = (header || icon) ?\n        `<header class=\"pnotify__header\">\n            <h4>\n                ${icon}\n                ${header ? header : ''}\n            </h4>\n        </header>` : '';\n\n    const preamble_section = !preamble ? '' :\n        `<section class=\"pnotify__preamble\">\n            <p><b>${preamble}</b></p>\n        </section>`;\n\n    const message_section = ! message_text ? '' :\n        `<section class=\"pnotify__message\">\n            <p>${message_text}</p>\n        </section>`;\n\n    let rfc_section = '';\n    if (rfc_options !== null) {\n        let custom_rfc_options = rfc_options === true ? null : rfc_options;\n        rfc_section = create_rfc_dropdown({custom_rfc_options: custom_rfc_options}).outerHTML;\n    }\n\n    // # Translators: This is the label for a textbox where a user can provide details about their reason for selecting a particular option\n    const rationale_label = rfc_section.length > 0 ?  `<label>${gettext(\"Details\")}</label>` : '';\n    const rationale_section = ! include_rationale ? '' :\n        `<section class=\"pnotify__rationale\">\n            <div class=\"form-group\">\n                ${rationale_label}\n                <textarea class=\"form-control\" name=\"rationale\" />\n            </div>\n        </section>`;\n\n    const inner = `\n        ${header_section}\n        ${preamble_section}\n        ${message_section}\n        ${rfc_section}\n        ${rationale_section}\n    `;\n\n\n    // IMPORTANT TODO\n    // **************\n    // Following code cribs from create_changeset_notice\n    // I left create_changeset_notice untouched to avoid lots of regressions\n    // I think we should deprecate create_changeset_notice entirely\n\n    let confirm_button = {\n        text: confirm_text,\n        primary: true,\n        addClass: 'btn-sm btn-' + color_classes[notice_type],\n        click: function (notice) {\n            let close = true;\n            let textarea = $(notice.refs.elem).find('textarea[name=\"rationale\"]');\n            textarea.parent().find('.invalid-feedback').remove();\n            let rationale = textarea.val() ? textarea.val().trim() : undefined; // trim whitespace to disallow whitespace-only submission\n            let rfc_select  = $(notice.refs.elem).find('select[name=\"reasons_for_change\"]');\n            let reasons_for_change = (rfc_select.val() || []).map(v => parseInt(v));\n            let is_valid = false;\n            switch (validation_type) {\n                case 1:\n                    // Uses RFC dropdown logic (either a rationale or a non-Other reason for change required):\n                    is_valid = (rationale || (reasons_for_change.length > 0 && reasons_for_change.indexOf(1) == -1))\n                    break;\n                case 0:\n                default:\n                    // Either a rationale is submitted, or there was no rationale form, or it was optional:\n                    is_valid = ((rationale || !include_rationale || !rationale_required) &&\n                    // Either one or more reasons for change or there were no options or they weren't required:\n                                (reasons_for_change.length > 0 || !rfc_options || !rfc_required));\n            }\n            if (is_valid){\n                textarea.removeClass('is-invalid');\n            } else {\n                textarea.addClass('is-invalid');\n                textarea.parent().append(\n                    '<div class=\"invalid-feedback\">'\n                    + gettext('A reason is required.')\n                    + '</div>'\n                );\n                return false;\n            }\n\n            if(on_submit) {\n                close = on_submit(rationale, reasons_for_change, validation_type);\n                if(close === undefined) {\n                    close = true;\n                }\n            }\n            if(close) {\n                document.getElementById('notification_blocking_div').style.display='none';\n                notice.close();\n            }\n        }\n    }\n\n    let cancel_button = {\n        text: cancel_text,\n        addClass: 'btn-sm',\n        click: function (notice) {\n            close = on_cancel()\n            if(close === undefined) {\n                close = true;\n            }\n\n            if(close) {\n                document.getElementById('notification_blocking_div').style.display='none';\n                notice.close();\n            }\n        }\n    }\n\n    var changeset_buttons = []\n\n    if (confirm_text) {\n        changeset_buttons.push(confirm_button)\n    }\n\n    if (cancel_text) {\n        changeset_buttons.push(cancel_button)\n    }\n\n    var notice = PNotify.alert({\n        text: $(`<div><form action=\"\" method=\"post\" class=\"form\">${inner}</form></div>`).html(),\n        textTrusted: true,\n        icon: false,\n        width: '350px',\n        hide: self_dismissing,\n        delay: dismiss_delay,\n        type: notice_type,\n        addClass: 'program-page__rationale-form',\n        stack: {\n            'overlayClose': true,\n            'dir1': 'right',\n            'dir2': 'up',\n            'firstpos1': 20,\n            'firstpos2': 20,\n            'context': context\n        },\n        modules: {\n            Buttons: {\n                closer: showCloser,\n                closerHover: false,\n                sticker: false\n            },\n            Confirm: {\n                align: 'flex-start',\n                confirm: true,\n                buttons: changeset_buttons\n            }\n        }\n    });\n\n    $('.pnotify__reason-for-change select').multiselect({\n        numberDisplayed: 1,\n        // # Translators: (preceded by a number) e.g. \"4 options selected\"\n        nSelectedText: ` ${gettext('selected')}`,\n        // # Translators: for a dropdown menu with no options checked:\n        nonSelectedText: gettext('None selected')\n    });\n\n\n\n    if (on_cancel) {\n        notice.on('click', function(e) {\n            if ($(e.target).is('.ui-pnotify-closer *')) {\n                let close = on_cancel();\n                if (close || close === undefined) {\n                    document.getElementById('notification_blocking_div').style.display='none';\n                    notice.close();\n                }\n        }});\n    }\n\n    // END CRIBBED CODE\n\n}\n\nexport { create_unified_changeset_notice };\n\nexport const testables = {\n    create_rfc_dropdown: create_rfc_dropdown,\n};\n","import React from 'react';\nimport classNames from 'classnames';\nimport { observer, inject } from \"mobx-react\"\nimport { toJS, extendObservable, action } from 'mobx';\nimport { library } from '@fortawesome/fontawesome-svg-core'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faCaretRight, faCaretDown, faArrowsAlt } from '@fortawesome/free-solid-svg-icons'\nimport { SingleReactSelect } from \"../../../components/selectWidgets\";\nimport { AddIndicatorButton, UpdateIndicatorButton } from '../../../components/indicatorModalComponents';\nimport {sortableContainer, sortableElement, sortableHandle} from 'react-sortable-hoc';\nimport HelpPopover from \"../../../components/helpPopover\";\nimport TextareaAutosize from 'react-autosize-textarea';\nimport Select from \"react-select\"\nimport { create_unified_changeset_notice } from '../../../components/changesetNotice';\n\n\n\nlibrary.add(faCaretDown, faCaretRight, faArrowsAlt);\n\nexport class LevelTitle extends React.Component {\n\n    render() {\n        return (\n            <h3 className={'level-title ' + this.props.classes}>\n                {this.props.tierName}\n                {/*if we don't check whether there is an ontology, there ill be an extra\n                space before the colon */}\n                {this.props.ontologyLabel ? \" \" + this.props.ontologyLabel : null}\n            </h3>\n        )\n    }\n}\n\nclass ProgramObjectiveImport extends React.Component {\n    onChange = (item) => {\n        this.props.onProgramObjectiveImport(item.value);\n    }\n\n    render() {\n        const programObjectives = this.props.programObjectives;\n\n        // hide if no objectives to import\n        if (programObjectives.length === 0) return null;\n\n        const options = programObjectives.map( entry => {return {value: entry.id, label: entry.name}});\n\n        return (\n            <div className=\"program-objective-import mb-3\">\n                <Select\n                    // # Translators: Take the text of a program objective and import it for editing\n                    placeholder={gettext('Import Program Objective')}\n                    onChange={ this.onChange }\n                    value={ \"\" }\n                    className=\"tola-react-select\"\n                    options={ options }\n                    isDisabled={this.props.isDisabled}\n                />\n\n                <a href=\"#\"\n                   className=\"program-objective-import__icon\"\n                   tabIndex=\"0\"\n                   data-html=\"true\"\n                   data-toggle=\"popover\"\n                   data-placement=\"bottom\"\n                   data-trigger=\"focus\"\n                   data-content={\n                       /* # Translators: instructions to users containing some HTML */\n                       gettext(\"Import text from a Program Objective. <strong class='program-objective-import__popover-strong-text'>Make sure to remove levels and numbers from your text, because they are automatically displayed.</strong>\")\n                   }\n                   onClick={e => e.preventDefault()}>\n                    <i className=\"far fa-question-circle\"/>\n                </a>\n            </div>\n        )\n    }\n}\n\n@inject('rootStore')\n@observer\nexport class LevelCardCollapsed extends React.Component {\n\n    deleteLevel = () => {\n        this.props.rootStore.uiStore.setDisableCardActions(true);\n        const levelTitle = this.props.levelProps.tierName + \" \" + this.props.levelProps.ontologyLabel;\n        create_unified_changeset_notice({\n            header: gettext(\"Warning\"),\n            show_icon: true ,\n            notice_type: 'error',\n            preamble: gettext(\"This action cannot be undone.\"),\n            /* # Translators:  This is a confirmation prompt that is triggered by clicking on a delete button. The code is a reference to the name of the specific item being deleted.  Only one item can be deleted at a time. */\n            message_text: interpolate(gettext(\"Are you sure you want to delete %s?\"), [levelTitle]),\n            on_submit: () => this.props.rootStore.levelStore.deleteLevelFromDB(this.props.level.id),\n            on_cancel: () => this.props.rootStore.uiStore.setDisableCardActions(false)\n        });\n    };\n\n    editLevel = () => {\n        this.props.rootStore.uiStore.editCard(this.props.level.id)\n    };\n\n    componentDidMount() {\n        // Enable popovers after update (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        // Enable popovers after update (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n    buildIPTTUrl = (indicator_ids) => {\n        let url = `/indicators/iptt_report/${this.props.rootStore.levelStore.program_id}/timeperiods/?frequency=3&start=0&end=999`;\n        indicator_ids.forEach( i => url += \"&indicators=\"+i);\n        return url\n    };\n\n    render(){\n        // the level card shouldn't be displayed if it's parent level is not expandoed (except\n        // if the level is the top level one).\n        if (this.props.rootStore.uiStore.hasVisibleChildren.indexOf(this.props.level.parent) < 0 && this.props.level.parent != null){\n            return null;\n        }\n\n        // Prepare the indicator links for the indicator popover\n        let allIndicatorLinks = [];\n\n        // Get indicator ids linked to this level and create a hyperlink for a filtered IPTT.\n        let sameLevelIndicatorIds = this.props.levelProps.indicators.map( i => i.id);\n        if (sameLevelIndicatorIds.length > 0) {\n            /* # Translators: this link opens a view of all indicators linked to (associated with) a particular level (level name replaces %s) */\n            const linkPreface = gettext('All indicators linked to %s');\n            const linkText = interpolate(linkPreface, [`${this.props.levelProps.tierName} ${this.props.levelProps.ontologyLabel}`]);\n            allIndicatorLinks.push(`<li class=\"nav-item level-card--iptt-links\"><a href=${this.buildIPTTUrl(sameLevelIndicatorIds)}>${linkText}</a></li>`);\n        }\n\n        // Get indicator ids linked to the descendants of this level, add the indicator ids identified\n        // above, and create a hyperlink for a filtered IPTT.  Only do this if the level has sublevels.\n        if (this.props.levelProps.tierName != this.props.rootStore.levelStore.chosenTierSet.slice(-1)[0]) {\n            let descendantIndicatorIds = this.props.levelProps.descendantIndicatorIds;\n            if (descendantIndicatorIds.length > 0) {\n                descendantIndicatorIds = descendantIndicatorIds.concat(sameLevelIndicatorIds);\n                /* # Translators: this link opens a view of all indicators linked to (associated with) a particular level and its child levels (level name replaces %s) */\n                const linkPreface = gettext('All indicators linked to %s and sub-levels');\n                const linkText = interpolate(linkPreface, [`${this.props.levelProps.tierName} ${this.props.levelProps.ontologyLabel}`]);\n                allIndicatorLinks.unshift(`<li class=\"nav-item level-card--iptt-links\"><a href=${this.buildIPTTUrl(descendantIndicatorIds)}>${linkText}</a></li>`);\n            }\n        }\n\n        // Create IPTT hyperlinks for each individual indicator linked to this level\n        let individualLinks = this.props.levelProps.indicators\n            .sort( (a, b) => a.level_order - b.level_order)\n            .map( (indicator, index) => {\n                let indicatorNumber = \"\";\n                if (!this.props.rootStore.levelStore.manual_numbering) {\n                    indicatorNumber = this.props.levelProps.ontologyLabel + String.fromCharCode(97 + index) + \": \";\n                }\n                else if (this.props.rootStore.levelStore.manual_numbering && indicator.number) {\n                    indicatorNumber = indicator.number + \": \";\n                }\n                return `<li class=\"nav-item level-card--iptt-links\"><a href=${this.buildIPTTUrl([indicator.id])}>${indicatorNumber}${indicator.name}</a></li>`;\n            });\n\n        allIndicatorLinks = allIndicatorLinks.concat(individualLinks);\n\n\n        let indicatorMarkup = `<ul class=\"nav flex-column\">${allIndicatorLinks.join(\"\")}</ul>`;\n        const iCount = this.props.levelProps.indicators.length;\n        /* # Translators: This is a count of indicators associated with another object */\n        const indicatorCountText = interpolate(ngettext(\"%s indicator\", \"%s indicators\", iCount), [iCount]);\n\n        // The expando caret is only applied to levels that:\n        // 1. Aren't at the end of the leveltier hierarchy\n        // 2. Actually have children\n        // The expando click should be disabled when there is a card being edited\n        let expando = null;\n        if (this.props.levelProps.tierName != toJS(this.props.rootStore.levelStore.chosenTierSet.slice(-1)[0]) &&\n            this.props.rootStore.levelStore.levels.filter( l => l.parent == this.props.level.id).length > 0){\n            expando = <FontAwesomeIcon\n                className={this.props.rootStore.uiStore.disabledActionsOrActiveCard ? \"\" : \"text-action\"}\n                icon={this.props.rootStore.uiStore.hasVisibleChildren.indexOf(this.props.level.id) >= 0 ? 'caret-down' : 'caret-right'} />\n        }\n        const expandoClasses = expando && !this.props.rootStore.uiStore.disabledActionsOrActiveCard ? \"level-card__toggle\" : null;\n        const expandoFunc = this.props.rootStore.uiStore.disabledActionsOrActiveCard ? null :\n            (e) => this.props.rootStore.uiStore.updateVisibleChildren(this.props.level.id);\n\n        let isIndicatorDropdownDisabled = allIndicatorLinks.length === 0 || this.props.rootStore.uiStore.disableCardActions;\n        return (\n            <div className=\"level-card level-card--collapsed\" id={`level-card-${this.props.level.id}`}>\n                <div\n                    className={expandoClasses}\n                    onClick={expandoFunc}>\n                    {expando}\n                    <span className=\"level-card--collapsed__name\">\n                        <LevelTitle\n                            tierName={this.props.levelProps.tierName}\n                            ontologyLabel={this.props.levelProps.ontologyLabel}\n                            classes=\"level-title--collapsed\"\n                        />\n                        &nbsp;{this.props.level.name}\n                    </span>\n                </div>\n                <div className=\"level-card--collapsed__actions\">\n                    <div className=\"actions__top btn-row\">\n                        { this.props.levelProps.canDelete &&\n                            <button\n                                disabled={this.props.rootStore.uiStore.disableCardActions || this.props.rootStore.uiStore.activeCard}\n                                className=\"btn btn-sm btn-link btn-danger\"\n                                onClick={this.deleteLevel}>\n                                <i className=\"fas fa-trash-alt\"></i>{gettext(\"Delete\")}\n                            </button>\n                        }\n                        {this.props.levelProps.canEdit &&\n                            <button\n                                disabled={this.props.rootStore.uiStore.disableCardActions}\n                                className=\"btn btn-sm btn-link btn-text edit-button\"\n                                onClick={this.editLevel}>\n                                <i className=\"fas fa-edit\"/>{gettext(\"Edit\")}\n                            </button>\n                        }\n                    </div>\n                    <div className=\"actions__bottom\">\n                        <a\n                            tabIndex=\"0\"\n                            className={classNames(\"btn btn-sm btn-link no-bold\", {disabled: isIndicatorDropdownDisabled})}\n                            data-toggle=\"popover\"\n                            data-trigger=\"focus\"\n                            data-placement=\"bottom\"\n                            data-html=\"true\"\n                            title={\n                                /* # Translators: this is the title of a button to open a popup with indicator performance metrics*/\n                                gettext(\"Track indicator performance\")\n                            }\n                            data-content={indicatorMarkup}>\n                            {indicatorCountText}\n                        </a>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\n\n@inject('rootStore')\n@observer\nexport class LevelCardExpanded extends React.Component {\n    constructor(props){\n        super(props);\n        this.submitType = \"saveOnly\";\n        this.indicatorWasReordered = false;\n\n        // These 'base' vars will allow us to save orignalish data so we know whether to prompt users if they hit cancel.\n        // baseIndicators will need to be updated on indicator changes other than reordering since we don't\n        // want to warn for e.g. indicator creation, since users can't do anything about that.\n        this.baseLevelString = JSON.stringify([props.level.name, props.level.assumptions]);\n        this.baseIndicators = this.props.levelProps.indicators.slice().map( i => toJS(i));\n\n        extendObservable(this, {\n            name: props.level.name,\n            assumptions: props.level.assumptions,\n            indicators: props.levelProps.indicators.sort((a, b) => a.level_order - b.level_order),\n\n            get dataHasChanged () {\n                const baseData = this.baseLevelString + JSON.stringify(this.baseIndicators.sort( (a, b) => a.id - b.id));\n                const currentData = JSON.stringify([this.name, this.assumptions]) + JSON.stringify(toJS(this.indicators).sort( (a, b) => a.id - b.id));\n                return currentData != baseData;\n            },\n\n            addIndicator (data) {\n                this.indicators.push(data);\n                this.baseIndicators.push(data)\n            },\n\n            deleteIndicator (indicatorId) {\n                this.indicators = this.indicators.filter( i => i.id != indicatorId);\n                this.indicators.forEach( (indicator, index) => indicator.level_order = index);\n                this.baseIndicators = this.baseIndicators.filter( i => i.id != indicatorId);\n                this.baseIndicators.forEach( (indicator, index) => indicator.level_order = index);\n            },\n\n            updateIndicatorName (indicatorId, newName) {\n                this.indicators.find( i => i.id == indicatorId).name = newName;\n                this.baseIndicators.find( i => i.id == indicatorId).name = newName;\n                this.props.rootStore.levelStore.updateIndicatorNameInStore(indicatorId, newName);\n            }\n\n        }, {\n            addIndicator: action,\n            deleteIndicator: action,\n            updateIndicatorName: action\n        });\n    }\n\n    onDragEnd = ({oldIndex, newIndex}) => {\n        this.indicatorWasReordered = true;\n        const indicatorId = this.indicators[oldIndex].id;\n        const fakeChangeObj = {value: newIndex + 1, name: newIndex + 1};\n        this.changeIndicatorOrder(indicatorId, fakeChangeObj)\n    };\n\n    // Updates the indicator order, resets level_order as necessary, sets updated data flag.\n    changeIndicatorOrder = (indicatorId, changeObj) => {\n        let oldIndex = this.indicators.find( i => i.id == indicatorId).level_order;\n        let newIndex = changeObj.value - 1;\n        let tempIndicators = this.indicators.slice();\n        tempIndicators.splice(newIndex, 0, tempIndicators.splice(oldIndex, 1)[0]);\n        tempIndicators.forEach( (indicator, index) => indicator.level_order = index);\n        this.indicators.replace(tempIndicators)\n        this.props.rootStore.uiStore.activeCardNeedsConfirm = this.dataHasChanged;\n        this.indicatorWasReordered = true;\n    };\n\n    /*\n    Using this allows us to use the same submit function for all three buttons.  Shame the function has to\n    be passed all the way down to the button to work.\n     */\n    updateSubmitType = (newType) => {\n        this.submitType = newType;\n    };\n\n    componentDidUpdate() {\n        // Enable popovers after update.  This is needed for the help popover in the indicator list section.\n        // Without this, the popover doesnt' pop.\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n    componentDidMount() {\n        // Enable popovers after load (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n\n        // Handle indicator creation.  Need to update rootStore and component store so if you close and reopen the card, you still see the new indicator\n        $('#indicator_modal_div').on('created.tola.indicator.save', (e, params) => {\n            const indicatorData = {\n                id: params.indicatorId,\n                name: params.indicatorName,\n                level: this.props.level.id,\n                level_order: this.indicators.length\n            };\n            this.props.rootStore.levelStore.addIndicatorToStore(indicatorData)\n            this.addIndicator(indicatorData)\n\n        });\n\n        // Handle indicator deletion.  Need to update rootStore and component store so if you close and reopen the card, you still see the new indicator\n        $('#indicator_modal_div').on('deleted.tola.indicator.save', (e, params) => {\n            this.props.rootStore.levelStore.deleteIndicatorFromStore(params.indicatorId);\n            this.deleteIndicator(params.indicatorId)\n\n        });\n\n        // Handle indicator update.  Need to update rootStore and component store so if you close and reopen the card, you still see the new indicator\n        $('#indicator_modal_div').on('updated.tola.indicator.save', (e, params) => {\n\n            this.updateIndicatorName(params.indicatorId, params.indicatorName);\n\n            if (params.levelId != this.props.rootStore.uiStore.activeCard){\n                // Only add the indicator to another level if it wasn't blanked out\n                if (params.levelId){\n                    this.props.rootStore.levelStore.moveIndicatorInStore(params.indicatorId, params.levelId)\n                }\n                this.deleteIndicator(params.indicatorId);\n            }\n\n            // Need to remount the tooltip so it reflects a potential new name.  It's a big janky, should probably use a react component instead.\n            $('*[data-toggle=\"tooltip\"]').tooltip('dispose');\n            $('*[data-toggle=\"tooltip\"]').tooltip();\n        });\n    }\n\n    componentWillUnmount() {\n        $('#indicator_modal_div').off('updated.tola.indicator.save');\n        $('#indicator_modal_div').off('deleted.tola.indicator.save');\n        $('#indicator_modal_div').off('created.tola.indicator.save');\n    }\n\n    saveLevel = (event) => {\n        event.preventDefault();\n        const saveFunc = (rationale) => {\n            this.props.rootStore.levelStore.saveLevelToDB(\n                this.submitType,\n                this.props.level.id,\n                this.indicatorWasReordered,\n                {\n                    name: this.name,\n                    assumptions: this.assumptions,\n                    rationale: rationale,\n                    indicators: toJS(this.indicators)}\n            )};\n\n        const hasIndicators = this.indicators.length > 0;\n        const hasUpdatedAssumptions = this.props.level.assumptions.length > 0 && this.assumptions != this.props.level.assumptions;\n        const hasUpdatedName = this.name != this.props.level.name;\n\n        if ( hasIndicators && (hasUpdatedAssumptions || hasUpdatedName)){\n            create_unified_changeset_notice({\n                header: gettext(\"Reason for change\"),\n                show_icon: true,\n                message_text: gettext(\"Your changes will be recorded in a change log.  For future reference, please share your reason for these changes.\"),\n                include_rationale: true,\n                rationale_required: true,\n                notice_type: 'notice',\n                on_submit: saveFunc,\n                on_cancel: () => this.props.rootStore.uiStore.setDisableCardActions(false),\n            });\n        }\n        else {\n            saveFunc('');\n        }\n    };\n\n    cancelEdit = () => {\n        if (this.props.rootStore.levelStore.levels.length == 1 && this.props.level.id == \"new\"){\n            this.clearData();\n        }\n        else{\n            this.props.rootStore.levelStore.cancelEdit(this.props.level.id);\n        }\n    };\n\n    clearData = () => {\n        this.name = \"\";\n        this.assumptions = \"\";\n    };\n\n    onFormChange = (event) => {\n        event.preventDefault();\n        this[event.target.name] = event.target.value;\n        // Add inline error message if name field is blanked out\n        if (!this.name) {\n            const target = $(`#level-name-${this.props.level.id}`);\n            target.addClass(\"is-invalid\");\n            /* # Translators: This is a validation message given to the user when the user-editable name field has been deleted or omitted. */\n            let feedbackText = gettext('Please complete this field.');\n            target.after(`<p id=name-feedback-${this.props.level.id} class=\"invalid-feedback\">${feedbackText}</p>`);\n        }\n        else{\n            $(`#level-name-${this.props.level.id}`).removeClass(\"is-invalid\");\n            $(`#name-feedback-${this.props.level.id}`).remove();\n        }\n        this.props.rootStore.uiStore.activeCardNeedsConfirm = this.dataHasChanged;\n    };\n\n    onProgramObjectiveImport = (programObjectiveId) => {\n        const programObjective = this.props.rootStore.levelStore.programObjectives.find(po => po.id === programObjectiveId);\n\n        if (programObjective != null) {\n            this.name = programObjective.name;\n            this.assumptions = programObjective.description;\n        }\n    };\n\n    render(){\n        // Need to reference a couple of observed vars so they react to changes.\n        // Simply passing the observables through to a child component or injecting them in\n        // the child component doesn't work.  No doubt that there's a better way to do this.\n        const tempIndicators = toJS(this.indicators);\n        const disabledTrigger = this.props.rootStore.uiStore.disableCardActions;\n        const programObjectives = this.props.rootStore.levelStore.programObjectives;\n\n        let indicatorSection = \"\";\n        if (this.props.level.id == \"new\"){\n            indicatorSection = <div className=\"form-group\">\n                <button\n                    type=\"submit\"\n                    disabled={this.name.length == 0 || disabledTrigger}\n                    className=\"btn btn-link btn-lg \"\n                    onClick={e => {this.updateSubmitType(\"saveAndEnableIndicators\")}}>\n                        { /* # Translators: This is button text that allows users to save their work and unlock the ability to add indicators */ }\n                        <i className=\"fas fa-plus-circle\"/>{interpolate(gettext(\"Save %s and add indicators\"), [this.props.levelProps.tierName])}\n                </button>\n            </div>\n\n        }\n        else {\n            indicatorSection = <IndicatorList\n                level={this.props.level}\n                tierName={this.props.levelProps.tierName}\n                indicators={this.indicators}\n                disabled={!this.name || this.props.level.id == \"new\" || this.props.rootStore.uiStore.disableCardActions}\n                reorderDisabled={this.indicators.length < 2 || this.props.rootStore.uiStore.disableCardActions}\n                changeFunc={this.changeIndicatorOrder}\n                dragEndFunc={this.onDragEnd}/>\n        }\n\n\n\n        return (\n            <div className=\"level-card level-card--expanded\" id={`level-card-${this.props.level.id}`}>\n                <div className=\"d-flex justify-content-between\">\n                    <LevelTitle\n                        tierName={this.props.levelProps.tierName}\n                        ontologyLabel={this.props.levelProps.ontologyLabel}\n                        classes=\"level-title--expanded\"\n                    />\n\n                    <ProgramObjectiveImport\n                        isDisabled = {this.props.rootStore.uiStore.disableCardActions}\n                        programObjectives={programObjectives}\n                        onProgramObjectiveImport={this.onProgramObjectiveImport} />\n                </div>\n                <form className=\"level-card--expanded__form\" onSubmit={this.saveLevel}>\n                    <div className=\"form-group\">\n                        <TextareaAutosize\n                            className=\"form-control\"\n                            id={`level-name-${this.props.level.id}`}\n                            name=\"name\"\n                            value={this.name || \"\"}\n                            disabled={this.props.rootStore.uiStore.disableCardActions}\n                            autoComplete=\"off\"\n                            rows={3}\n                            onChange={this.onFormChange}\n                            maxLength={500}\n                        />\n                    </div>\n                    <div className=\"form-group\">\n                        <label htmlFor=\"assumptions\">{gettext('Assumptions')}</label>\n                        <TextareaAutosize\n                            className=\"form-control\"\n                            id=\"level-assumptions\"\n                            disabled={!this.name || this.props.rootStore.uiStore.disableCardActions}\n                            name=\"assumptions\"\n                            autoComplete=\"off\"\n                            value={this.assumptions || \"\"}\n                            rows={3}\n                            onChange={this.onFormChange}/>\n                    </div>\n                    {indicatorSection}\n                    <ButtonBar\n                        level={this.props.level}\n                        levelProps={this.props.levelProps}\n                        submitFunc={this.updateSubmitType}\n                        cancelFunc={this.cancelEdit}\n                        nameVal={this.name}\n                        tierCount={this.props.rootStore.levelStore.chosenTierSet.length}\n                    />\n                </form>\n            </div>\n\n        )\n    }\n}\n\n\n@inject('rootStore')\nclass ButtonBar extends React.Component {\n    render() {\n        let isDisabled = !this.props.nameVal || this.props.rootStore.uiStore.disableCardActions;\n\n        // Build the button text with the right sibling level name, then build the button.\n        let addAnotherButton = null;\n        if (this.props.level.parent != null && this.props.level.parent != \"root\") {\n            {/* # Translators: On a button, with a tiered set of objects, save current object and add another one in the same tier, e.g. \"Save and add another Outcome\" when the user is editing an Outcome */}\n            const buttonText = interpolate(gettext(\"Save and add another %s\"), [this.props.levelProps.tierName])\n            addAnotherButton = <LevelButton disabled={isDisabled} classes=\"btn-primary\" icon='plus-circle' text={buttonText} submitType=\"saveAndAddSibling\"  submitFunc={this.props.submitFunc} />\n        }\n\n        // Build the button text with the right child level name, then build the button.\n        let addAndLinkButton = null;\n        const tierCount = this.props.rootStore.levelStore.chosenTierSet.length;\n        if (this.props.level.level_depth < tierCount) {\n            {/* # Translators: On a button, with a tiered set of objects, save current object and add another one in the next lower tier, e.g. \"Save and add another Activity\" when the user is editing a Goal */}\n            const buttonText = interpolate(gettext(\"Save and link %s\"), [this.props.levelProps.childTierName])\n            addAndLinkButton = <LevelButton disabled={isDisabled} classes=\"btn btn-primary\" icon='stream' text={buttonText} submitType=\"saveAndAddChild\" submitFunc={this.props.submitFunc} />\n        }\n        return (\n            <div className=\"button-bar btn-row\">\n                <LevelButton disabled={isDisabled} classes=\"btn-primary\" text={gettext(\"Save and close\")} icon='save' submitType=\"saveOnly\" submitFunc={this.props.submitFunc} />\n                {addAnotherButton}\n                {addAndLinkButton}\n                <LevelButton disabled={this.props.rootStore.uiStore.disableCardActions} classes=\"btn btn-reset\" text={gettext(\"Cancel\")} submitType=\"cancel\" submitFunc={this.props.cancelFunc} />\n            </div>\n        )\n\n    }\n}\n\nclass LevelButton extends React.Component {\n\n    render() {\n        const buttonType = this.props.submitType == \"cancel\" ? \"button\" : \"submit\";\n        return (\n            <button\n                disabled={this.props.disabled}\n                type={buttonType}\n                className={this.props.classes + ' level-button btn btn-sm'}\n                onClick={() =>this.props.submitFunc(this.props.submitType)}>\n                {this.props.text}\n                {/*this.props.icon ?  <FontAwesomeIcon icon={this.props.icon} /> : ''*/}\n            </button>\n        )\n\n    }\n}\n\n@inject('rootStore')\nclass IndicatorList extends React.Component {\n\n    componentDidMount() {\n        // Enable popovers after update (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n\n        $('*[data-toggle=\"tooltip\"]').tooltip()\n    }\n\n    componentDidUpdate() {\n        $('*[data-toggle=\"tooltip\"]').tooltip()\n    }\n\n    render() {\n\n        // Create the list of indicators and the dropdowns for setting the indicator order\n        let options = this.props.indicators.map( (entry, index) => {return {value: index+1, label: index+1}});\n\n        let indicatorMarkup = this.props.indicators.map ( (indicator) => {\n            // let options = this.props.indicators.map( (entry, index) => <option value={index+1}>{index+1}</option>);\n            const tipTemplate = '<div class=\"tooltip sortable-list__item__tooltip\" role=\"tooltip\"><div class=\"arrow\"></div><div class=\"tooltip-inner\"></div></div>';\n            const indicator_label =\n                <span data-toggle=\"tooltip\" data-delay={900} data-template={tipTemplate} title={indicator.name}>\n                    <span>{indicator.name.replace(/(.{55})..+/, \"$1...\")}</span>\n                </span>\n            return (\n                <React.Fragment>\n                    <SingleReactSelect\n                        update={(value) => this.props.changeFunc(indicator.id, value)}\n                        selectId={\"ind\"+indicator.id}\n                        labelClasses=\" \"\n                        formRowClasses=\"sortable-list__item__label\"\n                        selectClasses=\"sortable-list__item__select\"\n                        value={{value: indicator.level_order, label: indicator.level_order + 1}}\n                        label={indicator_label}\n                        options={options}\n                        disabled={this.props.disabled || this.props.reorderDisabled}\n                    />\n                    <div className=\"sortable-list__item__actions\">\n                        { /* # Translators: A label for a button that allows the user to modify the settings of an object */}\n                        <UpdateIndicatorButton\n                            readonly={this.props.disabled || this.props.rootStore.uiStore.disableCardActions}\n                            label={gettext(\"Settings\")}\n                            indicatorId={indicator.id}/>\n                    </div>\n                </React.Fragment>\n            )\n        });\n\n        // Conditionally set the other elements that are only visible when there are indicators\n        let order = null;\n        let helpLink = null;\n        const migratedProgramPopOverContent =\n            /* # Translators: Popover for help link telling users how to associate an Indicator not yet linked to a Level */\n            gettext('To link an already saved indicator to your results framework: Open the indicator from the program page and use the Result level menu on the Summary tab.');\n        /* # Translators: Popover for help link, tell user how to disassociate an Indicator from the Level they are currently editing. */\n        const popOverContent=gettext('To remove an indicator: Click Settings, where you can reassign the indicator to a different level or delete it.');\n\n        const usingResultsFramework = this.props.rootStore.levelStore.usingResultsFramework;\n        const popOverStr = !usingResultsFramework ? migratedProgramPopOverContent + '<br><br>' + popOverContent : popOverContent;\n\n        if (this.props.indicators.length > 0 || !usingResultsFramework) {\n            order = \"Order\";\n            helpLink =\n                <HelpPopover\n                    content={popOverStr}\n                    placement=\"bottom\"/>\n        }\n        return(\n            <div className={`level-card--indicator-links${this.props.disabled ? \" disabled\" : \"\"}`}>\n                <div className=\"indicator-links__header\">\n                    { /* # Translators: Title for a section that lists the Indicators associated with whatever this.props.tiername is. */}\n                    <h4>{interpolate(gettext(\"Indicators linked to this %s\"), [this.props.tierName])}</h4>\n                    <div>{helpLink}</div>\n                </div>\n                <div className=\"sortable-list-group\">\n                    { this.props.indicators.length > 0 ?\n                        <div className=\"sortable-list-header\">\n                            { /* TODO: this header is super janky. See _sortable-list.scss for future proofing with css subgrid */ }\n                            <div className=\"sortable-list-header__drag-handle\"><FontAwesomeIcon icon={faArrowsAlt} /></div>\n                            <div className=\"sortable-list-header__label\">\n                                {order}\n                            </div>\n                            <div className=\"sortable-list-header__actions\">\n                                <i className=\"fas fa-cog\"></i> { gettext(\"Settings\") }\n                            </div>\n                        </div>\n                    :\n                        null\n                    }\n                    <SortableContainer onSortEnd={this.props.dragEndFunc} useDragHandle lockAxis=\"y\" lockToContainerEdges>\n                        {indicatorMarkup.map((value, index) => (\n                            <SortableItem\n                                key={`item-${index}`}\n                                index={index}\n                                value={value}\n                                disabled={this.props.disabled || this.props.reorderDisabled} />\n                        ))}\n                    </SortableContainer>\n                    <div className=\"sortable-list-actions\">\n                        <AddIndicatorButton\n                            readonly={ !this.props.level.id || this.props.level.id == 'new' || this.props.disabled || this.props.rootStore.uiStore.disableCardActions }\n                            programId={ this.props.rootStore.levelStore.program_id }\n                            levelId={ this.props.level.id }/>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\nconst SortableItem = sortableElement(({value}) => <li className=\"sortable-list__item\"><DragHandle/>{value}</li>);\n\nconst SortableContainer = sortableContainer(({children}) => {\n    return <ul className=\"sortable-list\">{children}</ul>;\n});\n\nconst DragHandle = sortableHandle(() => <div className=\"sortable-list__item__drag-handle\"><FontAwesomeIcon icon={faArrowsAlt} /></div>);\n","import React from 'react';\nimport Select from 'react-select';\nimport ReactMultiSelectCheckboxes from 'react-multiselect-checkboxes';\nimport { uniqueId } from '../formUtils';\nimport { GROUP_BY_CHAIN, GROUP_BY_LEVEL } from '../constants';\n\n\n\nexport const SingleReactSelect = ( props ) => {\n    let selectId = uniqueId('react-select');\n    let labelClasses = props.labelClasses || \"col-form-label text-uppercase\";\n    let formRowClasses = props.formRowClasses || \"form-row mb-3\";\n    let selectClasses = props.selectClasses || \"tola-react-select\";\n    return (\n        <div className={ formRowClasses }>\n            <label\n                htmlFor={ selectId }\n                className={ labelClasses }>\n                    { props.label }\n            </label>\n            <Select\n                onChange={ props.update }\n                value={ props.value }\n                id={ selectId }\n                className={ selectClasses }\n                isDisabled={ props.disabled }\n                options={ props.options }\n            />\n        </div>\n    );\n}\n\nexport const DateSelect = ( props ) => {\n    let selectId = uniqueId('date-select');\n    let formattedOptions =\n        (props.options && props.options.length == 1 && props.options[0].value !== undefined) ?\n            <option value={ props.options[0].value }>{ props.options[0].label }</option> :\n            (props.options && props.options.length > 0 && props.options[0].options && props.options[0].options !== undefined) ?\n                props.options.map(\n                    (optgroup, index) => {\n                        return <optgroup label={ optgroup.label } key={ index }>\n                                    {optgroup.options.map(\n                                        option => (<option value={ option.value } key={ option.value }>\n                                                        { option.label }\n                                                   </option>)\n                                        )\n                                    }\n                                </optgroup>\n                        }) :\n                props.options.map(\n                    (option, index) => {\n                        return <option value={ option.value } key={ index }>{ option.label }</option>;\n                    }\n                );\n\n    return (\n        <div className=\"form-row mb-3\">\n            <label\n                htmlFor={ selectId }\n                className=\"col-form-label text-uppercase\">\n                    { props.label }\n            </label>\n            <select\n                className=\"form-control\"\n                id={ selectId }\n                value={ props.value }\n                onChange = { props.update }\n                disabled = { props.disabled }>\n                { formattedOptions }\n            </select>\n        </div>\n    );\n}\n\nexport const SingleSelect = ( props ) => {\n    let selectId = uniqueId('react-select');\n    let formGroupClass = props.formGroupClass || \"form-row mb-3\";\n    let labelClass = props.labelClass || \"col-form-label text-uppercase\";\n    let selectClass = props.selectClass || \"form-control\";\n    return (\n        <div className={ formGroupClass }>\n            <label\n                htmlFor={ selectId }\n                className={ labelClass }>\n                    { props.label }\n            </label>\n            <select\n                onChange={ props.update }\n                value={ props.value }\n                id={ selectId }\n                className={ selectClass }\n                disabled={ props.disabled }>\n                { props.options }\n            </select>\n        </div>\n    );\n}\n\n\n/**\n * styling element to replace OptGroup headings in react multiselect checkbox widgets - used for\n * MultiSelectCheckbox when optgroups are required\n */\nconst GroupHeading = (props) => {\n    if (props.children == '') {\n        return <div></div>;\n    } else {\n        return (\n            <React.Fragment>\n                <hr style={{ margin: '3px 0px 0px 0px' }} />\n                <div className=\"text-muted\"\n                     style={{ textTransform: 'uppercase',\n                              paddingLeft: '4px',\n                              marginBottom: '2px'}}>\n                    { props.children }\n                </div>\n            </React.Fragment>\n            );\n    }\n}\n\n\n/**\n * Styles ReactMultiSelectCheckbox to fit Tola styles\n */\nexport const MultiSelectCheckbox = ( props ) => {\n    const selectId = uniqueId('multiselect');\n    const blankOptions = (!props.options ||\n                          props.options.length == 0 ||\n                         (props.options.length == 1 && props.options[0].value === null));\n    const multiSelectProps = blankOptions ?\n            {\n                getDropdownButtonLabel: () => gettext('None available'),\n                isDisabled: true,\n                menuIsOpen: false,\n                options: [],\n            } :\n            {\n                isMulti: true,\n                options: props.options,\n                getDropdownButtonLabel: (_ref) => {\n                    if (!_ref.value) {\n                        return gettext('None selected');\n                    }\n                    if (Array.isArray(_ref.value)) {\n                        let options = _ref.value.filter(option => !option.noList);\n                        if (options.length == 0) {\n                            return gettext('None selected');\n                        }\n                        if (options.length == 1) {\n                            return options[0].label;\n                        }\n                        return `${options.length}  ${gettext('selected')}`;\n                    }\n                    return _ref.value.label;\n                }\n            };\n    const baseStyles = {\n        dropdownButton: base => blankOptions ? { ...base, backgroundColor: '#E5E6E8', background: '' } : base,\n        option: (provided, state) => ({\n                ...provided,\n                padding: '1px 12px',\n                display: 'inline-block'\n            }),\n        container: (provided, state) => ({\n                ...provided,\n                backgroundColor: '#f5f5f5'\n            }),\n    };\n    const formatOptionLabel = (props) => {\n        return <div style={{ display: \"inline-block\" , float: \"right\", width: \"90%\"}}>{props.label}</div>;\n    };\n    return (\n        <div className=\"form-row mb-2 tola-react-multiselect-row\">\n            <label htmlFor={ selectId } className=\"col-form-label text-uppercase\">\n                { props.label }\n            </label>\n            <ReactMultiSelectCheckboxes\n                id={ selectId }\n                styles={ baseStyles }\n                formatOptionLabel = { formatOptionLabel }\n                components={{ GroupHeading }}\n                value={ props.value }\n                onChange={ props.update }\n                { ...multiSelectProps }\n            />\n        </div>\n    );\n}\n\nexport const GroupBySelect = ({ chainLabel, ...selectProps }) => {\n    let options = [\n        <option value={ GROUP_BY_CHAIN } key={1}>{ chainLabel }</option>,\n        <option value={ GROUP_BY_LEVEL } key={2}>{\n            /* # Translators: refers to grouping the report by the level of the indicator */\n            gettext('by Level')\n        }</option>\n    ];;\n    return <SingleSelect\n                label={\n                    /* # Translators: menu for selecting how rows are grouped in a report */\n                    gettext('Group indicators')\n                }\n                options={ options }\n                { ...selectProps }\n            />;\n}\n","import { observable, computed, action, toJS, runInAction, autorun } from \"mobx\";\nimport { api } from \"../../api.js\"\nimport { create_unified_changeset_notice } from '../../components/changesetNotice';\n\nexport class RootStore {\n    constructor (program, levels, indicators, levelTiers, tierTemplates, englishTemplates, customTemplates, programObjectives, accessLevel, usingResultsFramework, maxTiers) {\n        this.levelStore =  new LevelStore(program, levels, indicators, levelTiers, tierTemplates, englishTemplates, customTemplates, programObjectives, accessLevel, usingResultsFramework, maxTiers, this);\n        this.uiStore = new UIStore(this);\n    }\n}\n\nexport class LevelStore {\n    @observable levels = [];\n    @observable indicators = [];\n    @observable chosenTierSetKey = \"\";\n    @observable useStaticTierList = \"\";\n    @observable formErrors;\n    @observable tierTemplates = \"\";\n    program_id;\n    tierTemplates;\n    programObjectives;\n    defaultTemplateKey = \"\";\n    customTierSetKey = \"\";\n    accessLevel = false;\n    usingResultsFramework;\n\n    constructor(program, levels, indicators, levelTiers, tierTemplates, englishTemplates, customTemplates, programObjectives, accessLevel, usingResultsFramework, maxTiers, rootStore) {\n        this.rootStore = rootStore;\n        this.levels = levels;\n        this.indicators = indicators;\n        this.englishTierTemlates = JSON.parse(englishTemplates);\n        this.defaultTemplateKey = \"mc_standard\";\n        this.customTierSetKey = \"custom\";\n        this.program_id = program.id;\n        this.manual_numbering = program.manual_numbering;\n        this.programObjectives = programObjectives;\n        this.accessLevel = accessLevel;\n        this.usingResultsFramework = usingResultsFramework;\n        this.formErrors = {hasError: false};\n        this.maxTiers = maxTiers;\n        this.excelURL = `/indicators/results_framework_export/${program.id}/`;\n\n        this.tierTemplates = JSON.parse(tierTemplates);\n        this.tierTemplates[this.customTierSetKey] = {name: gettext(\"Custom\")};\n        this.tierTemplates[this.customTierSetKey]['tiers'] = customTemplates.names || [\"\"];\n\n        // Set the stored tier set key and the values, if they exist.  Use the default if they don't.\n        if (levelTiers.length > 0) {\n            const origLevelTiers = levelTiers.map( t => t.name);\n            this.chosenTierSetKey = this.deriveTemplateKey(origLevelTiers);\n        }\n        else {\n            this.chosenTierSetKey = this.defaultTemplateKey;\n        }\n\n        this.useStaticTierList  =  !(this.chosenTierSetKey === this.customTierSetKey && this.levels.length === 0);\n    }\n\n    @computed get sortedLevels () {\n        return this.levels.slice().sort((a, b) => {a.level_depth - b.level_depth || a.customsort - b.customsort})\n    }\n\n    @computed get chosenTierSet () {\n        return this.tierTemplates[this.chosenTierSetKey]['tiers'];\n    }\n\n\n    @computed get levelProperties () {\n        let levelProperties = {};\n\n        for (let level of this.levels) {\n            let properties = {};\n            const childrenIds = this.getChildLevels(level.id).map( l => l.id);\n            const indicatorCount = this.indicators.filter( i => i.level == level.id);\n\n            properties['indicators'] = this.getLevelIndicators(level.id);\n            properties['descendantIndicatorIds'] = this.getDescendantIndicatorIds(childrenIds);\n            properties['ontologyLabel'] = this.buildOntology(level.id);\n            properties['tierName'] = this.chosenTierSet[level.level_depth-1];\n            properties['childTierName'] = null;\n            if (this.chosenTierSet.length > level.level_depth) {\n                properties['childTierName'] = this.chosenTierSet[level.level_depth];\n            }\n\n            properties['canDelete'] = childrenIds.length==0 && indicatorCount==0 && this.hasEditPermissions;\n            properties['canEdit'] = this.hasEditPermissions;  // TODO: is this really necessary?\n            levelProperties[level.id] = properties;\n        }\n\n        return levelProperties\n    }\n\n    @computed get chosenTierSetName () {\n        return this.tierTemplates[this.chosenTierSetKey]['name'];\n    }\n\n    @computed get hasEditPermissions () {\n        return this.accessLevel === 'high';\n    }\n\n    // This monitors the number of indicators attached to the program and adds/removes the header link depending on\n    // whether there are indicators.  It relies on all indicators being passed up from the server each time\n    // the indicator list is refreshed.\n    monitorHeaderLink = autorun( reaction => {\n        let headerSpan = $(\"#rf_builder_header\");\n        let linkedFlag = headerSpan.children(\"a\").length > 0;\n        if (this.indicators.length > 0 && !linkedFlag ) {\n            const headerText = headerSpan.text();\n            headerSpan.html(`<a href=\"/program/${this.program_id}/\">${headerText}</a>`)\n        }\n        else if (this.indicators.length == 0 && linkedFlag) {\n            const headerText = $(\"#rf_builder_header > a\").text();\n            headerSpan.text(headerText);\n        }\n    // delay is needed to prevent undefined value from being used for program_id that isn't set yet on first load.\n    }, {delay: 50});\n\n    @action\n    changeTierSet(newTierSetKey) {\n        const oldTopTier = this.chosenTierSet[0];\n        this.chosenTierSetKey = newTierSetKey;\n        if (this.chosenTierSetKey === this.customTierSetKey) {\n            this.editTierSet();\n\n            // Set a default first tier in the event the user is switching from a defined template to a blank custom one\n            // It's a bit of a hack, since new custom levels should be kept in the local component state and\n            // the root store would only be modified when the \"Apply\" button was pressed.  But this is easier\n            // than passing an the old level down to the component and the only downside seems a slightly sticky\n            // first tier value when you switch from a pre-defined template, to custom, and back to pre-defined, and\n            // back to custom again.  How did I write so much about 3 lines of code?\n            if (!this.tierTemplates[this.customTierSetKey]['tiers'][0]\n                && this.levels.filter(level=>level.id !== \"new\").length === 1) {\n                    this.tierTemplates[this.customTierSetKey]['tiers'] = [gettext(oldTopTier)]\n            }\n        }\n        else {\n            this.rootStore.uiStore.customFormErrors = {hasErrors: false, errors: []};\n            this.rootStore.uiStore.setDisableCardActions(false);\n        }\n        if (this.levels.length > 0 && this.chosenTierSetKey !== this.customTierSetKey) {\n            const result = this.saveLevelTiersToDB();\n            result.then(result => {\n                if (this.chosenTierSetKey !== this.customTierSetKey && this.levels.filter(level=>level.id !== \"new\").length > 0 ) {\n                    success_notice({\n                        // # Translators: Notification to user that the an update was successful\n                        message_text: gettext(\"Changes to the results framework template were saved.\"),\n                        addClass: 'program-page__rationale-form',\n                        stack: {\n                            dir1: 'up',\n                            dir2: 'right',\n                            firstpos1: 20,\n                            firstpos2: 20,\n                        }\n                    })\n                }\n            }).catch(error => {\n                // Ok, I know this is dumb, but we're in the middle of a revamp of the alerts and I don't\n                // want to add to the mess.  Punting.\n                console.log(\"There was an error saving the template to the database\")\n            })\n        }\n    }\n\n    @action\n    updateCustomTier = (event) => {\n        this.tierTemplates[this.customTierSetKey]['tiers'][event.target.dataset.tierorder] = event.target.value;\n    };\n\n    @action\n    addCustomTier = () => {\n        this.rootStore.uiStore.setAddLevelButtonLockedStatus(true);\n        this.saveCustomTemplateToDB({addTier: true});\n\n    };\n\n    @action\n    deleteCustomTier = (event) => {\n        // This prevents the delete button getting triggered when the user tabs out of the text area\n        // Need to check if a) there was an interaction other than tab and b) if the action was a key press, was it an 'Enter' key?\n        if ((event.detail === 0 && !event.key) || (event.key && event.key != \"Enter\")) {\n            return false;\n        }\n\n        if (this.chosenTierSet.length === 1){\n            this.tierTemplates[this.customTierSetKey]['tiers'] = [\"\"];\n            this.rootStore.uiStore.clearValidationMessages()\n        }\n        else{\n            this.tierTemplates[this.customTierSetKey]['tiers'].pop();\n            this.rootStore.uiStore.validateCustomTiers()\n        }\n\n        this.saveCustomTemplateToDB({isDeleting: true});\n    };\n\n    @action\n    applyTierSet = (event=null) => {\n        if (event) {\n            event.preventDefault();\n        }\n        if (this.chosenTierSetKey === this.customTierSetKey\n            && this.rootStore.uiStore.customFormErrors.hasErrors){\n            return false;\n        }\n        this.saveLevelTiersToDB();\n\n        if (this.chosenTierSetKey === this.customTierSetKey){\n            this.rootStore.uiStore.validateCustomTiers();\n            if (this.rootStore.uiStore.customFormErrors.hasErrors) return;\n            this.saveCustomTemplateToDB({shouldAlert: true});\n            this.useStaticTierList = true;\n        }\n        if (this.levels.length === 0) {\n            this.createFirstLevel();\n        }\n        this.rootStore.uiStore.setDisableCardActions(false)\n    };\n\n    @action\n    editTierSet = () => {\n        this.useStaticTierList = false;\n        this.rootStore.uiStore.setDisableCardActions(true)\n    };\n\n    saveCustomTemplateToDB = (options={}) => {\n        // TODO: Find a better way to handle options.  e.g. return a promise to the applyTierSet function and force it to do the alerting.\n        var {addTier, isDeleting, shouldAlert} = options;\n        if (!isDeleting) {\n            this.rootStore.uiStore.validateCustomTiers();\n            if (this.rootStore.uiStore.customFormErrors.hasErrors) return;\n        }\n        let tiersToSave = [...this.tierTemplates[this.customTierSetKey]['tiers']];\n        if (tiersToSave[0].length === 0) {\n            tiersToSave = null\n        }\n\n        const data = {program_id: this.program_id, tiers: tiersToSave};\n        api.post(`/save_custom_template/`, data)\n            .then(response => {\n                // Only notify of success if the tiers have changed.\n                if (shouldAlert) {\n                    success_notice({\n                        /* # Translators: Notification to user that the update they initiated was successful */\n                        message_text: gettext(\"Changes to the results framework template were saved.\"),\n                        addClass: 'program-page__rationale-form',\n                        stack: {\n                            dir1: 'up',\n                            dir2: 'right',\n                            firstpos1: 20,\n                            firstpos2: 20,\n                        }\n                    });\n                }\n                if (addTier) {\n                    // Protect against \"Add level\" button smashing by checking if the last value of the tier set is an empty string.\n                    if (this.chosenTierSet.slice(-1) != \"\") {\n                        this.chosenTierSet.push(\"\");\n                    }\n                }\n                this.rootStore.uiStore.setAddLevelButtonLockedStatus(false);\n\n            })\n            .catch(error => {\n                this.rootStore.uiStore.setAddLevelButtonLockedStatus(false);\n                console.log('error', error);\n            })\n    };\n\n    @action\n    cancelEdit = levelId => {\n        if (levelId == \"new\") {\n            const targetLevel = this.levels.find(l => l.id == levelId);\n\n            // First update any customsort values that were modified when this card was created\n            let siblingsToReorder = this.levels.filter(l => {\n                return l.customsort > targetLevel.customsort && l.parent == targetLevel.parent;\n            });\n            siblingsToReorder.forEach(sib => sib.customsort -= 1);\n\n            // Now remove the new card\n            this.levels.replace(this.levels.filter((element) => element.id != \"new\"));\n        }\n\n        this.fetchIndicatorsFromDB();\n        this.rootStore.uiStore.removeActiveCard();\n    };\n\n    @action\n    createNewLevelFromSibling = (siblingId) => {\n        // Copy sibling data for the new level and then clear some of it out\n        let sibling = toJS(this.levels.find( l => l.id == siblingId));\n        let newLevel = Object.assign({}, sibling);\n        newLevel.customsort += 1;\n        newLevel.id = \"new\";\n        newLevel.name = \"\";\n        newLevel.assumptions = \"\";\n\n        // bump the customsort field for siblings that come after the inserted Level\n        let siblingsToReorder = this.levels.filter( l => {\n            return sibling && l.customsort > sibling.customsort && l.parent == sibling.parent;\n        });\n        siblingsToReorder.forEach( sib => sib.customsort+=1);\n        // add new Level to the various Store components\n        this.rootStore.uiStore.activeCard = \"new\";\n        this.levels.push(newLevel);\n        setTimeout(\n            function(){$(\"#level-card-new\")[0].scrollIntoView({behavior:\"smooth\"})},\n            100\n        )\n    };\n\n    @action\n    createNewLevelFromParent = (parentId) => {\n        // Copy data for the new level and then clear some of it out\n        let parent = toJS(this.levels.find( l => l.id == parentId));\n        let newLevel = {\n            id:\"new\",\n            customsort: 1,\n            name: \"\",\n            assumptions: \"\",\n            parent: parentId,\n            level_depth: parent.level_depth + 1,\n            program: this.program_id\n        };\n\n        // bump the customsort field for siblings that come after the inserted Level\n        let siblingsToReorder = this.levels.filter( l => l.parent == parentId);\n\n        siblingsToReorder.forEach( sib => sib.customsort+=1);\n        // add new Level to the various Store components\n        this.levels.push(newLevel);\n        this.rootStore.uiStore.activeCard = \"new\";\n        this.rootStore.uiStore.hasVisibleChildren.push(newLevel.parent)\n\n    };\n\n    @action\n    createFirstLevel = () => {\n        // Using \"root\" for parent id so the Django view can distinguish between top tier level and 2nd tier level\n        let newLevel = {\n            id: \"new\",\n            program: this.program_id,\n            name: \"\",\n            assumptions: \"\",\n            customsort: 1,\n            level_depth: 1,\n            parent: \"root\"\n        };\n        this.levels.push(newLevel);\n        this.rootStore.uiStore.activeCard = \"new\";\n    };\n\n    saveLevelTiersToDB = () => {\n        const tier_data = {program_id: this.program_id};\n        if (this.chosenTierSetKey === this.customTierSetKey) {\n            tier_data.tiers = this.chosenTierSet;\n        }\n        else {\n            tier_data.tiers = this.englishTierTemlates[this.chosenTierSetKey]['tiers']\n        }\n        // Need to catch errors for this\n        return api.post(`/save_leveltiers/`, tier_data)\n    };\n\n    deleteLevelFromDB = (levelId) => {\n        const level_label = `${this.levelProperties[levelId]['tierName']} ${this.levelProperties[levelId]['ontologyLabel']}`;\n        api.delete(`/level/${levelId}`)\n            .then(response => {\n                this.levels.replace(response.data);\n                this.rootStore.uiStore.activeCard = null;\n                if (this.levels.length == 0){\n                    this.createFirstLevel()\n                }\n                success_notice({\n                    /* # Translators: Notification to user that the deletion command that they issued was successful */\n                    message_text: interpolate(gettext(\"%s was deleted.\"), [level_label]),\n                    addClass: 'program-page__rationale-form',\n                    stack: {\n                        dir1: 'up',\n                        dir2: 'right',\n                        firstpos1: 20,\n                        firstpos2: 20,\n                    }\n                })\n            })\n            .catch(error => console.log('error', error))\n\n        this.rootStore.uiStore.setDisableCardActions(false);\n    };\n\n\n    // TODO: better error handling for API\n    saveLevelToDB = (submitType, levelId, indicatorWasUpdated, formData) => {\n        // if indicators have been updated, call a separate save method and remove the data from object that will be sent with the level saving post request\n        if (indicatorWasUpdated) {\n            this.saveReorderedIndicatorsToDB(formData.indicators)\n        }\n        delete formData.indicators;\n\n        // Now process the save differently depending on if it's a new level or a pre-existing one.\n        let targetLevel = this.levels.find(level => level.id == levelId);\n        const level_label = `${this.levelProperties[levelId].tierName} ${this.levelProperties[levelId].ontologyLabel}`;\n        let levelToSave = Object.assign(toJS(targetLevel), formData);\n        const levelDataWasUpdated = this.rootStore.uiStore.activeCardNeedsConfirm;\n        if (levelId == \"new\") {\n            if (levelToSave.parent == \"root\") {\n                $('#logframe_link').show();\n            }\n\n            // Don't need id, since it will be \"new\", and don't need rationale, since it's a new level.\n            delete levelToSave.id;\n            delete levelToSave.rationale;\n            api.post(`/insert_new_level/`, levelToSave)\n                .then(response => {\n                    runInAction(() => {\n                        this.levels.replace(response.data['all_data'])\n                    });\n                    success_notice({\n                        // # Translators: This is a confirmation message that confirms that change has been successfully saved to the DB.\n                        message_text: interpolate(gettext(\"%s saved.\"), [level_label]),\n                        addClass: 'program-page__rationale-form',\n                        stack: {\n                            dir1: 'up',\n                            dir2: 'right',\n                            firstpos1: 20,\n                            firstpos2: 20,\n                        }\n                    });\n\n                    const newId = response.data[\"new_level\"][\"id\"];\n                    this.rootStore.uiStore.activeCard = null;\n                    if (submitType == \"saveAndEnableIndicators\") {\n                        runInAction( () => {\n                           this.rootStore.uiStore.activeCard = newId;\n                        });\n                    }\n                    else if (submitType == \"saveAndAddSibling\"){\n                        this.createNewLevelFromSibling(newId);\n\n                    }\n                    else if (submitType == \"saveAndAddChild\"){\n                        this.createNewLevelFromParent(newId);\n\n                    }\n                })\n                .catch(error => console.log('error', error))\n\n        } else {\n            api.put(`/level/${levelId}/`, levelToSave)\n                .then(response => {\n                    if (levelDataWasUpdated || indicatorWasUpdated) {\n                        success_notice({\n                            // # Translators:  Confirmation message that user-supplied updates were successfully applied.\n                            message_text: interpolate(gettext(\"%s updated.\"), [level_label]),\n                            addClass: 'program-page__rationale-form',\n                            stack: {\n                                dir1: 'up',\n                                dir2: 'right',\n                                firstpos1: 20,\n                                firstpos2: 20,\n                            }\n                        });\n                    }\n                    runInAction( () => {\n                        Object.assign(targetLevel, response.data);\n                    });\n                    this.rootStore.uiStore.activeCard = null;\n                    if (submitType == \"saveAndAddSibling\"){\n                        this.createNewLevelFromSibling(levelId);\n                    }\n                    else if (submitType == \"saveAndAddChild\"){\n                        this.createNewLevelFromParent(levelId);\n                    }\n\n                })\n                .catch( error => {\n                    console.log(\"There was an error:\", error);\n                })\n        }\n\n        this.fetchIndicatorsFromDB();\n\n        this.rootStore.uiStore.activeCardNeedsConfirm = false;\n    };\n\n    saveReorderedIndicatorsToDB = indicators => {\n        api.post(\"/reorder_indicators/\", indicators)\n                .then(response => {\n                   this.fetchIndicatorsFromDB()\n                })\n                .catch( error => {\n                    console.log(\"There was an error:\", error);\n                })\n    };\n\n    @action\n    updateIndicatorNameInStore(indicatorId, newName) {\n        this.indicators.find( i => i.id == indicatorId).name = newName;\n    }\n\n    @action\n    deleteIndicatorFromStore = (indicatorId, levelId) => {\n        this.indicators = this.indicators.filter( i => i.id != indicatorId);\n        this.indicators\n            .filter( i => i.level == levelId)\n            .sort( (a, b) => a.level_order - b.level_order)\n            .forEach( (indicator, index) => indicator.level_order = index);\n    };\n\n    @action\n    addIndicatorToStore = (indicatorData) => {\n        this.indicators.push(indicatorData);\n    };\n\n    @action\n    moveIndicatorInStore = (indicatorId, newLevelId) => {\n        let target = this.indicators.find( i => i.id == indicatorId);\n        target.level = newLevelId;\n        target.level_order = this.indicators.filter( i => i.level == newLevelId).length -1;\n    };\n\n    fetchIndicatorsFromDB = (indicatorId=null) => {\n        const indicatorQParam = indicatorId ? `?indicatorId=${indicatorId}` : \"\";\n        api.get(`/indicator_list/${this.program_id}/${indicatorQParam}`)\n            .then((response) => runInAction(() => {\n                this.indicators = response.data;\n            }))\n            .catch((error) => console.log('There was an error:', error));\n    };\n\n    deriveTemplateKey = (origLevelTiers) => {\n        // Check each tier set in the templates to see if the tier order and content are exactly the same\n        // If they are, return the template key\n        const levelTierStr = JSON.stringify(toJS(origLevelTiers));\n        for (let templateKey in this.englishTierTemlates){\n            // not an eligable template if the key is inherited or if the lengths of the tier sets don't match.\n            if (!this.englishTierTemlates.hasOwnProperty(templateKey) ||\n                origLevelTiers.length != this.englishTierTemlates[templateKey]['tiers'].length) {\n                continue;\n            }\n            const templateValuesStr = JSON.stringify(this.englishTierTemlates[templateKey]['tiers']);\n            if (levelTierStr == templateValuesStr) {\n                return templateKey;\n            }\n        }\n\n        // If this has been reached, the db has stored tiers but they're not a match to a template\n        return this.customTierSetKey;\n    };\n\n\n    buildOntology = (levelId, ontologyArray = []) => {\n        let level = toJS(this.levels.find( l => l.id == levelId));\n        /*  If there is no parent (saved top tier level) or the parent is \"root\" (unsaved top tier level)\n            then we should return with adding to the ontology because there is no ontology entry for the top tier\n         */\n        if (level.parent && level.parent != \"root\") {\n            ontologyArray.unshift(level.customsort);\n            return this.buildOntology(level.parent, ontologyArray);\n        }\n        else {\n            return ontologyArray.join(\".\");\n        }\n    };\n\n    getChildLevels = levelId => this.levels.filter( l => l.parent == levelId);\n\n    getLevelIndicators = levelId => this.indicators.filter( i => i.level == levelId);\n\n    getDescendantIndicatorIds = (childLevelIds) => {\n        const childLevels = this.levels.filter( l => childLevelIds.includes(l.id));\n        let newIndicatorIds = [];\n        childLevels.forEach( childLevel => {\n            newIndicatorIds = newIndicatorIds.concat(this.indicators.filter( i => i.level == childLevel.id).map( i => i.id));\n            let grandChildIds = this.levels.filter( l => l.parent == childLevel.id).map( l => l.id);\n            newIndicatorIds = newIndicatorIds.concat(this.getDescendantIndicatorIds(grandChildIds, newIndicatorIds));\n        });\n        return newIndicatorIds\n    };\n\n    tierIsDeletable = (tierLevel) => {\n        for (let level of this.levels) {\n            if (level.level_depth === tierLevel && level.name.length > 0){\n                return false;\n            }\n        }\n        return true;\n    };\n\n}\n\n\nexport class UIStore {\n\n    @observable activeCard;\n    @observable hasVisibleChildren = [];\n    @observable disableCardActions;\n    @observable customFormErrors;\n    @observable addLevelButtonIsLocked;\n    activeCardNeedsConfirm = \"\";\n\n    constructor (rootStore) {\n        this.rootStore = rootStore;\n        this.hasVisibleChildren = this.rootStore.levelStore.levels.map(l => l.id);\n        this.activeCardNeedsConfirm = false;\n        this.activeCard = null;\n        this.disableCardActions = false;\n        this.customFormErrors = {hasErrors: false, errors: []};\n        this.addLevelButtonIsLocked = false;  //used to prevent creating two new levels by smashing the Add Level button\n\n        this.splashWarning = gettext('<strong class=\"text-danger\">Choose your results framework template carefully!</strong> Once you begin building your framework, it will not be possible to change templates without first deleting saved levels.')\n    }\n\n    @computed get tierLockStatus () {\n        // Tiers should be locked if user doesn't have write permissions or when more than one level exists,\n        // regardless of saved or unsaved.  Allowing a second (unsaved) level to lock the tier\n        // switcher prevents a user from adding a second level and switching to a custom template before saving the\n        // level they're currently editing.  This could be a problem because there are two levels and potentially\n        // no second tier that corresponds to the second level.\n        if  (!this.rootStore.levelStore.hasEditPermissions || this.rootStore.levelStore.levels.length > 1) {\n            return \"locked\";\n        }\n        // The apply button should not be visible if there is only one level visible (i.e. saved to the db or not)\n        else if (this.rootStore.levelStore.levels.length > 0){\n            return \"primed\"\n        }\n        return null;\n    }\n\n    // This calculation is used in to decide if the Expand All button on in the level list should be disabled or not.\n    // Need count all nodes excluding leaf nodes, which is the how many id's will be in the\n    // hasVisibleChildren count if a user manually expands all of the level cards.\n    @computed get isExpandAllDisabled () {\n        if (this.rootStore.levelStore.levels.length == 0 ||\n            this.disableCardActions||\n            this.activeCard) {\n            return true;\n        }\n        else {\n            let parents = new Set(this.rootStore.levelStore.levels.map(level => level.parent));\n            parents = Array.from(parents).filter( p => p != null);\n            const sortedHasVisibleChildren = new Set([...this.hasVisibleChildren]);\n\n            for (var elem of parents) {\n                if (!sortedHasVisibleChildren.has(elem)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    @computed get disabledActionsOrActiveCard() {\n        return this.disableCardActions || this.activeCard;\n    }\n\n    @action\n    editCard = (levelId) => {\n        const cancelledLevelId = this.activeCard;\n        if (this.activeCardNeedsConfirm) {\n            this.setDisableCardActions(true);\n            $(`#level-card-${this.activeCard}`)[0].scrollIntoView({behavior:\"smooth\"});\n            const oldTierName = this.rootStore.levelStore.levelProperties[this.activeCard].tierName;\n            create_unified_changeset_notice({\n                header: gettext(\"Warning\"),\n                show_icon: true,\n                /* # Translators:  This is a confirmation prompt that is triggered by clicking on a cancel button.  */\n                message_text: gettext(\"Are you sure you want to continue?\"),\n                /* # Translators:  This is a warning provided to the user when they try to cancel the editing of something they have already modified.  */\n                preamble: interpolate(gettext(\"Changes to this %s will not be saved\"), [oldTierName]),\n                notice_type: \"notice\",\n                include_rationale: false,\n                rationale_required: false,\n                on_submit: () => this.onLeaveConfirm(levelId, cancelledLevelId),\n                on_cancel: () => this.setDisableCardActions(false),\n            })\n        }\n        else {\n            this.activeCard = levelId;\n            this.rootStore.levelStore.levels.replace(this.rootStore.levelStore.levels.filter( l => l.id != \"new\"))\n        }\n    };\n\n    @action\n    onLeaveConfirm = (levelId, cancelledLevelId) => {\n        this.setDisableCardActions(false);\n        this.rootStore.levelStore.cancelEdit(cancelledLevelId);\n        this.activeCardNeedsConfirm = false;\n        this.activeCard = levelId;\n        // Need to use set timeout to ensure that scrolling loses the race with components reacting to the new position of the open card.\n        setTimeout(\n            function(){$(`#level-card-${levelId}`)[0].scrollIntoView({behavior:\"smooth\"})},\n            100\n        );\n    };\n\n    @action\n    setDisableCardActions = (value) => {\n        this.disableCardActions = value;\n    };\n\n    @action\n    removeActiveCard = () => {\n        this.activeCard = null;\n        this.rootStore.uiStore.activeCardNeedsConfirm = false;\n    };\n\n    @action\n    updateVisibleChildren = (levelId, forceHide=false) => {\n        // forceHide is to ensure that descendant levels are also hidden.\n        if (this.hasVisibleChildren.indexOf(levelId) >= 0 || forceHide) {\n            this.hasVisibleChildren = this.hasVisibleChildren.filter( level_id => level_id != levelId );\n            const childLevels = this.rootStore.levelStore.levels.filter( l => l.parent == levelId);\n            childLevels.forEach( l => this.updateVisibleChildren(l.id, true))\n        }\n        else {\n            this.hasVisibleChildren.push(levelId);\n        }\n    };\n\n    @action\n    expandAllLevels = () =>{\n        this.hasVisibleChildren = this.rootStore.levelStore.levels.map( level => level.id);\n    };\n\n    @action\n    collapseAllLevels = () => this.hasVisibleChildren = [];\n\n    @action\n    setAddLevelButtonLockedStatus = (status) => this.addLevelButtonIsLocked = status;\n\n    @action\n    validateCustomTiers = () => {\n        let hasErrors = false;\n        const customKey = this.rootStore.levelStore.customTierSetKey;\n        const tiersToTest = this.rootStore.levelStore.tierTemplates[customKey]['tiers'];\n        this.setAddLevelButtonLockedStatus(false);\n        let errors = tiersToTest.map( (tierName) => {\n            const regex = /^\\s*$/;\n            let whitespaceError = tierName.length === 0 || (regex.test(tierName) && tierName.length > 0)\n            let duplicateErrors = 0; // There will be at least 1 for the self-match.\n            let commaError = tierName.indexOf(\",\") !== -1;\n\n            tiersToTest.forEach( otherTierName => {\n                if (otherTierName == tierName){\n                    duplicateErrors += 1;\n                }\n            });\n            if (whitespaceError){\n                hasErrors = true;\n                /* # Translators: This is a warning messages when a user has entered duplicate names for two different objects and those names contain only white spaces, both of which are not permitted. */\n                return {hasError: true, msg: gettext(\"Please complete this field.\")}\n            }\n            else if (commaError){\n                hasErrors = true;\n                /* # Translators: This is a warning messages when a user has entered duplicate names for two different objects */\n                return {hasError: true, msg: gettext(\"Result levels should not contain commas.\")}\n            }\n            else if (duplicateErrors > 1){\n                hasErrors = true;\n                /* # Translators: This is a warning messages when a user has a comma in a name that shouldn't contain commas */\n                return {hasError: true, msg: gettext(\"Result levels must have unique names.\")}\n            }\n            else{\n                return {hasError: false, msg: \"\"};\n            }\n        });\n        this.customFormErrors = {hasErrors: hasErrors, errors: errors}\n    };\n\n    @action\n    clearValidationMessages = () => {\n        this.customFormErrors = {hasErrors: false, errors: []}\n    }\n}\n","/*\n * ID generating code &c. for form inputs\n */\n\nlet lastId = 0;\n\nexport function uniqueId (prefix='id') {\n    lastId++;\n    return `${prefix}${lastId}`;\n}","import React from 'react';\nimport { observer, inject } from \"mobx-react\";\nimport { toJS } from \"mobx\";\n\nimport { DeleteButton } from \"../../../components/actionButtons\";\n\n\n\nclass StaticLevelTier extends React.Component {\n\n    render() {\n        return (\n            <div className={'leveltier leveltier--level-' + this.props.tierLevel}>{this.props.tierName} </div>\n    )}\n}\n\n@inject('rootStore')\n@observer\nexport class StaticLevelTierList extends React.Component{\n\n    render() {\n        let apply_button = null;\n        // Only show the Apply button if you haven't saved a level yet and if you're a 'high' level user.\n        if (this.props.rootStore.levelStore.levels.length === 0 &&\n            this.props.rootStore.levelStore.hasEditPermissions) {\n            apply_button =\n                <div className=\"leveltier-list__actions\">\n                    <button\n                        className=\"leveltier-button btn btn-primary btn-block\"\n                        onClick={this.props.rootStore.levelStore.applyTierSet}>\n                        {/* #Translators: this refers to an imperative verb on a button (\"Apply filters\")*/}\n                        {gettext(\"Apply\")}\n                    </button>\n                </div>\n        }\n\n        let settings_button = null;\n        // Only show the settings button if you've selected to customize the tiers, you are not actively editing\n        // the tiers, and you are a high level user.\n        if (this.props.rootStore.levelStore.chosenTierSetKey == this.props.rootStore.levelStore.customTierSetKey &&\n            this.props.rootStore.levelStore.useStaticTierList &&\n            this.props.rootStore.levelStore.hasEditPermissions) {\n            settings_button =\n                <button\n                        className=\"btn btn-link leveltier-list leveltier--editable__settings\"\n                        onClick={this.props.rootStore.levelStore.editTierSet}>\n                    <i className=\"fa fa-cog\" />\n                    {gettext(\"Settings\")}\n                </button>\n\n        }\n\n        return (\n            <React.Fragment>\n                <div id=\"leveltier-list\" className=\"leveltier-list\">\n                    {\n                        this.props.rootStore.levelStore.chosenTierSet.length > 0 ?\n                            this.props.rootStore.levelStore.chosenTierSet.map((tier, index) => {\n                                return <StaticLevelTier key={index} tierLevel={index} tierName={tier}/>\n                            })\n                            : null\n                    }\n\n                </div>\n                {settings_button}\n                {apply_button}\n            </React.Fragment>\n        )\n    }\n}\n\n@inject('rootStore')\nclass EditableLevelTier extends React.Component {\n    constructor(props) {\n        super(props);\n        this.inputRef = React.createRef()\n    }\n\n    onBlur = (event) => {\n        /*\n        When the onBlur event is triggered, if the user has fixed errors in the level tiers, React/MobX will redraw the elements\n        on the page.  When that onBlur event happens to be a button click (e.g. the Apply button), the onDraw redraw prevents the button's\n        onClick from firing.  This code is required to make sure buttons don't need to be clicked twice.\n        If the user is deleting a level, that should be called before the validation is called.\n         */\n        if (event.relatedTarget && event.relatedTarget.classList.contains(\"btn-delete\")) {\n            this.props.rootStore.levelStore.deleteCustomTier(event);\n        }\n        else {\n            this.props.rootStore.uiStore.validateCustomTiers();\n            if (event.relatedTarget && event.relatedTarget.id == \"applyButton\") {\n                this.props.rootStore.levelStore.applyTierSet();\n            }\n            if (event.relatedTarget && event.relatedTarget.id == \"addLevelButton\") {\n                this.props.rootStore.levelStore.addCustomTier();\n            }\n        }\n    };\n\n    componentDidMount() {\n        this.inputRef.current.focus()\n    }\n\n    render() {\n        let deleteButton = null;\n        if (this.props.showDeleteButton){\n            deleteButton =\n                <DeleteButton\n                    buttonClasses='p-0'\n                    type=\"button\"\n                    disabled={this.props.rootStore.uiStore.customFormErrors.hasErrors}\n                    action={this.props.rootStore.levelStore.deleteCustomTier}/>\n        }\n\n        let lockButton = null;\n        if (this.props.showLockButton){\n            lockButton =\n                <a\n                    tabIndex=\"0\"\n                    className=\"btn btn-sm btn-link\"\n                    data-toggle=\"popover\"\n                    data-trigger=\"focus\"\n                    data-placement=\"bottom\"\n                    /* # Translators: This is the help text of an icon that indicates that this element can't be deleted */\n                    data-content={gettext(\"This level is being used in the results framework\")}\n                >\n                    <i className='fa fa-lock text-muted' />\n                </a>\n        }\n\n        return (\n            <React.Fragment>\n                <div className=\"form-group\">\n                    <label className=\"leveltier--editable__label\">\n                        {\n                            /* # Translators: This is one of several user modifiable fields, e.g. \"Level 1\", \"Level 2\", etc... Level 1 is the top of the hierarchy, Level six is the bottom.*/\n                             interpolate(gettext(\"Level %s\"), [this.props.tierOrder + 1])\n                        }\n                    </label>\n                    <div className=\"leveltier--editable\">\n                        <input\n                            ref={this.inputRef}\n                            className=\"leveltier--editable__input form-control\"\n                            type=\"text\"\n                            maxLength={75}\n                            data-tierorder={this.props.tierOrder}\n                            value={this.props.tierName}\n                            onChange={this.props.rootStore.levelStore.updateCustomTier}\n                            onBlur={this.onBlur} />\n                        {deleteButton}\n                        {lockButton}\n                    </div>\n                    <span className='has-error'>{this.props.errorMsg}</span>\n                </div>\n            </React.Fragment>\n    )}\n}\n\n\n@inject('rootStore')\n@observer\nexport class EditableLevelTierList extends React.Component{\n\n    componentDidMount() {\n        // Enable popovers after update (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n    // Need this just to ensure that the implicit submit that takes place for single input forms is blocked\n    customTemplateFormSubmit = (event) => event.preventDefault();\n\n    render() {\n        const customKey = this.props.rootStore.levelStore.customTierSetKey;\n\n        // Loop through each custom tier and build the input field, error message, and delete/lock icon\n        const savedTiers  = this.props.rootStore.levelStore.chosenTierSet.map((tier, index) => {\n            const errorObj = this.props.rootStore.uiStore.customFormErrors.errors.length > index ?\n                this.props.rootStore.uiStore.customFormErrors.errors[index] : null;\n            const errorMsg = errorObj && errorObj.hasError ? errorObj.msg : null;\n            const showLockButton = !this.props.rootStore.levelStore.tierIsDeletable(index+1);\n            const showDeleteButton =\n                index === this.props.rootStore.levelStore.chosenTierSet.length - 1 &&\n                !showLockButton &&\n                !(this.props.rootStore.levelStore.chosenTierSet.length === 1 && tier.length === 0);\n            return <EditableLevelTier\n                key={index}\n                tierName={tier}\n                showDeleteButton={showDeleteButton}\n                showLockButton={showLockButton}\n                tierOrder={index}\n                errorMsg={errorMsg} />\n        }) || null;\n\n        // At the bottom of the tier list, show the add level and apply buttons, if appropriate.\n        let isAddTierButtonDisabled =\n            !this.props.rootStore.levelStore.tierTemplates[customKey]['tiers'].every( tierName => tierName.length > 0) ||\n            this.props.rootStore.uiStore.addLevelButtonIsLocked;\n        const addTierButton = savedTiers.length >= this.props.rootStore.levelStore.maxTiers ? null :\n            <button\n                id=\"addLevelButton\"\n                type=\"button\"\n                className=\"btn btn-link btn-add\"\n                disabled={isAddTierButtonDisabled}\n                onClick={this.props.rootStore.levelStore.addCustomTier}>\n                <i className=\"fa fa-plus-circle\" />Add level\n            </button>;\n\n        const applyButton =\n            <div className=\"leveltier-list__actions\">\n                <button\n                    id=\"applyButton\"\n                    className=\"leveltier-button btn btn-primary btn-block\"\n                    disabled={isAddTierButtonDisabled}\n                    type=\"button\"\n                    onClick={this.props.rootStore.levelStore.applyTierSet}>\n                    {/* #Translators: this refers to an imperative verb on a button (\"Apply filters\")*/}\n                    {gettext(\"Apply\")}\n                </button>\n            </div>;\n\n        return (\n            <form onSubmit={this.customTemplateFormSubmit}>\n                <div id=\"leveltier-list\" className=\"leveltier-list\">\n                    <div className=\"\">\n                        {savedTiers}\n                    </div>\n                    {addTierButton}\n                </div>\n                {applyButton}\n\n            </form>\n        )\n    }\n}\n","import React from 'react'\nimport { observer } from 'mobx-react';\nimport classNames from 'classnames';\nimport { library } from '@fortawesome/fontawesome-svg-core'\nimport {FontAwesomeIcon} from \"@fortawesome/react-fontawesome\"\nimport { faPlusSquare, faMinusSquare } from '@fortawesome/free-solid-svg-icons'\n\nlibrary.add(faPlusSquare, faMinusSquare)\n\n\nlibrary.add(faPlusSquare, faMinusSquare);\n\nexport class DeleteButton extends React.Component {\n    render() {\n        const buttonClasses = classNames('btn-delete btn btn-sm text-danger', this.props.buttonClasses);\n        const iconClasses = classNames('fa fa-times', this.props.iconClasses);\n        return (\n            <button\n                    type={this.props.type || \"button\"}\n                    onClick={this.props.action}\n                    onKeyUp={this.props.action}\n                    className={buttonClasses}>\n                <i className={iconClasses}/>\n            </button>\n        )\n    }\n}\n\n\nexport class ExpandAllButton extends React.Component {\n    render() {\n        return <button className=\"btn btn-medium text-action btn-sm\"\n                       onClick={this.props.expandFunc}\n                       disabled={this.props.isDisabled}>\n            <FontAwesomeIcon icon=\"plus-square\" />\n            {\n                /* # Translators: button label to show the details of all items in a list */}\n            {gettext('Expand all')}\n        </button>\n    }\n}\n\n\nexport class CollapseAllButton extends React.Component {\n    render() {\n        return <button className=\"btn btn-medium text-action btn-sm\"\n                       onClick={this.props.collapseFunc}\n                       disabled={this.props.isDisabled}>\n            <FontAwesomeIcon icon=\"minus-square\" />\n            {\n                /* # Translators: button label to hide the details of all items in a list */}\n            {gettext('Collapse all')}\n        </button>\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from \"mobx-react\"\nimport eventBus from '../../eventbus';\nimport createRouter from 'router5';\nimport browserPlugin from 'router5-plugin-browser';\nimport {reloadPageIfCached} from '../../general_utilities';\nimport {LevelListPanel} from './components/level_list';\nimport {LevelTierPicker} from './components/leveltier_picker';\nimport {RootStore} from './models';\n\n/*\n * Model/Store setup\n */\nconst {program, levels, indicators, levelTiers, tierTemplates, englishTemplates, customTemplates, programObjectives, accessLevel, usingResultsFramework, maxTiers} = jsContext;\nconst rootStore = new RootStore(program, levels, indicators, levelTiers, tierTemplates, englishTemplates, customTemplates, programObjectives, accessLevel, usingResultsFramework, maxTiers);\n/*\n * React components on page\n */\n\nReactDOM.render(\n    <Provider rootStore={rootStore}>\n        <React.Fragment>\n            <LevelTierPicker />\n            <LevelListPanel />\n        </React.Fragment>\n    </Provider>,\n    document.querySelector('#level-builder-react-component'));\n\n\n\nreloadPageIfCached();\n","const SPANISH = 'es';\nconst FRENCH = 'fr';\nconst ENGLISH = 'en';\n\nfunction flattenArray(arr, depth = 1) {\n    if (depth == 5) {\n        return arr;\n    }\n    let flattened = [];\n    arr.forEach(item => {\n        if (Array.isArray(item)) {\n            flattened = flattened.concat(flattenArray(item, depth+1));\n        } else {\n            flattened.push(item);\n        }\n    });\n    return flattened;\n}\n\nfunction ensureNumericArray(value) {\n    if (!Array.isArray(value)) {\n        value = parseInt(value);\n        if (value && !isNaN(value)) {\n            return [value];\n        }\n        return false;\n    }\n    let arr = value.map(x => parseInt(x)).filter(x => !isNaN(x));\n    if (arr && Array.isArray(arr) && arr.length > 0) {\n        return arr;\n    }\n    return false;\n}\n\n/*\n * Are we loading a cached page? If so, reload to avoid displaying stale indicator data\n * See ticket #1423\n */\nfunction reloadPageIfCached() {\n    // moving the cache check to after page load as firefox calculates transfer size at the end\n    $(function () {\n        let isCached = window.performance.getEntriesByType(\"navigation\")[0].transferSize === 0;\n        //adding a second check to ensure that if for whatever reason teh transfersize reads wrong, we don't reload on\n        //a reload:\n        let isReload = window.performance.getEntriesByType(\"navigation\")[0].type === \"reload\";\n        if (isCached && !isReload) {\n            window.location.reload();\n        }\n    });\n}\n\nconst indicatorManualNumberSort = (levelFunc, numberFunc) => {\n    return (indicatorA, indicatorB) => {\n        let levelA = levelFunc(indicatorA);\n        let levelB = levelFunc(indicatorB);\n        if (levelA && !levelB) {\n            return 1;\n        }\n        if (levelB && !levelA) {\n            return -1;\n        }\n        if (levelA != levelB) {\n            return parseInt(levelA) - parseInt(levelB);\n        }\n        let numberA = (numberFunc(indicatorA) || '').split('.');\n        let numberB = (numberFunc(indicatorB) || '').split('.');\n        for (let i=0; i < Math.max(numberA.length, numberB.length); i++) {\n            if (numberA[i] && numberB[i]) {\n                for (let j=0; j < Math.max(numberA[i].length, numberB[i].length); j++) {\n                    if (numberA[i][j] && numberB[i][j]) {\n                        if (numberA[i].charCodeAt(j) != numberB[i].charCodeAt(j)) {\n                            return numberA[i].charCodeAt(j) - numberB[i].charCodeAt(j);\n                        }\n                    } else if (numberA[i][j]) {\n                        return 1;\n                    } else if (numberB[i][j]) {\n                        return -1;\n                    }\n                }\n            } else if (numberA[i]) {\n                return 1;\n            } else if (numberB[i]) {\n                return -1;\n            }\n        }\n        return 0;\n    }\n}\n\nconst localizeNumber = (val) => {\n    if (val === undefined || val === null || isNaN(parseFloat(val))) {\n        return null;\n    }\n    var intPart = val.toString();\n    var floatPart = null;\n    if (val.toString().includes(\",\")) {\n        intPart = val.toString().split(\",\")[0];\n        floatPart = val.toString().split(\",\").length > 1 ? val.toString().split(\",\")[1 ] : null;\n    } else if (val.toString().includes(\".\")) {\n        intPart = val.toString().split(\".\")[0];\n        floatPart = val.toString().split(\".\").length > 1 ? val.toString().split(\".\")[1 ] : null;\n    }\n    floatPart = (floatPart && floatPart.length > 0) ? floatPart : null;\n    var displayValue;\n    switch(window.userLang) {\n        case SPANISH:\n            displayValue = intPart.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \".\");\n            if (floatPart) {\n                displayValue += `,${floatPart}`;\n            }\n        break;\n        case FRENCH:\n            displayValue = intPart.replace(/\\B(?=(\\d{3})+(?!\\d))/g, String.fromCharCode(160)); //nbsp\n            if (floatPart) {\n                displayValue += `,${floatPart}`;\n            }\n        break;\n        case ENGLISH:\n        default:\n            displayValue = intPart.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n            if (floatPart) {\n                displayValue += `.${floatPart}`;\n            }\n        break;\n    }\n    return displayValue;\n};\n\nconst localizePercent = (val) => {\n    if (val === undefined || val === null || isNaN(parseFloat(val))) {\n        return null;\n    }\n    let percent = localizeNumber(Math.round(val * 10000)/100);\n    return (percent === null) ? null : `${percent}%`;\n}\n\nconst sortObjectListByValue = (objects, key='label') => objects.sort((a, b) => {\n    return a[key].toUpperCase() > b[key].toUpperCase() ? 1 : -1\n})\n\nexport { flattenArray, ensureNumericArray, reloadPageIfCached, indicatorManualNumberSort,\n          localizeNumber, localizePercent, sortObjectListByValue };\n","import axios from 'axios';\n\nexport const api = axios.create({\n    withCredentials: true,\n    baseURL: '/api/',\n    headers: {\n        \"X-CSRFToken\": document.cookie.replace(/(?:(?:^|.*;\\s*)csrftoken\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\")\n    }\n});\n","import React from 'react';\nimport { observer } from 'mobx-react';\n\nexport const AddIndicatorButton = observer(({ readonly, ...params }) => {\n    return (\n            <button\n                type=\"button\"\n                disabled={readonly}\n                className=\"btn btn-sm btn-link px-0 btn-add text-nowrap\"\n                onClick={e => {openCreateIndicatorFormModal(params)}}>\n                <i className=\"fas fa-plus-circle\"/> {gettext(\"Add indicator\")}\n            </button>\n    );\n});\n\n\nexport const UpdateIndicatorButton = observer(({ readonly, label=null, ...params }) => {\n    return (\n            <button\n                type=\"button\"\n                disabled={readonly}\n                className=\"btn btn-link\"\n                onClick={e => {openUpdateIndicatorFormModal(params)}}>\n                <i className=\"fas fa-cog\"/>{label}\n            </button>\n    );\n});\n\n\n\nexport const ExpandAllButton = observer(\n    ({clickHandler, disabled}) => {\n        return <button className=\"btn btn-medium text-action btn-sm\"\n                       onClick={ clickHandler }\n                       disabled={ disabled }>\n            <i className=\"fas fa-plus-square\"></i>\n            {\n                /* # Translators: button label to show the details of all rows in a list */}\n            {gettext('Expand all')}\n        </button>\n    }\n);\n\nexport const CollapseAllButton = observer(\n    ({clickHandler, disabled}) => {\n        return <button className=\"btn btn-medium text-action btn-sm\"\n                       onClick={ clickHandler }\n                       disabled={ disabled }>\n            <i className=\"fas fa-minus-square\"></i>\n            {\n                /* # Translators: button label to hide the details of all rows in a list */}\n            {gettext('Collapse all')}\n        </button>\n    }\n);\n","// A global instance of an event bus\nimport nanobus from 'nanobus';\n\nconst globalEventBus = nanobus();\n\nexport default globalEventBus;\n","import React from 'react';\nimport { observer, inject } from \"mobx-react\"\nimport { toJS } from 'mobx';\nimport { library } from '@fortawesome/fontawesome-svg-core'\nimport { faCaretDown, faCaretRight, faSitemap } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport {LevelCardCollapsed, LevelCardExpanded} from \"./level_cards\";\nimport {ExpandAllButton, CollapseAllButton} from \"../../../components/actionButtons\";\n\nlibrary.add(faCaretDown, faCaretRight, faSitemap);\n\n@inject('rootStore')\n@observer\nclass LevelList extends React.Component {\n\n    render() {\n        let renderList = [];\n        if (this.props.renderList == 'initial') {\n            renderList = this.props.rootStore.levelStore.sortedLevels\n                .filter(level => ['root', null].indexOf(level.parent) != -1)\n        }\n\n        else{\n            renderList = this.props.renderList.sort((a, b) => a.customsort - b.customsort);\n        }\n\n        return renderList.map((elem) => {\n            let card = '';\n            if (this.props.rootStore.uiStore.activeCard == elem.id) {\n                card =\n                    <LevelCardExpanded\n                        level={elem}\n                        levelProps={this.props.rootStore.levelStore.levelProperties[elem.id]}/>\n            }\n            else {\n                card =\n                    <LevelCardCollapsed\n                        level={elem}\n                        levelProps={this.props.rootStore.levelStore.levelProperties[elem.id]}/>\n            }\n\n            let children = this.props.rootStore.levelStore.sortedLevels.filter(level => level.parent == elem.id);\n            let childLevels = null;\n            if (children.length > 0){\n                childLevels =  <LevelList\n                    rootStore={this.props.rootStore}\n                    renderList={children}/>\n            }\n\n            return (\n                <div key={elem.id} className=\"leveltier--new\">\n                    {card}\n                    {childLevels}\n                </div>\n            )\n    })}\n}\n\n@inject('rootStore')\n@observer\nexport class LevelListPanel  extends React.Component {\n\n    getWarningText = () => {\n        return {__html: this.props.rootStore.uiStore.splashWarning }\n    };\n\n    render() {\n        const isCollapseAllDisabled = this.props.rootStore.uiStore.hasVisibleChildren.length === 0 ||\n            this.props.rootStore.uiStore.disableCardActions ||\n            this.props.rootStore.uiStore.activeCard;\n        let expandoDiv = null;\n        if (this.props.rootStore.levelStore.levels.filter( l => l.id !== \"new\").length > 1){\n            const excelClickHandler = () => {\n                window.open(this.props.rootStore.levelStore.excelURL, '_blank')\n            }\n            expandoDiv =\n                <div className=\"level-list--expandos\">\n                    <div className=\"btn-group\">\n                        <ExpandAllButton\n                        isDisabled={this.props.rootStore.uiStore.isExpandAllDisabled}\n                        expandFunc={this.props.rootStore.uiStore.expandAllLevels} />\n                        <CollapseAllButton\n                        isDisabled={isCollapseAllDisabled}\n                        collapseFunc={this.props.rootStore.uiStore.collapseAllLevels} />\n                    </div>\n                    <div className=\"level-list--action-buttons\">\n                        <button\n                            type=\"button\"\n                            className=\"btn btn-sm btn-secondary\"\n                            onClick={ excelClickHandler }>\n                            <i className=\"fas fa-download\"></i>\n                            {\n                                //  # Translators: a button to download a spreadsheet\n                                gettext('Excel')\n                            }\n                        </button>\n                    </div>\n                </div>;\n                \n        }\n        let panel = '';\n        if (this.props.rootStore.levelStore.levels.length == 0) {\n            panel =\n                <div className=\"level-list-panel\">\n                    <div className=\"level-list-panel__dingbat\">\n                        <FontAwesomeIcon icon='sitemap'/>\n                    </div>\n                    <div className=\"level-list-panel__text text-large\"\n                         dangerouslySetInnerHTML={this.getWarningText()}/>\n                </div>\n        } else {\n            panel =\n                <div id=\"level-list\" style={{flexGrow: \"2\"}}>\n                    {expandoDiv}\n                    <LevelList renderList='initial'/>\n                </div>\n        }\n        return panel\n    }\n}\n\n","/* Site-wide constants */\n\n\n/**\n * JS_GLOBALS is in base.html (base Tola template) - delivered by middleware from the backend\n * this function returns the global constant for a given key (i.e. 'reason_for_change_options')\n */\n\nfunction getGlobal(key) {\n    if ((typeof JS_GLOBALS !== 'undefined')  && JS_GLOBALS.hasOwnProperty(key)) {\n        return JS_GLOBALS[key];\n    }\n    return null;\n}\n\n\n/**\n * IPTT Constants:\n */\nconst BLANK_LABEL = '---------';\nconst BLANK_OPTION = {\n    value: null,\n    label: BLANK_LABEL\n};\nconst EM_DASH = \"\";\nconst BLANK_TABLE_CELL = EM_DASH;\n\n\nconst TVA = 1;\nconst TIMEPERIODS = 2;\n\nconst TIME_AWARE_FREQUENCIES = [3, 4, 5, 6, 7];\nconst IRREGULAR_FREQUENCIES = [1, 2];\n\nconst TVA_FREQUENCY_LABELS = Object.freeze(\n    {\n        1: gettext(\"Life of Program (LoP) only\"),\n        2: gettext(\"Midline and endline\"),\n        3: gettext(\"Annual\"),\n        4: gettext(\"Semi-annual\"),\n        5: gettext(\"Tri-annual\"),\n        6: gettext(\"Quarterly\"),\n        7: gettext(\"Monthly\")\n    }\n);\n\nconst TIMEPERIODS_FREQUENCY_LABELS = Object.freeze(\n    {\n        3: gettext(\"Years\"),\n        4: gettext(\"Semi-annual periods\"),\n        5: gettext(\"Tri-annual periods\"),\n        6: gettext(\"Quarters\"),\n        7: gettext(\"Months\")\n    }\n);\n\nexport { BLANK_OPTION, BLANK_LABEL, BLANK_TABLE_CELL, EM_DASH, TVA, TIMEPERIODS, TIME_AWARE_FREQUENCIES,\n         IRREGULAR_FREQUENCIES, TVA_FREQUENCY_LABELS, TIMEPERIODS_FREQUENCY_LABELS };\n\nconst GROUP_BY_CHAIN = 1;\nconst GROUP_BY_LEVEL = 2;\n\nexport { GROUP_BY_CHAIN, GROUP_BY_LEVEL };\n\nconst _gettext = (typeof gettext !== 'undefined') ?  gettext : (s) => s;\n\nfunction getPeriodLabels() {\n    return {\n        targetperiodLabels: {\n            1: _gettext(\"Life of Program (LoP) only\"),\n            3: _gettext(\"Annual\"),\n            2: _gettext(\"Midline and endline\"),\n            5: _gettext(\"Tri-annual\"),\n            4: _gettext(\"Semi-annual\"),\n            7: _gettext(\"Monthly\"),\n            6: _gettext(\"Quarterly\")\n        },\n        timeperiodLabels: {\n            3: _gettext(\"Years\"),\n            5: _gettext(\"Tri-annual periods\"),\n            4: _gettext(\"Semi-annual periods\"),\n            7: _gettext(\"Months\"),\n            6: _gettext(\"Quarters\")\n        }\n    };\n}\n\nexport {getPeriodLabels};\n\nexport const STATUS_CODES = {\n    NO_INDICATOR_IN_UPDATE: 1\n};\n\nexport const IndicatorFilterType = Object.freeze({\n    noFilter: 0,\n    missingTarget: 1,\n    missingResults: 2,\n    missingEvidence: 3,\n\n    aboveTarget: 5,\n    belowTarget: 6,\n    onTarget: 7,\n    nonReporting: 8\n});\n\nexport const RFC_OPTIONS = getGlobal('reason_for_change_options') ?? [];"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA;AACA;AACA;AAIA;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;;;;;;AACA;AACA;AACA;AACA;AADA;AAGA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AADA;AAGA;AAAA;AAAA;AAAA;AAHA;AAMA;AAGA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AArBA;AAAA;AACA;AAsBA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAFA;AAFA;AAQA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AANA;AAWA;;;;AAnEA;AACA;AAqEA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAKA;AAAA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAVA;AAUA;AACA;;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AAAA;AAAA;AAAA;AAEA;;;;AA5BA;AACA;AADA;AA+BA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AA/BA;AAiCA;AACA;AACA;AAnCA;AAAA;AACA;AADA;AAAA;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAKA;AAKA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAQA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAVA;AACA;AAWA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AA9CA;AAiDA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AANA;AAjBA;AA+BA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AASA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAGA;AACA;AAAA;AAOA;AAXA;AACA;AADA;AAAA;AACA;AAaA;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;;;;;;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAXA;AAYA;AAAA;AAIA;;;;AAzCA;AACA;AA6CA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AARA;AAUA;AACA;AAhBA;AAkBA;AACA;AACA;AApBA;AAoCA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAxCA;AAAA;AACA;AADA;AAAA;AAAA;AAsBA;AACA;AACA;AADA;AAGA;AA1BA;AAAA;AAAA;AA6BA;AACA;AACA;AADA;AAGA;AAjCA;AAAA;AAAA;AAyCA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAFA;AAIA;AAAA;AAEA;AACA;AACA;AAHA;AAQA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AAHA;AAIA;AAAA;AAKA;AACA;AACA;AAHA;AAIA;AAAA;AAIA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAXA;AAkBA;AApKA;AACA;AADA;AAAA;AA0KA;AAAA;AACA;AADA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AA+CA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AArDA;AAwDA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAjEA;AAuEA;AACA;AACA;AAzEA;AAsIA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAJA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AARA;AAUA;AAEA;AACA;AACA;AACA;AAvKA;AAyKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAhLA;AAkLA;AACA;AACA;AACA;AArLA;AAuLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAvMA;AAyMA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9MA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AA3BA;AA8BA;AACA;AACA;AAHA;AAxCA;AA6CA;AACA;AA/CA;AAAA;AAAA;AA4EA;AACA;AACA;AACA;AADA;AAGA;AAjFA;AAAA;AAAA;AAmFA;AACA;AAAA;AACA;AACA;AADA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAKA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9HA;AAAA;AAAA;AAiIA;AACA;AACA;AACA;AApIA;AAAA;AAAA;AAkNA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAMA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAQA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAHA;AAOA;AACA;AACA;AAHA;AAKA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAYA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAYA;AACA;AACA;AACA;AACA;AACA;AANA;AAYA;AA1SA;AACA;AADA;AAAA;AA+SA;;;;;;;;;;;;;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AA7BA;AACA;AA+BA;;;;;;;;;;;;;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAUA;;;;AAfA;AACA;AAkBA;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AADA;AAIA;AACA;;;AAEA;AACA;AACA;;;AAEA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AATA;AAWA;AAAA;AAGA;AACA;AACA;AAHA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAKA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAJA;AADA;AAQA;AAAA;AAEA;AACA;AACA;AAHA;AAQA;;;;AA9GA;AAiHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACltBA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AAEA;AACA;AACA;AAEA;AAAA;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;AAGA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AALA;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AALA;AAUA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAFA;AADA;AAQA;AACA;AAGA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAlBA;AAoBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAHA;AAAA;AAKA;AAAA;AAEA;AAFA;AAAA;AAPA;AACA;AAWA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AANA;AAWA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AALA;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9MA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAGA;AAeA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8EA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AA1FA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AAsMA;AACA;AADA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAjPA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AAuUA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAjVA;AAmVA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AA3WA;AA+WA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAYA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1cA;AA4cA;AAEA;AACA;AAEA;AACA;AACA;AACA;AApdA;AACA;AADA;AACA;AADA;AACA;AADA;AA+eA;AACA;AACA;AACA;AACA;AACA;AAFA;AAGA;AAAA;AACA;AACA;AAvfA;AAyfA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3gBA;AA6gBA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA1hBA;AA2hBA;AAAA;AAAA;AAAA;AACA;AA5hBA;AA6hBA;AAAA;AAAA;AAAA;AACA;AA9hBA;AAgiBA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAziBA;AA0iBA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AAjjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA9CA;AAAA;AAAA;AA2GA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtJA;AAAA;AAAA;AAseA;AAAA;AAAA;AACA;AAveA;AAAA;AAAA;AAgDA;AAAA;AAAA;AACA;AAjDA;AAAA;AAAA;AAoDA;AACA;AArDA;AAAA;AAAA;AAwDA;AACA;AAAA;AACA;AAFA;AAAA;AACA;AADA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAnBA;AACA;AAEA;AAAA;AAiBA;AApBA;AAAA;AAAA;AAAA;AAAA;AACA;AAqBA;AACA;AA/EA;AAAA;AAAA;AAkFA;AACA;AAnFA;AAAA;AAAA;AAsFA;AACA;AAGA;AACA;AACA;AA5FA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AA0JA;AACA;AA3JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AA+JA;AACA;AAAA;AAAA;AAAA;AAEA;AAlKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAsKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAtLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAyLA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AA7MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAiNA;AACA;AAAA;AACA;AAnNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAmQA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAlRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAsRA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AA1SA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AA8SA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AACA;AAUA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAnUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAuUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AACA;AAQA;AACA;AAAA;AACA;AAnVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AA2eA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAhfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAofA;AACA;AArfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAyfA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AA5fA;AAAA;AAqkBA;AASA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AApBA;AAAA;AAAA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAKA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAxCA;AAAA;AAAA;AAyCA;AAGA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAJA;AAAA;AACA;AADA;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AATA;AAAA;AAAA;AAAA;AAAA;AACA;AASA;AACA;AACA;AA1DA;AAAA;AAAA;AA6DA;AACA;AA9DA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAkEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAXA;AAaA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAzFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AA6FA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAtGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AA0GA;AACA;AA3GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AA+GA;AACA;AACA;AAjHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAoHA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AA9HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAkIA;AAAA;AAAA;AACA;AAnIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAsIA;AAAA;AAtIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAyIA;AAAA;AAzIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AA6IA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAhLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAoLA;AAAA;AAAA;AAAA;AACA;AArLA;AAAA;;;;;;;;;;;;AChlBA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AAEA;AACA;AAGA;;;;;;;;;;;;;AAEA;AACA;AACA;AAAA;AACA;;;;AALA;AACA;AASA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAFA;AAOA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AAEA;AACA;AAFA;AAGA;AAAA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AASA;AAlDA;AACA;AADA;AAAA;AAsDA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAvBA;AAFA;AAGA;AACA;;;AAsBA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAKA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAOA;AAPA;AASA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAYA;AAAA;AAGA;;;;AAnFA;AAyFA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAUA;AAAA;AACA;AAXA;AAAA;AACA;AADA;AAAA;AAAA;AAGA;AACA;AACA;AADA;AAGA;AACA;AARA;AAAA;AAAA;AAYA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAOA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AALA;AAMA;AAAA;AAGA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AALA;AAWA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AASA;AAzEA;AACA;AADA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAKA;AAAA;AAGA;AAbA;AACA;AADA;AAAA;AAiBA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAFA;AAGA;AAAA;AAKA;AAVA;AACA;AADA;AAAA;AAcA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAFA;AAGA;AAAA;AAKA;AAVA;AACA;AADA;AAAA;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAUA;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAnBA;AACA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAFA;AACA;;;;;;;;;;;;;ACzIA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAKA;AAAA;AAGA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAKA;AAAA;AAGA;AAIA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AAGA;AAAA;AAKA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AAGA;AAAA;AAKA;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;;;;;;;;;;;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAFA;AAGA;AAEA;AAEA;AACA;AAFA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAKA;AAAA;;;;AA1CA;AA+CA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAGA;AAAA;AAAA;AACA;AACA;AALA;AAAA;AACA;AADA;AAAA;AAAA;AAMA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAFA;AAIA;AACA;AAFA;AAIA;AAAA;AAEA;AACA;AACA;AAHA;AAIA;AAAA;AAGA;AAMA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AADA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AA1DA;AACA;AADA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAWA;AAEA;AACA;AACA;AACA;AACA;AALA;AASA;AAGA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AALA;AAVA;AAkBA;AACA;AACA;AAEA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AATA;AAYA;;;;A","sourceRoot":""}
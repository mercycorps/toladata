{"version":3,"file":"iptt_report-8a87ba7cd4092690ead8.js","sources":["webpack:///./js/pages/iptt_report/components/ipttReport.js","webpack:///./js/pages/iptt_report/components/report/headerCells.js","webpack:///./js/models/program.js","webpack:///./js/pages/iptt_report/models/ipttRootStore.js","webpack:///./js/components/helpPopover.js","webpack:///./js/apiv2.js","webpack:///./js/pages/iptt_report/models/ipttIndicatorReport.js","webpack:///./js/pages/iptt_report/components/report/buttons.js","webpack:///./js/pages/iptt_report/components/report/tableRows.js","webpack:///./js/components/selectWidgets.js","webpack:///./js/formUtils.js","webpack:///./js/pages/iptt_report/components/report/reportBody.js","webpack:///./js/pages/iptt_report/components/sidebar/reportFilter.js","webpack:///./js/models/indicator.js","webpack:///./js/pages/iptt_report/models/filterStore.js","webpack:///./js/models/formattingUtils.js","webpack:///./js/models/periodDateRange.js","webpack:///./js/pages/iptt_report/components/sidebar/sidebar.js","webpack:///./js/pages/iptt_report/components/report/tableHeader.js","webpack:///./js/pages/iptt_report/components/sidebar/filterForm.js","webpack:///./js/pages/iptt_report/router.js","webpack:///./js/pages/iptt_report/components/sidebar/buttons.js","webpack:///./js/pages/iptt_report/components/report/tableBody.js","webpack:///./js/pages/iptt_report/models/ipttIndicator.js","webpack:///./js/pages/iptt_report/models/ipttProgram.js","webpack:///./js/pages/iptt_report/index.js","webpack:///./js/pages/iptt_report/components/report/header.js","webpack:///./js/models/level.js","webpack:///./js/pages/iptt_report/models/reportStore.js","webpack:///./js/pages/iptt_report/models/ipttLevel.js","webpack:///./js/constants.js","webpack:///./js/pages/iptt_report/components/sidebar/reportSelect.js"],"sourcesContent":["import React from 'react';\nimport IPTTSidebar from './sidebar/sidebar';\nimport IPTTReportBody from './report/reportBody';\n\nexport default () => {\n    return (\n        <React.Fragment>\n            <IPTTSidebar />\n            <IPTTReportBody />\n        </React.Fragment>\n    );\n}","import React from 'react';\nimport { FaRegQuestionCircle } from 'react-icons/fa';\n\nconst HeaderCell = ( props ) => {\n    let style = props.styleWidth ? {\n        minWidth: `${props.styleWidth}px`\n    } : {};\n    return (\n        <th\n            scope=\"col\"\n            colSpan={ props.colSpan }\n            className={ props.className }\n            style={ style }>\n            { props.label }\n        </th>\n    )\n}\n\nclass LopHeaderWithPopover extends React.Component {\n    render() {\n        // # Translators: label on a report, column header for a column of values that have been rounded\n        const msg = gettext('All values in this report are rounded to two decimal places.');\n        return (\n            <span className=\"text-uppercase\">\n            { this.props.children }\n                <a href=\"#\"\n                    className=\"popover-icon\"\n                    tabIndex=\"0\"\n                    data-toggle=\"popover\"\n                    data-placement=\"right\"\n                    data-trigger=\"focus\"\n                    data-content={msg} >\n                    < FaRegQuestionCircle />\n                </a>\n            </span>        \n        );\n    }\n}\n\nconst PeriodHeader = ( props ) => {\n    return (\n        <td scope=\"colgroup\" colSpan={ props.isTVA ? 3 : 1}\n            className=\"iptt-period-header\">\n            <span className=\"text-uppercase\">{ props.period.name }</span>\n            { props.period.range &&\n                <React.Fragment>\n                    <br />\n                    <small>{ props.period.range }</small>\n                </React.Fragment>\n            }\n        </td>\n    )\n}\n\nconst TargetHeader = () => {\n    return (\n        <th\n            scope=\"col\"\n            className=\"iptt-period-subheader\"\n            style={{minWidth: '110px'}}>\n            {\n                /* # Translators: Column header for a target value column */\n                gettext('Target')\n            }\n        </th>\n    )\n}\n\nconst ActualHeader = () => {\n    return (\n        <th\n            scope=\"col\"\n            className=\"iptt-period-subheader\"\n            style={{minWidth: '110px'}}>\n            {\n                /* # Translators: Column header for an \"actual\" or achieved/real value column */\n                pgettext('report (long) header', 'Actual')\n            }\n        </th>\n    )\n}\n\nconst PercentMetHeader = () => {\n    return (\n        <th\n            scope=\"col\"\n            className=\"iptt-period-subheader\"\n            style={{minWidth: '110px'}}>\n            {\n                /* # Translators: Column header for a percent-met column */\n                gettext('% Met')\n            }\n        </th>\n    )\n}\n\nconst TVAHeader = () => {\n    return (\n        <React.Fragment>\n            <TargetHeader />\n            <ActualHeader />\n            <PercentMetHeader />\n        </React.Fragment>\n    )\n}\n\nexport { HeaderCell, LopHeaderWithPopover, PeriodHeader, TVAHeader, ActualHeader }\n","import { observable, action, runInAction, extendObservable } from 'mobx';\nimport api from '../apiv2';\nconst _gettext = (typeof gettext !== 'undefined') ?  gettext : (s) => s;\n\n/**\n *  Base program constructor\n *  JSON params:\n *      pk (string|number)\n *      name (string)\n *      results_framework (boolean)\n *      by_result_chain (string)\n *  @return {Object}\n */\n\nconst bareProgram = (\n    programJSON = {}\n) => ({\n    pk: parseInt(programJSON.pk),\n    name: programJSON.name,\n    resultsFramework: Boolean(programJSON.results_framework),\n    _resultChainFilterLabel: programJSON.by_result_chain || _gettext(\"by Outcome chain\"),\n    get resultChainFilterLabel() {\n        return this.resultsFramework ? this._resultChainFilterLabel : null\n    }\n});\n\nexport const getProgram = (\n    ...programConstructors\n) => ( programJSON = {} ) => [bareProgram, ...programConstructors].reduce(\n        (acc, fn) => extendObservable(acc, fn(programJSON)), {});\n\n/**\n * Extends program with reporting date start/end processing\n * JSON params:\n *      reporting_period_start_iso (string - ISO date format e.g. \"2018-01-14\")\n *      reporting_period_end_iso (string - ISO date format e.g. \"2018-12-02\")\n */\n\nexport const withReportingPeriod = (\n    programJSON = {}\n) => ({\n        reportingPeriodStart: new Date(programJSON.reporting_period_start_iso),\n        reportingPeriodEnd: new Date(programJSON.reporting_period_end_iso)\n    });\n\n/**\n *  Extends program with program-wide indicator ordering (rf-aware)\n *  JSON params:\n *      indicator_pks_level_order ([int])\n *      indicator_pks_chain_order ([int])\n */\n\nexport const withProgramLevelOrdering = (\n    programJSON = {}\n) => {\n    return {\n        _indicatorsLevelOrder: observable((programJSON.indicator_pks_level_order || [])),\n        _indicatorsChainOrder: observable((programJSON.indicator_pks_chain_order || [])),\n        _applyOrderUpdate(results) {\n            runInAction(() => {\n                this._indicatorsLevelOrder = results.indicator_pks_level_order || [];\n                this._indicatorsChainOrder = results.indicator_pks_chain_order || [];\n                Object.entries(results.indicators || {}).forEach(([pk, indicatorJSON]) => {\n                    if (!isNaN(parseInt(pk)) && this.indicators.has(parseInt(pk))) {\n                        this.indicators.get(parseInt(pk)).updateData(indicatorJSON);\n                    }\n                });\n                return results;\n            });\n        },\n        updateOrder() {\n            return api.programLevelOrdering(this.pk).then(this._applyOrderUpdate.bind(this));\n        },\n        get indicatorsInLevelOrder() {\n            return this._indicatorsLevelOrder.map(pk => this.indicators.get(pk));\n        },\n        get indicatorsInChainOrder() {\n            if (this.hasOwnProperty('resultsFramework') && this.resultsFramework === false) {\n                return this.indicatorsInLevelOrder;   \n            }\n            return this._indicatorsChainOrder.map(pk => this.indicators.get(pk));\n        }\n    };\n}\n\n\n/**\n *  Extends program with level-by-level indicator ordering (rf-aware)\n *  JSON params:\n *      level_pks_level_order ([int])\n *      level_pks_chain_order ([int])\n *      indicator_pks_for_level ([{pk: int, indicator_pks; [int]}])\n *      unassigned_indicator_pks ([int])\n */\n\nexport const withRFLevelOrdering = (\n    programJSON = {}\n) => {\n    return {\n        _levelsLevelOrder: observable((programJSON.level_pks_level_order || [])),\n        _levelsChainOrder: observable((programJSON.level_pks_chain_order || [])),\n        _unassignedIndicators: observable((programJSON.unassigned_indicator_pks || [])),\n        levelIndicators: observable(new Map(\n            (programJSON.indicator_pks_for_level || []).map(\n                levelMapJSON => [levelMapJSON.pk, levelMapJSON.indicator_pks]\n            ))),\n        updateOrder() {\n            return api.rfLevelOrdering(this.pk).then(results => {\n                runInAction(() => {\n                    this._levelsLevelOrder = results.level_pks_level_order || [];\n                    this._levelsChainOrder = results.level_pks_chain_order || [];\n                    this._unassignedIndicators = results.unassigned_indicator_pks || [];\n                    this._updateLevelIndicatorsOrder(results.indicator_pks_for_level);\n                    return true;\n                });\n            });\n        },\n        get levelsInLevelOrder() {\n            return this._levelsLevelOrder.map(pk => this.levels.get(pk)) || [];\n        },\n        get levelsInChainOrder() {\n            if (this.hasOwnProperty('resultsFramework') && this.resultsFramework === false) {\n                return this.levelsInLevelOrder;   \n            }\n            return this._levelsChainOrder.map(pk => this.levels.get(pk)) || [];\n        },\n        get unassignedIndicators() {\n            return this._unassignedIndicators.map(pk => this.indicators.get(pk)) || [];\n        },\n        get indicatorsInLevelOrder() {\n            if (!this.resultsFramework) {\n                return this.unassignedIndicators;\n            }\n            return Array.prototype.concat\n                .apply([], this.levelsInLevelOrder\n                                .map(level => this.levelIndicators.get(level.pk).filter(pk => this.indicators.has(pk))\n                                                            .map(pk => this.indicators.get(pk))))\n                .concat(this.unassignedIndicators);\n        },\n        get indicatorsInChainOrder() {\n            if (!this.resultsFramework) {\n                return this.unassignedIndicators;\n            }\n            return Array.prototype.concat\n                .apply([], this.levelsInChainOrder\n                                .map(level => this.levelIndicators.get(level.pk).filter(pk => this.indicators.has(pk))\n                                                            .map(pk => this.indicators.get(pk))))\n                .concat(this.unassignedIndicators);\n        },\n        _updateLevelIndicatorsOrder(orderByLevel=[]) {\n            runInAction(() => {\n                this.levelIndicators.clear();\n                orderByLevel.forEach(({pk, indicator_pks}) => {\n                    this.levelIndicators.set(pk, indicator_pks);\n                });\n            });\n        }\n    };\n}","import { observable, reaction } from 'mobx';\n\nimport getFilterStore from './filterStore';\nimport getReportStore from './reportStore';\n\nimport { TVA, TIMEPERIODS } from '../../../constants';\nimport api from '../../../apiv2';\n\n\nexport default (\n    reactContext = {}\n) => {\n    let rootStore = observable({\n        _filterStore: getFilterStore(reactContext),\n        get filterStore() {return this._filterStore},\n        _reportStore: getReportStore(reactContext.report || {}),\n        _expandoRows: [],\n        expandAllRows() {\n            this._expandoRows.forEach(row => {row.expandRow()});\n        },\n        get allExpanded() {\n            return this._expandoRows.every(row => row.state.expanded);\n        },\n        get allCollapsed() {\n            return this._expandoRows.every(row => !row.state.expanded)\n        },\n        collapseAllRows() {\n            this._expandoRows.forEach(row => {row.collapseRow()});\n        },\n        get reportStore() {return this._reportStore},\n        get currentReport() {\n            return this.reportStore.getReport(this.filterStore.selectedFrequency);\n        },\n        loadReportData({update = false} = {}) {\n            return this.reportStore.callForReportData({programPk: this.filterStore.selectedProgramId,\n                                                  frequency: this.filterStore.selectedFrequency,\n                                                  reportType: this.filterStore.isTVA ? TVA : TIMEPERIODS,\n                                                  update: update\n                                                  });\n        },\n        get pinParams() {\n            return {\n                program: this.filterStore.selectedProgramId,\n                report_type: this.filterStore.isTVA ? 'targetperiods' : 'timeperiods',\n                query_string: this.filterStore.queryString\n            };\n        },\n        get pinAPI() {\n            return {\n                programPageUrl: api.getProgramPageUrl(this.filterStore.selectedProgramId),\n                pinReady: true,\n                pinParams: this.pinParams,\n                savePin(params) {\n                    return api.savePinnedReport(params);\n                }\n            };\n        },\n        get excelAPI() {\n            return {\n                excelUrl: this.filterStore.excelUrl,\n                fullExcelUrl: this.filterStore.fullExcelUrl\n            };\n        },\n        get currentProgram() {\n            return this.filterStore.programFilterData;\n        },\n        get currentProgramPageUrl() {\n            return this.currentProgram ? api.getProgramPageUrl(this.currentProgram.pk) : null;\n        },\n        get isTVA() {\n            return this.filterStore.isTVA;\n        },\n        get resultsFramework() {\n            return this.filterStore.resultsFramework;\n        },\n        get levelRows() {\n            return this.filterStore.resultsFramework && this.filterStore.allLevels.length > 0 ?\n                this.filterStore.getLevelIndicatorGroups().filter(\n                    levelGroup => ((levelGroup.indicators.length > 0) ||\n                                  (!this.filterStore.filtersActive &&\n                                   (levelGroup.level !== null) &&\n                                   (levelGroup.level.tierDepth === 1)))\n                ) :\n                false;\n        },\n        get indicatorRows() {\n            return this.filterStore.getAllIndicators();\n        },\n        get reportPeriods() {\n            return (this.currentProgram && this.filterStore.selectedFrequency && this.filterStore.selectedFrequency !== 1) ?\n                    (this.filterStore.selectedFrequency == 2 ?\n                        this.currentProgram.periodRanges.get(this.filterStore.selectedFrequency).periods :\n                        this.currentProgram.periodRanges.get(this.filterStore.selectedFrequency).periods\n                            .slice(this.filterStore.startPeriodValue, this.filterStore.endPeriodValue + 1)) :\n                [];\n        },\n        getReportData(indicatorPk) {\n            return (this.currentReport && this.currentReport.has(parseInt(indicatorPk))) ?\n                    this.currentReport.get(parseInt(indicatorPk)) : {};\n        },\n        periodValues(indicatorPk) {\n            let periodValues = this.currentReport.has(parseInt(indicatorPk)) ?\n                    (this.filterStore.selectedFrequency == 2 ?\n                        this.currentReport.get(parseInt(indicatorPk)).periodValues :\n                        this.currentReport.get(parseInt(indicatorPk)).periodValues\n                            .slice(this.filterStore.startPeriodValue, this.filterStore.endPeriodValue + 1)) : [];\n            if (periodValues && !this.isTVA) {\n                periodValues = periodValues.map(periodValue => periodValue.actual);\n            }\n            return periodValues;\n        },\n        disaggregatedLop(indicatorPk, disaggregationPk) {\n            return this.currentReport.has(parseInt(indicatorPk)) ?\n                this.currentReport.get(parseInt(indicatorPk)).disaggregatedLop(parseInt(disaggregationPk)) : null;\n        },\n        disaggregatedPeriodValues(indicatorPk, disaggregationPk) {\n            let periodValues = this.currentReport.has(parseInt(indicatorPk)) ? this.currentReport.get(parseInt(indicatorPk)).disaggregatedPeriodValues(parseInt(disaggregationPk)) : null;\n            if (periodValues && this.filterStore.selectedFrequency != 2) {\n                periodValues = periodValues.slice(this.filterStore.startPeriodValue, this.filterStore.endPeriodValue + 1);\n            }\n            if (periodValues && !this.isTVA) {\n                periodValues = periodValues.map(periodValue => periodValue.actual);\n            }\n            return periodValues || [];\n        },\n        get hiddenCategories() {\n            return this.filterStore._hiddenCategories === true;\n        },\n        get baseColumns() {\n            return 8 + (this.filterStore.resultsFramework ? 0 : 1) - (this.filterStore._hiddenColumns.length);\n        },\n        get reportColumnWidth() {\n            return this.baseColumns + (!this.resultsFramework && 1) + 3 + (this.reportPeriods.length) * (this.isTVA ? 3 : 1);\n        },\n        get activeDisaggregationPks() {\n            return this.filterStore.currentDisaggregations;\n        },\n        indicatorHasActiveDisaggregations(indicator) {\n            if (!indicator.hasDisaggregations(this.activeDisaggregationPks)) {\n                return false;\n            }\n            if (this.hiddenCategories) {\n                return this.activeDisaggregationPks.map(pk => (this.getDisaggregationLabels(pk).labels || []))\n                                                           .reduce((a, b) => a.concat(b), [])\n                                                           .filter(label => this.disaggregatedLop(indicator.pk, label.pk)).length > 0;\n            }\n            return true;\n        },\n        getDisaggregationLabels(disaggregationPk) {\n            return (this.currentProgram && this.currentProgram.disaggregations.has(disaggregationPk)) ?\n                this.currentProgram.disaggregations.get(disaggregationPk) : false;\n        },\n        get hasUOMColumn() {\n            return !this.filterStore._hiddenColumns.includes(0);\n        },\n        get hasChangeColumn() {\n            return !this.filterStore._hiddenColumns.includes(1);\n        },\n        get hasCNCColumn() {\n            return !this.filterStore._hiddenColumns.includes(2);\n        },\n        get hasUOMTypeColumn() {\n            return !this.filterStore._hiddenColumns.includes(3);\n        },\n        get hasBaselineColumn() {\n            return !this.filterStore._hiddenColumns.includes(4);\n        },\n        loadResultsModal(indicatorPk) {\n            api.indicatorResultsTable(indicatorPk, false).then(\n                (data) => {\n                    $('#modalmessages').empty();\n                    let $modal = $('#indicator_modal_content');\n                    $modal.empty().html(data);\n                    $('#indicator_modal_div').modal('show');\n                    $modal.find('[data-toggle=\"popover\"]').popover({\n                        html: true, placement: 'right', container: $modal,\n                        // note: this template is just the default with the addition of a width attribute\n                        // already tried: container, boundary, placement, offset, and loading order, but this works:\n                        template: '<div class=\"popover\" style=\"width: 325px;\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-header\"></h3><div class=\"popover-body\"></div></div>'\n                    });\n                }\n            );\n        },\n        indicatorUpdate(e, {indicatorId, ...data}) {\n            return this.filterStore.updateProgramFilterData().then(\n                () => {this.loadReportData({update: true});}\n            );\n        },\n        indicatorDelete(e, {indicatorId, ...data}) {\n            this.filterStore.programFilterData.deleteIndicator(indicatorId);\n        },\n    });\n    const _updateReportData = reaction(\n        () => [rootStore.filterStore.selectedProgramId, rootStore.filterStore.selectedFrequency],\n        ([programId, frequency]) => {\n            if (programId && frequency) {\n                rootStore.loadReportData();\n            }\n        },\n        {fireImmediately: true}\n    );\n    return rootStore;\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom';\n\nexport default class HelpPopover extends React.Component {\n    constructor(props) {\n        super(props)\n        this.placement = props.placement || null;\n        this.popoverRef = props.innerRef || React.createRef();\n        this.iconClass = props.iconClass || \"far fa-question-circle\";\n        this.iconStyle = props.iconStyle || {};\n        this.linkStyle = {};\n        if (props.linkHeight) {\n            this.linkStyle.height = props.linkHeight;\n        }\n    }\n\n    render() {\n        return (\n            <a\n                tabIndex=\"0\"\n                style={ this.linkStyle }\n                data-toggle=\"popover\"\n                data-trigger=\"focus\"\n                data-html=\"true\"\n                data-placement={this.placement}\n                data-content={this.props.content}\n                className={this.props.className}\n                ref={this.popoverRef}\n                >\n            <i aria-label={ this.props.ariaText } style={ this.iconStyle } className={ this.iconClass }></i></a>\n        )\n    }\n}\n\nexport class BootstrapPopoverButton extends React.Component {\n    popoverName = 'base';\n\n    componentDidMount = () => {\n        // make a cancelable (class method) function so clicking out of the popover will close it:\n        this.bodyClickHandler = (ev) => {\n            if ($(`#${this.popoverName}_popover_content`).parent().find($(ev.target)).length == 0) {\n                $(this.refs.target).popover('hide');\n            }\n        }\n        const popoverOpenHandler = () => {\n            // first make it so any click outside of the popover will hide it:\n            $('body').on('click', this.bodyClickHandler);\n            // update position (it's had content loaded):\n            $(this.refs.target).popover('update')\n                //when it hides destroy the body clickhandler:\n                .on('hide.bs.popover', () => {$('body').off('click', this.bodyClickHandler);});\n        };\n        const shownFn = (ev) => {\n            ReactDOM.render(\n                this.getPopoverContent(),\n                document.querySelector(`#${this.popoverName}_popover_content`),\n                popoverOpenHandler\n            );\n        };\n        $(this.refs.target).popover({\n            content: `<div id=\"${this.popoverName}_popover_content\"></div>`,\n            html: true,\n            placement: 'bottom'\n        }).on('shown.bs.popover', shownFn);\n    }\n\n    getPopoverContent = () => {\n        throw new Error('not implemented');\n    }\n}\n","import axios from 'axios';\nimport qs from 'qs';\n\nconst api = {\n    apiInstance: axios.create({\n        withCredentials: true,\n        baseURL: '/indicators/api/',\n        responseType: 'json',\n        headers: {\n            \"X-CSRFToken\": document.cookie.replace(/(?:(?:^|.*;\\s*)csrftoken\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\")\n        }\n    }),\n    documentInstance: axios.create({\n        withCredentials: true,\n        baseURL: '/indicators/api/',\n        responseType: 'document',\n        headers: {\n            \"X-CSRFToken\": document.cookie.replace(/(?:(?:^|.*;\\s*)csrftoken\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\")\n        },\n        transformResponse: [response => new XMLSerializer().serializeToString(response)]\n    }),\n    formPostInstance: axios.create({\n        withCredentials: true,\n        baseURL: '/indicators/api/',\n        responseType: 'json',\n        headers: {\n            \"X-CSRFToken\": document.cookie.replace(/(?:(?:^|.*;\\s*)csrftoken\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\"),\n            'content-type': 'application/x-www-form-urlencoded'\n        },\n    }),\n    logFailure(failureMsg) {\n        console.log(\"api call failed:\", failureMsg);\n    },\n    getProgramPageUrl(programPk) {\n        return !isNaN(parseInt(programPk)) ? `/program/${programPk}/` : false;\n    },\n    programLevelOrdering(programPk) {\n        return this.apiInstance.get(`/program/ordering/${programPk}/`)\n        .then(response => response.data)\n        .catch(this.logFailure);\n    },\n    rfLevelOrdering(programPk) {\n        return this.apiInstance.get(`/program/level_ordering/${programPk}/`)\n        .then(response => response.data)\n        .catch(this.logFailure);\n    },\n    indicatorResultsTable(indicatorPk, editable) {\n        return this.documentInstance.get(`/result_table/${indicatorPk}/`, {params: {raw: true, edit: editable}})\n            .then(response => response.data)\n            .catch(this.logFailure);\n    },\n    updateProgramPageIndicator(indicatorPk) {\n        return this.apiInstance.get(`/program_page/indicator/${indicatorPk}/`)\n        .then(response => response.data)\n        .catch(this.logFailure);\n    },\n    updateAllProgramPageIndicators(programPk) {\n        return this.apiInstance.get(`/program_page/${programPk}/`)\n        .then(response => response.data)\n        .catch(this.logFailure);\n    },\n    ipttFilterData(programPk) {\n        return this.apiInstance.get(`/iptt/${programPk}/filter_data/`)\n                    .then(response => response.data)\n                    .catch(this.logFailure);\n    },\n    getIPTTReportData({programPk, frequency, reportType} = {}) {\n        return this.apiInstance.get(`/iptt/${programPk}/report_data/`,\n                                    {params: {frequency: frequency, report_type: reportType}})\n                    .then(response => response.data)\n                    .catch(this.logFailure);\n    },\n    savePinnedReport(reportData) {\n        return this.formPostInstance.post(`/pinned_report/`, qs.stringify(reportData))\n                    .catch(this.logFailure);\n    },\n    updateIPTTIndicator(indicatorPk) {\n        return this.apiInstance.get(`/iptt/indicator/${indicatorPk}/`)\n                    .then(response => response.data)\n                    .catch(this.logFailure);\n    }\n    \n};\n\n\nexport default api;","import { observable } from 'mobx';\n\n\n/*\n * Take an array [{index: #, actual: #},] and fill in all indices from 0 to max with actual: null\n * Uncompresses serialized report data for IPTT\n */\nconst impliedNullValuesMapper = (values) => {\n    // map of existing (non-null) indices to their actual value\n    let valuesMap = new Map(values.map(v => [v.index, v.actual]));\n    // iterate from 0 to largest index value provided\n    let valuesArray = [...Array(Math.max(...values.map(v => v.index)) + 1).keys()]\n    // for each either provide the value from the values Map if it exists (this value was provided) or default to null\n        .map(i => ({index: i, actual: valuesMap.has(i) ? valuesMap.get(i) : null}))\n    return valuesArray;\n}\n\nfunction getPeriodData ({target = null, actual = null, met = null, disaggregations = {}} = {}) {\n    let disaggregatedPeriodData = new Map(Object.entries(disaggregations).map(\n                    ([disaggregationPk, disaggregationJSON]) => [parseInt(disaggregationPk),\n                                                                 {actual: disaggregationJSON.actual}]));\n    return {target: target, actual: actual, met: met, disaggregations: disaggregatedPeriodData};\n}\n\nconst getIndicatorReport = (\n    frequency,\n    indicatorReportJSON = {}\n) => observable({\n    pk: parseInt(indicatorReportJSON.pk),\n    frequency: parseInt(frequency),\n    _lopPeriod: getPeriodData(indicatorReportJSON.lop_period),\n    get lopTarget() {\n        return this._lopPeriod.target;\n    },\n    get lopActual() {\n        return this._lopPeriod.actual;\n    },\n    get lopMet() {\n        return this._lopPeriod.met;\n    },\n    _reportData: observable(new Map((indicatorReportJSON.periods || [])\n                                    .map(periodJSON => [parseInt(periodJSON.count), getPeriodData(periodJSON)]\n        ))),\n    get periodValues() {\n        return Array.from(this._reportData.values());\n    },\n    _disaggregatedData: observable(new Map(Object.entries(indicatorReportJSON.disaggregated_data || {})\n                                           .map(([disaggregationPk, disaggregationJSON]) => [parseInt(disaggregationPk), disaggregationJSON]))),\n    disaggregatedLop(disaggregationPk) {\n        return (!isNaN(parseInt(disaggregationPk)) && this._lopPeriod.disaggregations.has(parseInt(disaggregationPk))) ?\n                this._lopPeriod.disaggregations.get(parseInt(disaggregationPk)).actual : null;\n    },\n    disaggregatedPeriodValues(disaggregationPk) {\n        return !isNaN(parseInt(disaggregationPk)) ? this.periodValues.map(period => period.disaggregations.get(parseInt(disaggregationPk))) : [];\n    }\n    \n});\n\n\nexport default getIndicatorReport;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { inject, observer } from 'mobx-react';\nimport { BootstrapPopoverButton } from '../../../../components/helpPopover';\n\n\n@observer\nclass PinPopover extends React.Component {\n    NOT_SENT = 0;\n    SENDING = 1;\n    SENT = 2;\n    FAILED = 3;\n    constructor(props) {\n        super(props);\n        this.state = {\n            reportName: '',\n            status: this.NOT_SENT\n        };\n    }\n    handleChange = (e) => {\n        this.setState({reportName: e.target.value});\n    }\n    isDisabled = () => {\n        return !this.props.rootStore.pinAPI.pinReady || !this.state.reportName;\n    }\n    handleClick = () => {\n        this.setState({status: this.SENDING});\n        this.props.rootStore.pinAPI.savePin({\n            name: this.state.reportName,\n            ...this.props.rootStore.pinParams\n        }).then( () => {\n            this.setState({status: this.SENT});\n            this.props.updatePosition();\n        }).catch( () => {\n            this.setState({status: this.FAILED});\n            console.log(\"ajax error:\", ev);\n        });\n    }\n    render() {\n        return (\n            <React.Fragment>\n            {(() => {\n            switch(this.state.status) {\n                case this.SENT:\n                    return (\n                        <div className=\"form-group\">\n                            <p><span>\n\n                                {/* # Translators: The user has successfully \"pinned\" a report link to a program page for quick access to the report */}\n                                {gettext('Success!  This report is now pinned to the program page')}\n\n                            </span></p>\n                            <p><a href={ this.props.rootStore.pinAPI.programPageUrl }>\n\n                                    {/* # Translators: This is not really an imperative, it's an option that is available once you have pinned a report to a certain web page */}\n                                    {gettext('Visit the program page now.')}\n\n                            </a></p>\n                        </div>\n                    );\n                case this.FAILED:\n                    return (\n                        <div className=\"form-group\">\n                            <p><span>\n                                {\n                                    gettext('Something went wrong when attempting to pin this report')\n                                }\n                            </span></p>\n                        </div>\n                    );\n                case this.NOT_SENT:\n                    return (\n                        <React.Fragment>\n                            <div className=\"form-group\">\n                                <label className=\"\">\n                                    {\n                                        /* # Translators: a field where users can name their newly created report */\n                                        gettext('Report name')\n                                    }\n                                </label>\n                                <input type=\"text\" className=\"form-control\"\n                                     value={ this.state.reportName }\n                                     onChange={ this.handleChange }\n                                     disabled={ this.state.sending }/>\n                            </div>\n                            <button type=\"button\"\n                                      onClick={ this.handleClick }\n                                      disabled={ this.isDisabled() }\n                                      className=\"btn btn-primary btn-block\">\n                                        {\n                                            gettext('Pin to program page')\n                                        }\n                            </button>\n                        </React.Fragment>\n                    );\n                case this.SENDING:\n                    return (\n                        <div className=\"btn btn-primary\" disabled>\n                            <img src='/static/img/ajax-loader.gif' />&nbsp;\n                                { gettext('Sending') }\n                        </div>\n                    );\n                }\n            })()}\n            </React.Fragment>\n        );\n    }\n}\n\n\n@inject('rootStore')\n@observer\nexport class PinButton extends BootstrapPopoverButton {\n    popoverName = 'pin';\n\n    getPopoverContent = () => {\n        return (\n            <PinPopover\n                rootStore={ this.props.rootStore }\n                updatePosition={() => {$(this.refs.target).popover('update');}}\n            />\n            );\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <button\n                    href=\"#\"\n                    className=\"btn btn-sm btn-secondary\"\n                    ref=\"target\">\n                <i className=\"fas fa-thumbtack\"></i>\n                    {\n                        /* # Translators: a button that lets a user \"pin\" (verb) a report to their home page */\n                        gettext('Pin')\n                    }\n                </button>\n            </React.Fragment>\n        );\n    }\n}\n\n\n@observer\nclass ExcelPopover extends React.Component {\n    getCurrent = () => {\n        if (this.props.excelUrl) {\n            window.open(this.props.excelUrl, '_blank');\n        }\n    }\n\n    getAll = () => {\n        if (this.props.fullExcelUrl) {\n            window.open(this.props.fullExcelUrl, '_blank');\n        }\n    }\n    render() {\n        return (\n            <div>\n                <button type=\"button\" className=\"btn btn-primary btn-block\" onClick={ this.getCurrent }>\n                    {\n                        /* # Translators: a download button for a report containing just the data currently displayed */\n                        gettext('Current view')\n                    }\n                </button>\n                <button type=\"button\" className=\"btn btn-primary btn-block\" onClick={ this.getAll }>\n                    {\n                        /* # Translators: a download button for a report containing all available data */\n                        gettext('All program data')\n                    }\n                </button>\n            </div>\n        );\n    }\n}\n\n@observer\nexport class ExcelPopoverButton extends BootstrapPopoverButton {\n    popoverName = 'excel';\n\n    getPopoverContent = () => {\n        return (\n            <ExcelPopover { ...this.props } />\n            );\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <button type=\"button\"\n                     className=\"btn btn-sm btn-secondary\"\n                     ref=\"target\">\n                     <i className=\"fas fa-download\"></i> Excel\n                     </button>\n            </React.Fragment>\n        );\n    }\n}\n\n\n@observer\nexport class ExcelButton extends React.Component {\n     handleClick = () => {\n        if (this.props.excelUrl) {\n            window.open(this.props.excelUrl, '_blank');\n        }\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <button type=\"button\"\n                     className=\"btn btn-sm btn-secondary\"\n                     onClick={this.handleClick }>\n                     <i className=\"fas fa-download\"></i> Excel\n                     </button>\n            </React.Fragment>\n        );\n    }\n}\n","import React from 'react';\nimport { inject, observer } from 'mobx-react';\nimport { library } from '@fortawesome/fontawesome-svg-core';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faCaretDown, faCaretRight } from '@fortawesome/free-solid-svg-icons';\nimport {BLANK_TABLE_CELL} from '../../../../constants';\n\nlibrary.add(faCaretDown, faCaretRight);\n\nfunction ipttRound(value, percent) {\n    if (value == gettext('N/A')) {\n        return value;\n    }\n    if (value !== '' && !isNaN(parseFloat(value))) {\n        if (!Number.isInteger(value)) {\n            value = Number.parseFloat(value).toFixed(2);\n            value = value.endsWith('00') ? parseInt(value) : value.endsWith('0') ? value.slice(0, -1) : value;\n        } else {\n            value = String(value);\n        }\n        return percent === true ? `${value}%` : value;\n    }\n    return null;\n}\n\nconst IndicatorEditModalCell = inject('rootStore')(\n    observer(({ rootStore, indicator }) => {\n        const loadModal = (e) => {\n            e.preventDefault();\n            let url = `/indicators/indicator_update/${indicator.pk}/?modal=true`;\n            $(\"#indicator_modal_content\").empty();\n            $(\"#modalmessages\").empty();\n            $(\"#indicator_modal_content\").load(url);\n            $(\"#indicator_modal_div\").modal('show')\n                .on('updated.tola.indicator.save', rootStore.indicatorUpdate.bind(rootStore))\n                .on('deleted.tola.indicator.save', rootStore.indicatorDelete.bind(rootStore))\n                .one('hidden.bs.modal', (ev) => {\n                    $(ev.target).off('.tola.save');\n                });\n        }\n        return (\n            <td className=\"indicator-edit-modal-cell \">\n                <button type=\"button\" className=\"btn btn-link p-1 float-right\"\n                        onClick={ loadModal }>\n                    <i className=\"fas fa-cog\"></i>\n                </button>\n            </td>\n        );\n    })\n);\n\n\nconst IndicatorResultModalCell = inject(\"rootStore\")(\n    observer(({ indicator, rootStore }) => {\n        const loadModal = (e) => {\n            e.preventDefault();\n            rootStore.loadResultsModal(indicator.pk);\n        }\n        return (\n            <td className=\"indicator-result-modal-cell \">\n                <button type=\"button\" className=\"btn btn-link p-1 indicator-ajax-popup indicator-data\"\n                        onClick={ loadModal }>\n                    <i className=\"fas fa-table\"></i>\n                </button>\n            </td>\n        )\n    })\n);\n\nconst IndicatorCell = ({ value, resultCell, ...props }) => {\n    const displayValue = (value || value === 0) ? value : <span className=\"empty-value\">{BLANK_TABLE_CELL}</span>;\n    if (resultCell && resultCell === true) {\n        return <td className=\"indicator-cell result-cell\" { ...props }>{ displayValue }</td>;\n    }\n    return (\n        <td className=\"indicator-cell \" { ...props }>{ displayValue }</td>\n    );\n}\n\nconst ExpandoCell = observer(({ value, expanded, clickHandler, ...props }) => {\n    const displayValue = (value || value === 0) ? value : <span className=\"empty-value\">{BLANK_TABLE_CELL}</span>;\n    return (\n        <td className=\"expando-cell \" { ...props } onClick={ clickHandler }>\n            <FontAwesomeIcon icon={expanded ? 'caret-down' : 'caret-right'} />&nbsp;\n            { displayValue }\n        </td>\n    );\n})\n\nconst IndicatorNameExpandoCell = observer(({ value, expanded, clickHandler, ...props }) => {\n    const displayValue = (value || value === 0) ? value : BLANK_TABLE_CELL;\n    return (\n        <td className=\"indicator-cell expando-cell \" { ...props } onClick={ clickHandler }>\n            { displayValue }\n        </td>\n    );\n})\n\n\nconst localizeFunc = window.localizeNumber;\n\n\nconst PercentCell = ({ value, ...props }) => {\n    value = (value !== undefined && value !== null) ? `${localizeFunc(value)}%` : null;\n    return <IndicatorCell className=\"indicator-cell percent-cell\" value={ value } { ...props } />;\n}\n\nconst NumberCell = ({ value, ...props }) => {\n    value = (value !== undefined && value !== null) ? localizeFunc(value) : null;\n    return <IndicatorCell className=\"indicator-cell number-cell\" value={ value } { ...props } />;\n}\n\nconst TVAResultsGroup = ({ value, resultCell, ...props }) => {\n    return (\n        <React.Fragment>\n            <NumberCell value={ value.target } />\n            <NumberCell value={ value.actual } />\n            <PercentCell value={ value.met }/>\n        </React.Fragment>\n    );\n}\n\nconst TVAResultsGroupPercent = ({ value, resultCell, ...props }) => {\n    return (\n        <React.Fragment>\n            <PercentCell value={ value.target } />\n            <PercentCell value={ value.actual } />\n            <PercentCell value={ value.met }/>\n        </React.Fragment>\n    );\n}\n\nconst DisaggregationTable = inject('rootStore')(\n    observer(({indicator, disaggregationPk, rootStore}) => {\n        let disaggregation = rootStore.getDisaggregationLabels(disaggregationPk);\n        if (!disaggregation) {\n            return null;\n        }\n        var ValueCell = NumberCell;\n        if (indicator.isPercent) {\n            ValueCell = PercentCell;\n        }\n        let labels = rootStore.hiddenCategories ? disaggregation.labels.filter(label => rootStore.disaggregatedLop(indicator.pk, label.pk)) : disaggregation.labels;\n        if (!labels) {\n            return <React.Fragment></React.Fragment>;\n        }\n        return (\n            <React.Fragment>\n                {\n                    labels.map(\n                        (label, idx) => (\n                            <tr\n                                className={ (idx == labels.length - 1) ?\n                                    \"disaggregation-end-row\" :\n                                    \"\"\n                                }\n                                key={idx}>\n                                {idx == 0 &&\n                                <td className=\"disaggregation-name-cell\"\n                                    colSpan={ 2 }\n                                    rowSpan={labels.length}>\n                                    {disaggregation.name}</td>\n                                }\n                                <td colSpan={ rootStore.hasBaselineColumn ? rootStore.baseColumns - 2 : rootStore.baseColumns - 1 } className=\"disaggregation-label-cell\">{ label.name }</td>\n                                { rootStore.hasBaselineColumn &&\n                                    <td className=\"disaggregation-value-cell base-column empty-value\">—</td>\n                                }\n                                <td className=\"disaggregation-value-cell lop-column empty-value\">—</td>\n                                <ValueCell className=\"disaggregation-value-cell lop-column\" value={ ipttRound(rootStore.disaggregatedLop(indicator.pk, label.pk), false) } />\n                                <td className=\"disaggregation-value-cell lop-column empty-value\">—</td>\n                                {\n                                    rootStore.disaggregatedPeriodValues(indicator.pk, label.pk).map(\n                                        (periodValue, idx) => {\n                                            return rootStore.isTVA ?\n                                                <React.Fragment key={idx}>\n                                                    <td className=\"disaggregation-value-cell empty-value\">—</td>\n                                                    <ValueCell key={idx} value={ periodValue.actual } />\n                                                    <td className=\"disaggregation-value-cell empty-value\">—</td>\n                                                </React.Fragment> :\n                                                <ValueCell key={idx} value={ periodValue } />\n                                        })\n                                }\n                            </tr>\n                        )\n                    )\n                }\n            </React.Fragment>\n        );\n    }\n))\n\n\n@inject('rootStore')\n@observer\nclass IndicatorRow extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            expanded: false\n        };\n    }\n\n    componentDidMount() {\n        this.props.rootStore._expandoRows.push(this);\n    }\n\n    componentWillUnmount() {\n        this.props.rootStore._expandoRows = this.props.rootStore._expandoRows.filter(row => row != this);\n    }\n\n    handleExpandoClick = (e) => {\n        this.setState({expanded: !this.state.expanded});\n    }\n\n    expandRow = () => {\n        this.setState({expanded: true});\n    }\n\n    collapseRow = () => {\n        this.setState({expanded: false});\n    }\n\n    render() {\n        let indicator = this.props.indicator;\n        let rootStore = this.props.rootStore;\n        var ValueCell;\n        var PeriodCell;\n        if (indicator.isPercent) {\n            ValueCell = PercentCell;\n            PeriodCell = rootStore.isTVA ? TVAResultsGroupPercent : PercentCell;\n        } else {\n            ValueCell = NumberCell;\n            PeriodCell = rootStore.isTVA ? TVAResultsGroup : NumberCell;\n        }\n        let cumulative = indicator.isCumulative === null ? null\n                : indicator.isCumulative ? gettext('Cumulative')\n                            : gettext('Non-cumulative');\n        let displayNumber = indicator.number;\n        if (displayNumber && displayNumber.length > 0 && displayNumber.slice(-1) == \":\") {\n            displayNumber = displayNumber.slice(0, -1);\n        }\n        let reportData = rootStore.getReportData(indicator.pk);\n        return (\n            <React.Fragment>\n                <tr>\n                    {rootStore.indicatorHasActiveDisaggregations(indicator) ?\n                    <ExpandoCell value={ displayNumber } expanded={ this.state.expanded } clickHandler={ this.handleExpandoClick } /> :\n                    <IndicatorCell className=\"indicator-cell \" value={ displayNumber } />\n                    }\n                    <IndicatorResultModalCell indicator={ indicator } />\n                    {rootStore.indicatorHasActiveDisaggregations(indicator) ?\n                    <IndicatorNameExpandoCell value={ indicator.name } expanded={ this.state.expanded } clickHandler={ this.handleExpandoClick } /> :\n                    <IndicatorCell className=\"indicator-cell \" value={ indicator.name } />\n                    }\n                    <IndicatorEditModalCell indicator={ indicator } />\n                    { !rootStore.resultsFramework && <IndicatorCell className=\"indicator-cell \" value={ indicator.oldLevelDisplay } /> }\n                    { rootStore.hasUOMColumn && <IndicatorCell className=\"indicator-cell \" value={ indicator.unitOfMeasure } /> }\n                    { rootStore.hasChangeColumn && <IndicatorCell className=\"indicator-cell \" value={ indicator.directionOfChange || gettext('N/A') } /> }\n                    { rootStore.hasCNCColumn && <IndicatorCell className=\"indicator-cell \" value={ cumulative || gettext('N/A') } /> }\n                    { rootStore.hasUOMTypeColumn && <IndicatorCell className=\"indicator-cell is-percent-column \" value={ indicator.isPercent ? '%' : '#' } /> }\n                    { rootStore.hasBaselineColumn && (indicator.baseline === null ? <IndicatorCell className=\"indicator-cell baseline-column\" value={ gettext('N/A') } /> : <ValueCell value={ indicator.baseline } className=\"lop-column\" /> ) }\n                    { reportData && (\n                    <React.Fragment>\n                    <ValueCell value={ reportData.lopTarget } className=\"lop-column \" />\n                    <ValueCell value={ reportData.lopActual } className=\"lop-column\" />\n                    <PercentCell value={ reportData.lopMet } className=\"lop-column\" />\n                    {reportData.periodValues &&\n                        (rootStore.periodValues(indicator.pk).map(\n                            (value, index) => <PeriodCell value={ value } key={ index } resultCell={ true }/>\n                        ))\n                    }\n                    </React.Fragment>\n                    )}\n                </tr>\n                { this.state.expanded &&\n                    <React.Fragment>\n                    { rootStore.activeDisaggregationPks.filter(pk => indicator.hasDisaggregation(pk))\n                        .map(pk => (\n                            <React.Fragment key={ pk }>\n                                <DisaggregationTable indicator={ indicator } disaggregationPk={ pk } />\n                            </React.Fragment>\n                        ))\n                    }\n                    </React.Fragment>\n                }\n            </React.Fragment>\n        );\n    }\n}\n\nconst LevelTitleRow = inject('rootStore')(\n    observer(({ rootStore, children }) => {\n        return (\n            <tr>\n                <td colSpan={ rootStore.reportColumnWidth + 1 }\n                    className=\"iptt-level-row\">\n                   { children }\n                </td>\n            </tr>\n        )\n    })\n);\n\nconst LevelRow = ({ level }) => {\n    return (\n        <LevelTitleRow>\n             { level.tierNumber }: { level.name }\n        </LevelTitleRow>\n    )\n}\n\nconst BlankLevelRow = () => {\n    return (\n        <LevelTitleRow>\n        {\n            gettext('Indicators unassigned to a results framework level')\n        }\n        </LevelTitleRow>\n    )\n}\n\nconst LevelGroup = ({ level, indicators }) => {\n    return (\n        <React.Fragment>\n            {\n                level ? <LevelRow level={ level } />\n                      : (indicators && indicators.length > 0) && <BlankLevelRow />\n            }\n            {\n                indicators.map(\n                    (indicator, index) => (\n                        <IndicatorRow indicator={ indicator }\n                                      levelCol={ false }\n                                      key={ index } />\n                                      )\n                )\n            }\n        </React.Fragment>\n    );\n}\n\n\nexport { LevelGroup, IndicatorRow };\n","import React from 'react';\nimport Select from 'react-select';\nimport ReactMultiSelectCheckboxes from 'react-multiselect-checkboxes';\nimport { uniqueId } from '../formUtils';\nimport { GROUP_BY_CHAIN, GROUP_BY_LEVEL } from '../constants';\n\n\n\nexport const SingleReactSelect = ( props ) => {\n    let selectId = uniqueId('react-select');\n    let labelClasses = props.labelClasses || \"col-form-label text-uppercase\";\n    let formRowClasses = props.formRowClasses || \"form-row mb-3\";\n    let selectClasses = props.selectClasses || \"tola-react-select\";\n    return (\n        <div className={ formRowClasses }>\n            <label\n                htmlFor={ selectId }\n                className={ labelClasses }>\n                    { props.label }\n            </label>\n            <Select\n                onChange={ props.update }\n                value={ props.value }\n                id={ selectId }\n                className={ selectClasses }\n                isDisabled={ props.disabled }\n                options={ props.options }\n            />\n        </div>\n    );\n}\n\nexport const DateSelect = ( props ) => {\n    let selectId = uniqueId('date-select');\n    let formattedOptions =\n        (props.options && props.options.length == 1 && props.options[0].value !== undefined) ?\n            <option value={ props.options[0].value }>{ props.options[0].label }</option> :\n            (props.options && props.options.length > 0 && props.options[0].options && props.options[0].options !== undefined) ?\n                props.options.map(\n                    (optgroup, index) => {\n                        return <optgroup label={ optgroup.label } key={ index }>\n                                    {optgroup.options.map(\n                                        option => (<option value={ option.value } key={ option.value }>\n                                                        { option.label }\n                                                   </option>)\n                                        )\n                                    }\n                                </optgroup>\n                        }) :\n                props.options.map(\n                    (option, index) => {\n                        return <option value={ option.value } key={ index }>{ option.label }</option>;\n                    }\n                );\n\n    return (\n        <div className=\"form-row mb-3\">\n            <label\n                htmlFor={ selectId }\n                className=\"col-form-label text-uppercase\">\n                    { props.label }\n            </label>\n            <select\n                className=\"form-control\"\n                id={ selectId }\n                value={ props.value }\n                onChange = { props.update }\n                disabled = { props.disabled }>\n                { formattedOptions }\n            </select>\n        </div>\n    );\n}\n\nexport const SingleSelect = ( props ) => {\n    let selectId = uniqueId('react-select');\n    let formGroupClass = props.formGroupClass || \"form-row mb-3\";\n    let labelClass = props.labelClass || \"col-form-label text-uppercase\";\n    let selectClass = props.selectClass || \"form-control\";\n    return (\n        <div className={ formGroupClass }>\n            <label\n                htmlFor={ selectId }\n                className={ labelClass }>\n                    { props.label }\n            </label>\n            <select\n                onChange={ props.update }\n                value={ props.value }\n                id={ selectId }\n                className={ selectClass }\n                disabled={ props.disabled }>\n                { props.options }\n            </select>\n        </div>\n    );\n}\n\n\n/**\n * styling element to replace OptGroup headings in react multiselect checkbox widgets - used for\n * MultiSelectCheckbox when optgroups are required\n */\nconst GroupHeading = (props) => {\n    if (props.children == '') {\n        return <div></div>;\n    } else {\n        return (\n            <React.Fragment>\n                <hr style={{ margin: '3px 0px 0px 0px' }} />\n                <div className=\"text-muted\"\n                     style={{ textTransform: 'uppercase',\n                              paddingLeft: '4px',\n                              marginBottom: '2px'}}>\n                    { props.children }\n                </div>\n            </React.Fragment>\n            );\n    }\n}\n\n\n/**\n * Styles ReactMultiSelectCheckbox to fit Tola styles\n */\nexport const MultiSelectCheckbox = ( props ) => {\n    const selectId = uniqueId('multiselect');\n    const blankOptions = (!props.options ||\n                          props.options.length == 0 ||\n                         (props.options.length == 1 && props.options[0].value === null));\n    const multiSelectProps = blankOptions ?\n            {\n                getDropdownButtonLabel: () => gettext('None available'),\n                isDisabled: true,\n                menuIsOpen: false,\n                options: [],\n            } :\n            {\n                isMulti: true,\n                options: props.options,\n                getDropdownButtonLabel: (_ref) => {\n                    if (!_ref.value) {\n                        return gettext('None selected');\n                    }\n                    if (Array.isArray(_ref.value)) {\n                        let options = _ref.value.filter(option => !option.noList);\n                        if (options.length == 0) {\n                            return gettext('None selected');\n                        }\n                        if (options.length == 1) {\n                            return options[0].label;\n                        }\n                        return `${options.length}  ${gettext('selected')}`;\n                    }\n                    return _ref.value.label;\n                }\n            };\n    const baseStyles = {\n        dropdownButton: base => blankOptions ? { ...base, backgroundColor: '#E5E6E8', background: '' } : base,\n        option: (provided, state) => ({\n                ...provided,\n                padding: '1px 12px',\n                display: 'inline-block'\n            }),\n        container: (provided, state) => ({\n                ...provided,\n                backgroundColor: '#f5f5f5'\n            }),\n    };\n    const formatOptionLabel = (props) => {\n        return <div style={{ display: \"inline-block\" , float: \"right\", width: \"90%\"}}>{props.label}</div>;\n    };\n    return (\n        <div className=\"form-row mb-2 tola-react-multiselect-row\">\n            <label htmlFor={ selectId } className=\"col-form-label text-uppercase\">\n                { props.label }\n            </label>\n            <ReactMultiSelectCheckboxes\n                id={ selectId }\n                styles={ baseStyles }\n                formatOptionLabel = { formatOptionLabel }\n                components={{ GroupHeading }}\n                value={ props.value }\n                onChange={ props.update }\n                { ...multiSelectProps }\n            />\n        </div>\n    );\n}\n\nexport const GroupBySelect = ({ chainLabel, ...selectProps }) => {\n    let options = [\n        <option value={ GROUP_BY_CHAIN } key={1}>{ chainLabel }</option>,\n        <option value={ GROUP_BY_LEVEL } key={2}>{\n            /* # Translators: refers to grouping the report by the level of the indicator */\n            gettext('by Level')\n        }</option>\n    ];;\n    return <SingleSelect\n                label={\n                    /* # Translators: menu for selecting how rows are grouped in a report */\n                    gettext('Group indicators')\n                }\n                options={ options }\n                { ...selectProps }\n            />;\n}\n","/*\n * ID generating code &c. for form inputs\n */\n\nlet lastId = 0;\n\nexport function uniqueId (prefix='id') {\n    lastId++;\n    return `${prefix}${lastId}`;\n}","import React from 'react';\nimport IPTTHeader from './header';\nimport ReportTableHeader from './tableHeader';\nimport ReportTableBody from './tableBody';\n\n\nexport default () => {\n    return <main className=\"iptt_table_wrapper\">\n                <div id=\"id_div_top_iptt_report\">\n                    <IPTTHeader />\n                    <table className=\"table table-sm table-hover table__iptt\" id=\"iptt_table\">\n                        <ReportTableHeader />\n                        <ReportTableBody />\n                    </table>\n                </div>\n            </main>;\n\n}\n","import React from 'react';\nimport { observer, inject } from 'mobx-react';\nimport { MultiSelectCheckbox } from '../../../../components/selectWidgets';\n\n\n\n/**\n * input-ready multi-select checkbox widget for filtering IPTT report by level\n * contains both \"grouping\" and \"chaining\" filtering options, displayed as two optgroups\n * labeling for second optgroup is based on Program's definition of tier 2 (stored in rootStore.selectedProgram)\n */\nconst LevelSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        const updateSelected = (selected) => {\n            filterStore.levelTierFilters = {\n                levels: selected.filter(s => s.category === \"level\").map(s => s.value),\n                tiers: selected.filter(s => s.category === \"tier\").map(s => s.value),\n                oldLevels: selected.filter(s => s.category === \"oldLevel\").map(s => s.value),\n            };\n        };\n        return <MultiSelectCheckbox\n                    label={ gettext('Levels') }\n                    options={ filterStore.levelTierOptions }\n                    value={ filterStore.levelTierFilters }\n                    update={ selected => {filterStore.levelTierFilters = {\n                                levels: selected.filter(s => s.category === \"level\").map(s => s.value),\n                                tiers: selected.filter(s => s.category === \"tier\").map(s => s.value),\n                                oldLevels: selected.filter(s => s.category === \"oldLevel\").map(s => s.value),\n                             };} }\n                />;\n    })\n);\n\n/**\n * input-ready multi-select checkbox widget for filtering IPTT report by disaggregations\n */\nconst DisaggregationSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <MultiSelectCheckbox\n                    label={\n                        /* # Translators: labels categories that  data could be disaggregated into */\n                        gettext('Disaggregations')\n                    }\n                    options={ filterStore.disaggregationOptions }\n                    value={ filterStore.disaggregationFilters }\n                    update={ selected => {filterStore.disaggregationFilters = selected.map(s => s.value);} }\n                />;\n    })\n);\n\nconst HiddenColumnSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <MultiSelectCheckbox\n                    label={\n                        /* # Translators: labels columns that could be hidden in the report */\n                        gettext('Hide columns')\n                    }\n                    options={ filterStore.hideColumnOptions }\n                    value={ filterStore.hiddenColumns }\n                    update={ selected => {filterStore.hiddenColumns = selected.map(s => s.value);} }\n                />;\n    })\n);\n\n/**\n * multi-select checkbox for selecting sites for filtering IPTT */\nconst SiteSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <MultiSelectCheckbox\n                    label={\n                        /* # Translators: labels sites that a data could be collected at */\n                        gettext('Sites')\n                    }\n                    options={ filterStore.siteOptions }\n                    value={ filterStore.siteFilters }\n                    update={ selected => {filterStore.siteFilters = selected.map(s => s.value);} }\n                />;\n    })\n);\n\n\n/**\n * multi-select checkbox for selecting types for filtering IPTT */\nconst TypeSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <MultiSelectCheckbox\n                    label={\n                        /* # Translators: labels types of indicators to filter by */\n                        gettext('Types')\n                    }\n                    options={ filterStore.indicatorTypeOptions }\n                    value={ filterStore.indicatorTypeFilters }\n                    update={ selected => {filterStore.indicatorTypeFilters = selected.map(s => s.value);} }\n                />;\n    })\n);\n\n\n/**\n * multi-select checkbox for selecting sectors for filtering IPTT */\nconst SectorSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <MultiSelectCheckbox\n                    label={\n                        /* # Translators: labels sectors (i.e. 'Food Security') that an indicator can be categorized as */\n                        gettext('Sectors')\n                    }\n                    options={ filterStore.sectorOptions }\n                    value={ filterStore.sectorFilters }\n                    update={ selected => {filterStore.sectorFilters = selected.map(s => s.value);} }\n                />;\n    })\n);\n\n\n/**\n * multi-select checkbox for selecting indicators for filtering IPTT */\nconst IndicatorSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <MultiSelectCheckbox\n                    label={\n                        /* # Translators: labels a filter to select which indicators to display */\n                        gettext('Indicators')\n                    }\n                    options={ filterStore.indicatorOptions }\n                    value={ filterStore.indicatorFilters }\n                    update={ selected => {filterStore.indicatorFilters = selected.map(s => s.value);} }\n                />;\n    })\n);\nexport { LevelSelect, DisaggregationSelect, SiteSelect, TypeSelect, SectorSelect, IndicatorSelect, HiddenColumnSelect };","import { observable, computed, extendObservable } from \"mobx\";\nimport { formatDecimal } from './formattingUtils';\nimport { TIME_AWARE_FREQUENCIES } from '../constants';\n\nconst _gettext = (typeof gettext !== 'undefined') ?  gettext : (s) => s;\n\n/**\n *  Base indicator constructor\n *  JSON params:\n *      pk (string|number)\n *      name (string)\n *      level_pk (number)\n *      old_level_name (string)\n *      means_of_verification (string)\n *  @return {Object}\n */\n\nconst bareIndicator = (\n    indicatorJSON = {}\n) => ({\n    pk: parseInt(indicatorJSON.pk),\n    name: indicatorJSON.name,\n    levelPk: !isNaN(parseInt(indicatorJSON.level_pk)) ? parseInt(indicatorJSON.level_pk) : false,\n    oldLevelDisplay: indicatorJSON.old_level_name || false,\n    meansOfVerification: indicatorJSON.means_of_verification || false\n});\n\nexport const getIndicator = (\n    ...indicatorConstructors\n) => (indicatorJSON) => {\n    return [bareIndicator, ...indicatorConstructors].reduce(\n            (acc, fn) => extendObservable(acc, fn(indicatorJSON)), {});\n}\n\n/**\n *  indicator constructor where unit and measurement figures are recorded\n *  JSON params:\n *      unit_of_measure (string)\n *      is_percent (boolean)\n *      is_cumulative (boolean)\n *      direction_of_change (string)\n *      baseline (number)\n *      lop_target (number)\n *  @return {Object}\n */\n\nexport const withMeasurement = (\n    indicatorJSON = {}\n) => ({\n        _formatDecimal: formatDecimal,\n        frequency: parseInt(indicatorJSON.target_frequency),\n        get timeAware() { return TIME_AWARE_FREQUENCIES.includes(this.frequency);},\n        unitOfMeasure: indicatorJSON.unit_of_measure || false,\n        isPercent: Boolean(indicatorJSON.is_percent),\n        isCumulative: Boolean(indicatorJSON.is_cumulative),\n        directionOfChange: indicatorJSON.direction_of_change || false,\n        baseline: indicatorJSON.baseline || null,\n        _lopTarget: indicatorJSON.lop_target || null,\n        _lopActual: indicatorJSON.lop_actual || null,\n        _lopMet: indicatorJSON.lop_met || null,\n        _lopTargetProgress: indicatorJSON.lop_target_progress || null,\n        _lopActualProgress: indicatorJSON.lop_actual_progress || null,\n        _lopMetProgress: indicatorJSON.lop_met_progress || null,\n        get lopTarget() {\n            return this._formatDecimal(this._lopTarget);\n        },\n        get lopActual() {\n            return this._formatDecimal(this._lopActual);\n        },\n        get lopMet() {\n            return this._formatDecimal(this._lopMet);\n        },\n        get lopTargetProgress() {\n            return this._formatDecimal(this._lopTargetProgress);\n        },\n        get lopActualProgress() {\n            return this._formatDecimal(this._lopActualProgress);\n        },\n        get lopMetProgress() {\n            return this._formatDecimal(this._lopMetProgress);\n        },\n    });","import { observable, runInAction, reaction } from 'mobx';\nimport IPTTProgram from './ipttProgram';\nimport IPTTRouter from '../router';\nimport api from '../../../apiv2';\n\nimport { TVA, TIMEPERIODS, BLANK_OPTION, TIME_AWARE_FREQUENCIES, IRREGULAR_FREQUENCIES,\n    TVA_FREQUENCY_LABELS, TIMEPERIODS_FREQUENCY_LABELS, GROUP_BY_LEVEL, GROUP_BY_CHAIN } from '../../../constants';\n\n\nconst getProgramsList = (\n    programsList = []\n) => observable.object({\n    _allPrograms: new Map((programsList).filter(([pk, name, tvaCount]) => !isNaN(parseInt(pk)))\n                          .map(([pk, name, tvaCount]) => [parseInt(pk), {pk: parseInt(pk), name: name, tvaCount: parseInt(tvaCount)}])),\n    listPrograms() {\n        return Array.from(this._allPrograms.values())\n    },\n    listTvaPrograms() {\n        return this.listPrograms().filter(program => program.tvaCount > 0);\n    },\n    getProgram(programId) {\n        return !isNaN(parseInt(programId)) ? this._allPrograms.get(parseInt(programId)) : null;\n    },\n    hasProgram(programId) {\n        return !isNaN(parseInt(programId)) ? this._allPrograms.has(parseInt(programId)) : false;\n    }\n});\n\n\nconst getProgramsFilterData = (\n    programData = {}\n) => {\n    let program = IPTTProgram(programData);\n    return observable.object({\n        _programs: new Map([[program.pk, program]]),\n        getProgramFilterData(programId) {\n            return this._programs.has(parseInt(programId)) ? this._programs.get(parseInt(programId)) : null;\n        },\n        loadProgramFilterData(programId) {\n            if (!isNaN(parseInt(programId))) {\n                return api.ipttFilterData(programId).then(data => IPTTProgram(data))\n                    .then(program => {\n                        runInAction(() => {\n                            this._programs.set(program.pk, program);\n                            return program;\n                        });\n                    });\n            }\n            return Promise.reject('invalid program Id');\n        }\n    });\n}\n\n\nexport default (\n    reactContext = {}\n) => {\n    const router = IPTTRouter();\n    const filterStore = observable.object({\n        _programsListStore: getProgramsList(reactContext.programs_list || []),\n        _programFilterDataStore: getProgramsFilterData(reactContext.program_data),\n        _router: router,\n        _reportType: null,\n        _selectedProgramId: null,\n        _selectedFrequency: null,\n        _start: null,\n        _end: null,\n        _mostRecentForce: null,\n        _groupBy: GROUP_BY_CHAIN,\n        _indicatorFilters: {},\n        _hiddenColumns: [],\n        _hiddenCategories: false,\n        get isTVA() {\n            return this._reportType === TVA;\n        },\n        get selectedProgramId() {\n            return this._programsListStore.hasProgram(this._selectedProgramId) ? this._selectedProgramId : null;\n        },\n        /**\n         * Method instead of setter because there are side effects (updating frequency/timeframe)\n         */\n        setProgramId(programId) {\n            programId = parseInt(programId);\n            if (isNaN(programId)) {\n                this._selectedProgramId = null;\n            }\n            else if (programId !== this._selectedProgramId) {\n                this.clearFilters();\n                const frequency = this.selectedFrequency;\n                const periods = {\n                    mostRecent: this.mostRecentValue != '' ? this.mostRecentValue : null,\n                    showAll: this.showAll,\n                    start: this.startPeriodValue,\n                    end: this.endPeriodValue\n                };\n                this._selectedProgramId = programId;\n                return this.updateProgramFilterData().then(\n                    () => {\n                        this.setFrequency(frequency);\n                        this.setPeriods(periods);\n                    }\n                );\n            }\n        },\n        /**\n         * Options throughout returns a [{value, label}] array to supply select options\n         */\n        get programOptions() {\n            return (this.isTVA ? this._programsListStore.listTvaPrograms() :\n                                this._programsListStore.listPrograms())\n                        .map(program => ({value: program.pk, label: program.name}));\n        },\n        get selectedProgramOption() {\n            let program = this._programsListStore.getProgram(this.selectedProgramId);\n            return (program && program !== null) ? {value: program.pk, label: program.name} : BLANK_OPTION;\n        },\n        set selectedProgramOption(option) {\n            this.setProgramId(option.value);\n        },\n        get programFilterData() {\n            return this._programFilterDataStore.getProgramFilterData(this.selectedProgramId);\n        },\n        updateProgramFilterData() {\n            return this._programFilterDataStore.loadProgramFilterData(this.selectedProgramId);\n        },\n        get _frequencyLabels() {\n            return this.isTVA ? TVA_FREQUENCY_LABELS : TIMEPERIODS_FREQUENCY_LABELS;\n        },\n        get frequencyDisabled() {\n            return this.selectedProgramId === null;\n        },\n        get frequencyOptions() {\n            if (this.programFilterData) {\n                return (this.isTVA ?\n                        Array.from(this.programFilterData.frequencies).sort() : TIME_AWARE_FREQUENCIES\n                    ).map(frequency => ({value: frequency, label: this._frequencyLabels[frequency]}));\n            } return [BLANK_OPTION];\n        },\n        get selectedFrequency() {\n            return (this.selectedProgramId && !isNaN(parseInt(this._selectedFrequency))) ? parseInt(this._selectedFrequency) : null;\n        },\n        /**\n         * method instead of setter because of side effects (updating timeframe)\n         */\n        setFrequency(frequency) {\n            frequency = parseInt(frequency);\n            if (isNaN(frequency)) {\n                this._selectedFrequency = null;\n                return false;\n            }\n            if (this.isTVA && !this.programFilterData.frequencies.has(frequency)) {\n                frequency = parseInt(Array.from(this.programFilterData.frequencies).sort()[0]);\n            } else if (!this.isTVA && !TIME_AWARE_FREQUENCIES.includes(frequency)) {\n                frequency = parseInt(TIME_AWARE_FREQUENCIES[0]);\n            }\n            if (frequency !== this._selectedFrequency) {\n                const periods = {\n                    mostRecent: this.mostRecentValue != '' ? this.mostRecentValue : null,\n                    showAll: this.showAll,\n                    start: this.startPeriodValue,\n                    end: this.endPeriodValue\n                };\n\n                this._selectedFrequency = frequency;\n                this.setPeriods(periods);\n                return true;\n            }\n        },\n        get selectedFrequencyOption() {\n            return (this.programFilterData && this.selectedFrequency !== null) ?\n                {value: this.selectedFrequency, label: this._frequencyLabels[this.selectedFrequency]} :\n                BLANK_OPTION;\n        },\n        set selectedFrequencyOption(option) {\n            this.setFrequency(option.value);\n        },\n        get periodsDisabled() {\n            return !this.programFilterData || !TIME_AWARE_FREQUENCIES.includes(this.selectedFrequency);\n        },\n        get periodRange() {\n            return this.periodsDisabled ?\n                {years: [], options: [BLANK_OPTION]} :\n                this.programFilterData.periodRanges.get(this.selectedFrequency);\n        },\n        get startOptions() {\n            if (IRREGULAR_FREQUENCIES.includes(this.selectedFrequency)) {\n                // select is disabled for irregular frequencies, display blank in disabled box\n                return [BLANK_OPTION];\n            }\n            if (this.selectedFrequency == 3) {\n                return this.periodRange.options;\n            }\n            let yearGroups = this.periodRange.years.map(\n                year => ({label: year, options: this.periodRange.options.filter(periodRange => periodRange.year == year)})\n            ).filter(yearGroup => yearGroup.options.length > 0)\n            if (yearGroups.length == 0) {\n                return [BLANK_OPTION];\n            }\n            if (yearGroups.length == 1) {\n                return yearGroups[0].options;\n            }\n            return yearGroups;\n        },\n        get endOptions() {\n            if (IRREGULAR_FREQUENCIES.includes(this.selectedFrequency)) {\n                // select is disabled for irregular frequencies, display blank in disabled box\n                return [BLANK_OPTION];\n            }\n            let options = this.periodRange.options.filter(periodOption => (!this.startPeriodValue || (periodOption.value >= this.startPeriodValue)));\n            if (this.selectedFrequency == 3) {\n                return options;\n            }\n            let yearGroups = this.periodRange.years.map(\n                year => ({label: year, options: options.filter(periodRange => periodRange.year == year)})\n            ).filter(yearGroup => yearGroup.options.length > 0);\n            if (yearGroups.length == 0) {\n                return [BLANK_OPTION];\n            }\n            if (yearGroups.length == 1) {\n                return yearGroups[0].options;\n            }\n            return yearGroups;\n        },\n        get _lastPeriod() {\n            return this.periodsDisabled ? null : this.programFilterData.periodRanges.get(this.selectedFrequency).periodCount - 1;\n        },\n        get _currentPeriod() {\n            return this.periodsDisabled ? null : this.programFilterData.periodRanges.get(this.selectedFrequency).currentPeriod;\n        },\n        get mostRecentChecked() {\n            return this.mostRecentValue !== '';\n        },\n        get mostRecentValue() {\n            return (this.periodsDisabled || this.showAll || this.endPeriodValue !== this._currentPeriod) ? '' :\n                    this.endPeriodValue - this.startPeriodValue + 1;\n        },\n        get showAll() {\n            /* _mostRecentForce - for when the selected # of most recent periods is the same as\n             * all periods, but the checkbox should say \"most recent\"\n             */\n            return (this.periodsDisabled || this._mostRecentForce) ? false :\n                this.startPeriodValue === 0 && this._lastPeriod && this.endPeriodValue == this._lastPeriod;\n        },\n        set showAll(value) {\n            this._mostRecentForce = false;\n            this.startPeriodValue = 0;\n            this.endPeriodValue = this._lastPeriod;\n        },\n        set mostRecentValue(value) {\n            this.startPeriodValue = 0;\n            this.endPeriodValue = this._currentPeriod;\n            this.startPeriodValue = this.endPeriodValue - value + 1;\n            if (this.showAll) {\n                this._mostRecentForce = true;\n                var self = this;\n                const unForce = reaction(\n                    () => [self.mostRecentChecked, self.startPeriodValue, self.endPeriodValue],\n                    (checked, reaction) => {\n                        self._mostRecentForce = false;\n                        reaction.dispose();\n                    }\n                );\n            }\n        },\n        get startPeriod() {\n            if (this.programFilterData && IRREGULAR_FREQUENCIES.includes(this.selectedFrequency)) {\n                return this.programFilterData.periodRanges.get(this.selectedFrequency).periods[0];\n            }\n            return (this.programFilterData && this.selectedFrequency && this._start !== null) ?\n                        this.programFilterData.periodRanges.get(this.selectedFrequency).periods[this._start] :\n                        null;\n        },\n        get startPeriodValue() {\n            return this.periodsDisabled ? null : this._start;\n        },\n        set startPeriodValue(startPeriod) {\n            startPeriod = !isNaN(parseInt(startPeriod)) ? parseInt(startPeriod) : 0;\n            if (this._lastPeriod !== null) {\n                this._start = Math.max(0, Math.min(this._lastPeriod, startPeriod));\n            }\n            if (this.endPeriodValue && this.startPeriodValue > this.endPeriodValue) {\n                this.endPeriodValue = this.startPeriodValue;\n            }\n        },\n        get endPeriod() {\n            if (this.programFilterData && IRREGULAR_FREQUENCIES.includes(this.selectedFrequency)) {\n                return this.programFilterData.periodRanges.get(this.selectedFrequency).periods.slice(-1).pop();\n            }\n            return (this.programFilterData && this.selectedFrequency && this._end !== null) ?\n                        this.programFilterData.periodRanges.get(this.selectedFrequency).periods[this._end] :\n                        null;\n        },\n        get endPeriodValue() {\n            return this.periodsDisabled ? null : this._end;\n        },\n        set endPeriodValue(endPeriod) {\n            endPeriod = !isNaN(parseInt(endPeriod)) ? parseInt(endPeriod) : this._lastPeriod;\n            if (this._lastPeriod !== null) {\n                this._end = Math.max((this.startPeriodValue || 0), Math.min(this._lastPeriod, endPeriod));\n            }\n        },\n        setTimeframe({mostRecent = null, showAll = null} = {}) {\n            if (mostRecent) {\n                this.mostRecentValue = mostRecent;\n            }\n            if (showAll) {\n                this.showAll = true;\n            }\n        },\n        setPeriods({mostRecent = null, showAll = null, start = null, end = null}) {\n            if (mostRecent) {\n                this.mostRecentValue = mostRecent;\n            }\n            else if (showAll) {\n                this.showAll = true;\n            }\n            else {\n                this.startPeriodValue = start;\n                this.endPeriodValue = end;\n            }\n        },\n        get resultsFramework() {\n            return this.programFilterData && this.programFilterData.resultsFramework;\n        },\n        get resultChainFilterLabel() {\n            return this.programFilterData ? this.programFilterData.resultChainFilterLabel : null;\n        },\n        get groupBy() {\n            return this.resultsFramework ? this._groupBy : null;\n        },\n        set groupBy(groupBy) {\n            this._groupBy = parseInt(groupBy) === GROUP_BY_LEVEL ? GROUP_BY_LEVEL : GROUP_BY_CHAIN;\n        },\n        get allLevels() {\n            return (this.resultsFramework ?\n                    (this.groupBy === GROUP_BY_CHAIN) ?\n                      this.programFilterData.levelsInChainOrder :\n                      this.programFilterData.levelsInLevelOrder : []) || [];\n        },\n        get levels() {\n            return this.allLevels;\n        },\n        get _levelOptions() {\n            let levelPks = this.resultsFramework ?\n                [...this.getAllIndicators('levels').map(indicator => indicator.levelPk),\n                 ...this._indicatorFilters.levels] : [];\n            return this.levels.filter(\n                level => (level.isResultChainLevel && levelPks.includes(level.pk)))\n            .map(\n                level => ({value: level.pk, label: level.resultChainLabel, category: \"level\"})\n            );\n        },\n        get _tierOptions() {\n            let tierPks = this.resultsFramework ?\n                [...this.getAllIndicators('levels')\n                    .filter(indicator => indicator.levelPk)\n                    .map(indicator => this.programFilterData.levels.get(indicator.levelPk).tierPk),\n                    ...this._indicatorFilters.tiers] : [];\n            return this.programFilterData ?\n                (Array.from(this.programFilterData.tiers.values()) || [])\n                .filter(tier => tierPks.includes(tier.pk))\n                .map(tier => ({value: tier.pk, label: tier.name, category: \"tier\"})) : [];\n        },\n        get _oldLevelOptions() {\n            let oldLevelPks = this.resultsFramework ? [] :\n                [...this.getAllIndicators('levels').map(indicator => indicator.levelPk),\n                 ...this._indicatorFilters.oldLevels];\n            return this.programFilterData ?\n                (Array.from(this.programFilterData.oldLevels.values()) || [])\n                .filter(oldLevel => oldLevelPks.includes(oldLevel.pk))\n                .map(oldLevel => ({value: oldLevel.pk, label: oldLevel.name, category: \"oldLevel\"})) :\n            [BLANK_OPTION];\n        },\n        get levelTierOptions() {\n            if (!this.programFilterData) {\n                return [BLANK_OPTION];\n            }\n            if (this.programFilterData.resultsFramework) {\n                let optGroups = [\n                    {label: '', options: this._tierOptions},\n                    {label: this.programFilterData.resultChainLabel, options: this._levelOptions}\n                ].filter(optGroup => (optGroup.options && optGroup.options.length > 0));\n                if (optGroups && optGroups.length > 0) {\n                    return optGroups;\n                }\n                return [BLANK_OPTION];\n            }\n            return (this._oldLevelOptions && this._oldLevelOptions.length > 0) ? this._oldLevelOptions : [BLANK_OPTION];\n        },\n        get levelTierFilters() {\n            return [\n                ...this._tierOptions.filter(option => this._indicatorFilters.tiers.includes(option.value)),\n                ...this._levelOptions.filter(option => this._indicatorFilters.levels.includes(option.value)),\n                ...this._oldLevelOptions.filter(option => this._indicatorFilters.oldLevels.includes(option.value)),\n            ];\n        },\n        set levelTierFilters({levels = [], tiers = [], oldLevels = []} = {}) {\n            if (tiers.length > 0 && levels.length > 0) {\n                if (this._indicatorFilters.levels.length > 0) {\n                    levels = [];\n                } else {\n                    tiers = [];\n                }\n            }\n            this._indicatorFilters.tiers = this.resultsFramework ? tiers : [];\n            this._indicatorFilters.levels = this.resultsFramework ? levels : [];\n            this._indicatorFilters.oldLevels = this.resultsFramework ? [] : oldLevels;\n        },\n        get sectorOptions() {\n            let sectorPks = [...new Set(this.getAllIndicators('sectors')\n                .filter(indicator => indicator.sectorPk)\n                .map(indicator => indicator.sectorPk)),\n            ...this._indicatorFilters.sectors];\n            return this.programFilterData ?\n                    Array.from(this.programFilterData.sectors.values())\n                        .filter(sector => sectorPks.includes(sector.pk))\n                        .map(sector => ({value: sector.pk, label: sector.name})) :\n                    [BLANK_OPTION];\n        },\n        get sectorFilters() {\n            return this.sectorOptions.filter(option => this._indicatorFilters.sectors.includes(option.value));\n        },\n        set sectorFilters(sectorFilterValues = []) {\n            this._indicatorFilters.sectors = sectorFilterValues.map(v => parseInt(v));\n        },\n        get siteOptions() {\n            let sitePks = [...new Set(this.getAllIndicators('sites').map(\n                indicator => Array.from(indicator._sitePks.values())\n            ).reduce((a, b) => a.concat(b), [])),\n            ...this._indicatorFilters.sites];\n            return this.programFilterData ?\n                    Array.from(this.programFilterData.sites.values())\n                        .filter(site => sitePks.includes(site.pk))\n                        .map(site => ({value: site.pk, label: site.name})) :\n                    [BLANK_OPTION];\n        },\n        get siteFilters() {\n            return this.siteOptions.filter(option => this._indicatorFilters.sites.includes(option.value));\n        },\n        set siteFilters(siteFilterValues = []) {\n            this._indicatorFilters.sites = siteFilterValues.map(v => parseInt(v));\n        },\n        get disaggregationOptions() {\n            let disaggregationPks = [...new Set(this.getAllIndicators('disaggregations').map(\n                indicator => Array.from(indicator._disaggregationPks.values())\n            ).reduce((a, b) => a.concat(b), [])),\n            ...this._indicatorFilters.disaggregations];\n            if (!this.programFilterData) {\n                return [BLANK_OPTION];\n            }\n            let disaggregationOptions = Array.from(this.programFilterData.disaggregations.values())\n                                                .filter(disaggregation => disaggregationPks.includes(disaggregation.pk))\n                                                .map(disaggregation => ({value: disaggregation.pk, label: disaggregation.name, country: disaggregation.country}));\n            let countries = [...new Set(disaggregationOptions.map(option => option.country))].filter(country => country !== null).sort();\n            let optgroups = [];\n            /* # Translators: User-selectable option that filters out rows from a table where the disaggregation category has not been used (i.e. avoids showing lots of blank rows. */\n            optgroups.push({value: \"hide-categories\", label: gettext('Only show categories with results'), noList: true});\n            if (disaggregationOptions.filter(option => option.country === null).length > 0) {\n                /* # Translators: filter that allows users to select only those disaggregation types that are available across the globe (i.e. across the agency). */\n                optgroups.push({label: gettext('Global disaggregations'), options: disaggregationOptions.filter(option => option.country === null)});\n            }\n            countries.forEach(\n                country => {\n                    /* # Translators: A list of disaggregation types follows this header. */\n                    optgroups.push({label: `${country} ${gettext('Disaggregations')}`, options:disaggregationOptions.filter(option => option.country === country)});\n                }\n            );\n            return optgroups;\n        },\n        get currentDisaggregations() {\n            let disaggregationPks = (this._indicatorFilters.disaggregations && this._indicatorFilters.disaggregations.length > 0)\n                ? this._indicatorFilters.disaggregations\n                : [...new Set(this.getAllIndicators('disaggregations').map(\n                        indicator => Array.from(indicator._disaggregationPks.values())\n                    ).reduce((a, b) => a.concat(b), []))];\n            return this.programFilterData ?\n                Array.from(this.programFilterData.disaggregations.values())\n                    .filter(disaggregation => disaggregationPks.includes(disaggregation.pk))\n                    .sort((disagg_a, disagg_b) => (disagg_a.name > disagg_b.name) ? 1 : -1)\n                    .map(disaggregation => disaggregation.pk) : []\n        },\n        get disaggregationFilters() {\n            let disaggregationOptions = [].concat.apply([], this.disaggregationOptions.slice(1).map(optgroup => optgroup.options));\n            disaggregationOptions = disaggregationOptions.filter(option => (option && option.value && this._indicatorFilters.disaggregations.includes(option.value)));\n            if (this._hiddenCategories) {\n                disaggregationOptions = [this.disaggregationOptions[0], ...disaggregationOptions];\n            }\n            return disaggregationOptions;\n        },\n        set disaggregationFilters(disaggregationFilterValues = []) {\n            this._indicatorFilters.disaggregations = disaggregationFilterValues.filter(v => (v != 'hide-categories' && v != 'NaN' && !isNaN(parseInt(v)))).map(v => parseInt(v));\n            this._hiddenCategories = disaggregationFilterValues.includes('hide-categories');\n        },\n        get indicatorTypeOptions() {\n            let typePks = [...new Set(this.getAllIndicators('types').map(\n                indicator => Array.from(indicator._typePks.values())\n            ).reduce((a, b) => a.concat(b), [])),\n            ...this._indicatorFilters.indicatorTypes];\n            return this.programFilterData ?\n                    Array.from(this.programFilterData.indicatorTypes.values())\n                        .filter(indicatorType => typePks.includes(indicatorType.pk))\n                        .map(indicatorType => ({value: indicatorType.pk, label: indicatorType.name})) :\n                    [BLANK_OPTION];\n        },\n        get indicatorTypeFilters() {\n            return this.indicatorTypeOptions.filter(option => this._indicatorFilters.indicatorTypes.includes(option.value));\n        },\n        set indicatorTypeFilters(indicatorTypeFilterValues = []) {\n            this._indicatorFilters.indicatorTypes = indicatorTypeFilterValues.map(v => parseInt(v));\n        },\n        _filterFrequency(indicators) {\n            indicators = indicators || [];\n            if (this.isTVA) {\n                indicators = indicators.filter(indicator => indicator.frequency == this.selectedFrequency);\n            }\n            return indicators;\n        },\n        _filterLevelTiers(indicators) {\n            indicators = indicators || [];\n            if (this.resultsFramework && this._indicatorFilters.tiers && this._indicatorFilters.tiers.length > 0) {\n                indicators = indicators.filter(indicator => {\n                    return (indicator.levelPk &&\n                            this._indicatorFilters.tiers.some(\n                                tierPk => this.programFilterData.levels.get(indicator.levelPk).showForTier(tierPk)));\n                });\n            }\n            if (this.resultsFramework && this._indicatorFilters.levels && this._indicatorFilters.levels.length > 0) {\n                indicators = indicators.filter(indicator => {\n                    return (indicator.levelPk &&\n                            this._indicatorFilters.levels.some(\n                                levelPk => this.programFilterData.levels.get(indicator.levelPk).showForChain(levelPk)\n                            ));\n                });\n            }\n            if (!this.resultsFramework && this._indicatorFilters.oldLevels && this._indicatorFilters.oldLevels.length > 0) {\n                indicators = indicators.filter(indicator => (indicator.levelPk && this._indicatorFilters.oldLevels.includes(indicator.levelPk)));\n            }\n            return indicators;\n        },\n        _filterSites(indicators) {\n            if (this._indicatorFilters.sites && this._indicatorFilters.sites.length > 0) {\n                indicators = indicators.filter(\n                    indicator => this._indicatorFilters.sites.some(sitePk => indicator.hasSite(sitePk))\n                );\n            }\n            return indicators;\n        },\n        _filterDisaggregations(indicators) {\n            if (this._indicatorFilters.disaggregations && this._indicatorFilters.disaggregations.length > 0) {\n                indicators = indicators.filter(\n                    indicator => this._indicatorFilters.disaggregations.some(disaggregationPk => indicator.hasDisaggregation(disaggregationPk))\n                );\n            }\n            return indicators;\n        },\n        _filterIndicatorTypes(indicators) {\n            if (this._indicatorFilters.indicatorTypes && this._indicatorFilters.indicatorTypes.length > 0) {\n                indicators = indicators.filter(\n                    indicator => this._indicatorFilters.indicatorTypes.some(typePk => indicator.hasIndicatorType(typePk))\n                );\n            }\n            return indicators;\n        },\n        _filterSectors(indicators) {\n            if (this._indicatorFilters.sectors && this._indicatorFilters.sectors.length > 0) {\n                indicators = indicators.filter(\n                    indicator => (indicator.sectorPk && this._indicatorFilters.sectors.includes(indicator.sectorPk))\n                );\n            }\n            return indicators;\n        },\n        _filterIndicatorFilter(indicators) {\n            indicators = indicators || [];\n            if (this._indicatorFilters.indicators && this._indicatorFilters.indicators.length > 0) {\n                indicators = indicators.filter(indicator => this._indicatorFilters.indicators.includes(indicator.pk));\n            }\n            return indicators;\n        },\n        filterIndicators(indicators, skip=false) {\n            indicators = indicators || [];\n            indicators = this._filterFrequency(indicators);\n            if (skip != 'levels') {\n                indicators = this._filterLevelTiers(indicators);\n            }\n            if (skip != 'disaggregations') {\n                indicators = this._filterDisaggregations(indicators);\n            }\n            if (skip != 'sites') {\n                indicators = this._filterSites(indicators);\n            }\n            if (skip != 'types') {\n                indicators = this._filterIndicatorTypes(indicators);\n            }\n            if (skip != 'sectors') {\n                indicators = this._filterSectors(indicators);\n            }\n            if (skip != 'indicators') {\n                indicators = this._filterIndicatorFilter(indicators);\n            }\n            return indicators;\n        },\n        getUnassignedIndicators(skip=false) {\n            return this.filterIndicators(this.programFilterData.unassignedIndicators, skip);\n        },\n        getLevelIndicators(levelPk, skip=false) {\n            return this.filterIndicators((this.programFilterData.levelIndicators.get(levelPk) || [])\n                .map(\n                    indicatorPk => this.programFilterData.indicators.get(indicatorPk)\n                ), skip) || [];\n        },\n        getAllIndicators(skip=false) {\n            if (this.programFilterData) {\n                let indicators = this.groupBy === GROUP_BY_CHAIN ?\n                            this.programFilterData.indicatorsInChainOrder :\n                            this.programFilterData.indicatorsInLevelOrder;\n                return this.filterIndicators(indicators, skip);\n            }\n            return [];\n        },\n        getLevelIndicatorGroups(skip=false) {\n            if (this.resultsFramework) {\n                return [...this.levels.map(\n                    level => ({level: level, indicators: this.getLevelIndicators(level.pk, skip)})\n                ), {level: null, indicators: this.getUnassignedIndicators(skip)}];\n            }\n            return (Array.from(this.programFilterData.oldLevels.values()) || [])\n                    .map(oldLevel => ({level: oldLevel,\n                                      indicators: this.getAllIndicators(skip)\n                                                    .filter(indicator => indicator.levelPk == oldLevel.pk)\n                                     }));\n        },\n        get indicatorOptions() {\n            if (this.programFilterData) {\n                let groups = this.getLevelIndicatorGroups('indicators');\n                if (this.resultsFramework) {\n                    groups = groups.map(\n                        /* # Translators: Allows users to filter an indicator list for indicators that are unassigned. */\n                        levelGroup => ({label: levelGroup.level ? levelGroup.level.tierNumber : gettext('Indicators unassigned to  a results framework level'),\n                                        options: levelGroup.indicators.map(indicator => ({value: indicator.pk, label: indicator.name}))\n                    }));\n                } else {\n                    groups = groups.map(\n                        levelGroup => ({label: levelGroup.level.name,\n                                        options: levelGroup.indicators.map(indicator => ({value: indicator.pk, label: indicator.name}))\n                        }));\n                }\n                groups = groups.filter(\n                    levelGroup => levelGroup.options && levelGroup.options.length > 0\n                );\n                if (groups.length === 0) {\n                    return [BLANK_OPTION];\n                } else if (groups.length === 1) {\n                    return groups[0].options;\n                }\n                return groups;\n            }\n            return [BLANK_OPTION];\n        },\n        get indicatorFilters() {\n            var options = this.indicatorOptions;\n            if (!options || options.length == 0) {\n                return [];\n            }\n            if (options[0].options && options[0].options.length > 0) {\n                options = options.reduce((acc, optGroup) => [...acc, ...optGroup.options], []);\n            }\n            return options.filter(option => this._indicatorFilters.indicators.includes(option.value));\n        },\n        set indicatorFilters(indicatorFilterValues = []) {\n            this._indicatorFilters.indicators = indicatorFilterValues.map(v => parseInt(v));\n        },\n        clearFilters() {\n            this._indicatorFilters = {\n                levels: [],\n                tiers: [],\n                oldLevels: [],\n                disaggregations: [],\n                sectors: [],\n                sites: [],\n                indicatorTypes: [],\n                indicators: []\n            };\n            this._hiddenCategories = false;\n        },\n        get filtersActive() {\n            return Object.values(this._indicatorFilters).reduce((a, b) => a + b.length, 0) > 0 || this._hiddenCategories;\n        },\n        get hideColumnOptions() {\n            return [\n                {label: gettext('Unit of measure'), value: 0},\n                {label: gettext('Change'), value: 1},\n                {label: gettext('C / NC'), value: 2},\n                {label: '# / %', value: 3},\n                {label: gettext('Baseline'), value: 4}\n            ];\n        },\n        get hiddenColumns() {\n            return this.hideColumnOptions.filter(option => this._hiddenColumns.includes(option.value));\n        },\n        set hiddenColumns(hiddenColumnOptions = []) {\n            this._hiddenColumns = hiddenColumnOptions.map(v => parseInt(v));\n        },\n        get pathParams() {\n            let params = {\n                tva: this.isTVA,\n                programId: this.selectedProgramId,\n                frequency: this.selectedFrequency,\n                start: this.startPeriodValue,\n                end: this.endPeriodValue,\n                mr: this._mostRecentForce ? 1 : null,\n                groupby: this.groupBy,\n                levels: (this.resultsFramework ?\n                            this.levelTierFilters.filter(f => f.category == \"level\") :\n                            this.levelTierFilters.filter(f => f.category == \"oldLevel\")\n                        ).map(f => f.value),\n                tiers: this.resultsFramework ? this.levelTierFilters.filter(f => f.category == \"tier\").map(f => f.value) : null,\n                sectors: this.sectorFilters.map(f => f.value),\n                sites: this.siteFilters.map(f => f.value),\n                types: this.indicatorTypeFilters.map(f => f.value),\n                indicators: this.indicatorFilters.map(f => f.value),\n                disaggregations: this.disaggregationFilters.map(f => f.value),\n                columns: this.hiddenColumns.map(f => f.value),\n            };\n            Object.keys(params).forEach(\n                key => (params[key] === null) && delete params[key]\n            );\n            return params;\n        },\n        updateParams(params) {\n            if (params.programId) {\n                this._router.updateParams(params);\n            }\n        },\n        get queryString() {\n            let {tva, programId, ...params} = this.pathParams;\n            return Object.entries(params).filter(\n                ([key, value]) => (value === 0 || value) && (!Array.isArray(value) || value.length > 0)\n            ).map(\n                ([key, value]) => (!Array.isArray(value) ?\n                    `${key}=${value}` : value.map(v => `${key}=${v}`).join('&')\n                )\n            ).reduce((a, b) => a.concat(b), []).join('&');\n        },\n        get excelUrl() {\n            return this.selectedFrequency ? this._router.getExcelUrl(this.pathParams) : false;\n        },\n        get fullExcelUrl() {\n            return this.selectedProgramId ? this._router.getFullExcelUrl(this.pathParams) : false;\n        },\n    });\n    filterStore._reportType = filterStore._router.isTVA ? TVA : TIMEPERIODS;\n    filterStore._selectedProgramId = filterStore._router.programId;\n    filterStore._selectedFrequency = filterStore._router.frequency;\n    if (filterStore._router.timeframe) {\n        filterStore.setTimeframe(filterStore._router.timeframe);\n    } else {\n        filterStore.startPeriodValue = filterStore._router.start;\n        filterStore.endPeriodValue = filterStore._router.end;\n    }\n    filterStore._mostRecentForce = filterStore._router.mr;\n    filterStore.groupBy = filterStore._router.groupBy;\n    filterStore.sectorFilters = filterStore._router.sectors;\n    filterStore.siteFilters = filterStore._router.sites;\n    filterStore.disaggregationFilters = filterStore._router.disaggregations;\n    filterStore.indicatorTypeFilters = filterStore._router.types;\n    filterStore.indicatorFilters = filterStore._router.indicators;\n    filterStore._hiddenColumns = filterStore._router.columns;\n    filterStore._hiddenCategories = filterStore._router.hiddenCategories;\n    filterStore.levelTierFilters = {\n        levels: filterStore._router.levels,\n        tiers: filterStore._router.tiers,\n        oldLevels: filterStore._router.levels,\n    };\n    const _updateRouter = reaction(\n        () => filterStore.pathParams,\n        params => filterStore.updateParams(params),\n        {fireImmediately: true}\n    );\n    return filterStore;\n}\n","/**\n * Formats a decimal number from the received JSON value to a valid JS model value\n * formatting for user language / percent / etc. is next step, this normalizes nulls, strings, etc.\n * to a float if it has a decimal component, and an int otherwise\n */\nexport const formatDecimal = (value) => {\n    if (isNaN(parseFloat(value))) { return false; }\n    value = parseFloat(value);\n    if (Number.isInteger(value)) { return parseInt(value); }\n    return value;\n};","import { extendObservable } from 'mobx';\n\n\nconst bareRange = (\n    rangeJSON = {}\n) => ({\n    frequency: parseInt(rangeJSON.frequency),\n    get periodCount() {\n        return this.periods.length;\n    },\n    get currentPeriod() {\n        if ([1, 2, 8].includes(this.frequency)) {\n            return null;\n        }\n        return this.periods.filter(period => period.past).length - 1;\n    },\n    getLabel(period) {\n        if ([3, 4, 5, 6].includes(this.frequency)) {\n            return `${period.name} (${period.label})`;\n        }\n        if (this.frequency == 7) {\n            return period.name;\n        }\n    },\n    get options() {\n        return this.periods.map((period, index) => ({value: index, label: this.getLabel(period), year: period.year}));\n    }\n});\n\nexport const getPeriodDateRange = (\n    ...rangeConstructors\n) => (rangeJSON) => {\n    return [bareRange, ...rangeConstructors].reduce(\n        (acc, fn) => extendObservable(acc, fn(rangeJSON)), {});\n}\n","import React from 'react';\nimport IPTTFilterForm from './filterForm';\n\nexport default () => {\n    return (\n        <div className=\"sidebar_wrapper\">\n            <div className=\"collapse width show\" id=\"sidebar\">\n                <IPTTFilterForm />\n            </div>\n            <div className=\"sidebar-toggle\">\n              <a href=\"#\" data-target=\"#sidebar\" data-toggle=\"collapse\"\n                    title={\n                        /* # Translators: A toggle button that hides a sidebar of filter options */\n                        gettext('Show/Hide Filters') }>\n                <i className=\"fa fa-chevron-left\"></i>\n              </a>\n            </div>\n        </div>\n    );\n}\n","import React from 'react';\nimport { observer, inject } from 'mobx-react';\nimport { library } from '@fortawesome/fontawesome-svg-core'\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\"\nimport { faPlusSquare, faMinusSquare } from '@fortawesome/free-solid-svg-icons'\n\nlibrary.add(faPlusSquare, faMinusSquare)\n\nimport * as HeaderCells from './headerCells';\n\nconst ColGroups = inject('rootStore')(\n    observer(({ rootStore }) => {\n        return (\n            <React.Fragment>\n                <colgroup\n                    span={ rootStore.baseColumns + 1 }\n                    className=\"iptt-base-columns\" />\n                <colgroup\n                    span={ 3 }\n                    className=\"iptt-lop-columns\" />\n                {\n                    rootStore.reportPeriods.map(\n                        (period, index) => (\n                            <colgroup\n                                key={ index }\n                                span={ rootStore.isTVA ? 3 : 1 }\n                                className=\"iptt-period-columns\"\n                                id={ 'period-' + index }\n                            />\n                        )\n                    )\n                }\n            </React.Fragment>\n        )\n    })\n);\n\n\nconst ProgramNameRow = inject('rootStore')(\n    observer(({ rootStore }) => {\n        const program = rootStore.currentProgram;\n        if (!program) {\n            return (<tr><td>Loading</td></tr>);\n        }\n        return (\n            <tr className=\"title-row\">\n                <td\n                    colSpan={ rootStore.baseColumns + 1 }\n                    className=\"base-column\">\n                    <button className=\"btn btn-medium text-action btn-sm\"\n                        onClick={rootStore.expandAllRows.bind(rootStore)}\n                        disabled={ rootStore.allExpanded }>\n                        <FontAwesomeIcon icon=\"plus-square\" />\n                        { gettext('Expand all') }\n                    </button>\n                    <button className=\"btn btn-medium text-action btn-sm\"\n                        onClick={rootStore.collapseAllRows.bind(rootStore)}\n                        disabled={ rootStore.allCollapsed }>\n                        <FontAwesomeIcon icon=\"minus-square\" />\n                        { gettext('Collapse all') }\n                    </button>\n                </td>\n                <td\n                    colSpan={ 3 }\n                    // centered under LOP superheader\n                    className=\"iptt-period-header\">\n                    <HeaderCells.LopHeaderWithPopover>\n                    {\n                        /* # Translators: header for a group of columns showing totals over the life of the program */\n                        gettext('Life of program')\n                    }\n                    </HeaderCells.LopHeaderWithPopover>\n                </td>\n                {\n                    rootStore.reportPeriods.map(\n                        (period, index) => (\n                            <HeaderCells.PeriodHeader isTVA={ rootStore.isTVA} key={ index }\n                                                      period={ period } />\n                        )\n                    )\n                }\n            </tr>\n        );\n    })\n);\n\nconst ColumnHeaderRow = inject('rootStore')(\n    observer(({ rootStore }) => {\n        return (\n            <tr>\n                <HeaderCells.HeaderCell\n                    styleWidth={110}\n                    className='base-column'\n                    label={\n                        /* # Translators: Abbreviation as column header for \"number\" column */\n                        gettext('No.')\n                    } />\n                <HeaderCells.HeaderCell\n                    className='base-column'\n                    styleWidth={600}\n                    colSpan={2}\n                    label={\n                        /* # Translators: Column header for indicator Name column */\n                        gettext('Indicator')\n                    } />\n                <HeaderCells.HeaderCell\n                    className='base-column'\n                    // empty cell above gear widget column\n                    />\n                { !rootStore.filterStore.resultsFramework && <HeaderCells.HeaderCell\n                    className='base-column'\n                    styleWidth={90}\n                    label={\n                        /* # Translators: Column header for indicator Level name column */\n                        gettext('Level')\n                    } />\n                }\n                { rootStore.hasUOMColumn && <HeaderCells.HeaderCell\n                    className='base-column'\n                    styleWidth={250}\n                    label={\n                        /* # Translators: Column header */\n                        gettext('Unit of measure')\n                    } /> }\n                { rootStore.hasChangeColumn && <HeaderCells.HeaderCell\n                    className='base-column'\n                    label={\n                        /* # Translators: Column header for \"direction of change\" column (increasing/decreasing) */\n                        gettext('Change')\n                    } /> }\n                { rootStore.hasCNCColumn && <HeaderCells.HeaderCell\n                    className='base-column'\n                    styleWidth={130}\n                    label={\n                        /* # Translators: Column header, stands for \"Cumulative\"/\"Non-cumulative\" */\n                        gettext('C / NC')\n                    } /> }\n                { rootStore.hasUOMTypeColumn && <HeaderCells.HeaderCell\n                    className='base-column'\n                    styleWidth={50}\n                    label={\n                        /* # Translators: Column header, numeric or percentage type indicator */\n                        gettext('# / %')\n                    } /> }\n                { rootStore.hasBaselineColumn && <HeaderCells.HeaderCell\n                    className='base-column'\n                    label={\n                        /* # Translators: Column header */\n                        gettext('Baseline')\n                    } /> }\n                <HeaderCells.HeaderCell\n                    styleWidth={110}\n                    className='lop-column'\n                    label={\n                        /* # Translators: Column header for a target value column */\n                        gettext('Target')\n                    } />\n                <HeaderCells.HeaderCell\n                    styleWidth={110}\n                    className='lop-column'\n                    label={\n                        /* # Translators: Column header for an \"actual\" or achieved/real value column */\n                        pgettext('report (long) header', 'Actual')\n                    } />\n                <HeaderCells.HeaderCell\n                    styleWidth={110}\n                    className='lop-column'\n                    label={\n                        /* # Translators: Column header for a percent-met column */\n                        gettext('% Met')\n                    } />\n                { rootStore.reportPeriods.map(\n                    (period, index) => (rootStore.isTVA ?\n                                <HeaderCells.TVAHeader key={ index } /> :\n                                <HeaderCells.ActualHeader key={ index } />\n                              )\n                )}\n            </tr>\n        )\n    })\n);\n\nconst ReportTableHeader = () => {\n    return (\n        <React.Fragment>\n            <ColGroups />\n            <thead>\n                <ProgramNameRow />\n                <ColumnHeaderRow />\n            </thead>\n        </React.Fragment>\n        );\n}\n\nexport default ReportTableHeader;\n","import React from 'react';\nimport { inject, observer } from 'mobx-react';\nimport * as Selectors from './reportSelect';\nimport * as Filters from './reportFilter';\nimport { IPTTButton } from './buttons';\n\n\nconst FilterTop = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return (\n            <React.Fragment>\n                <Selectors.ProgramSelect />\n                <Selectors.FrequencySelect />\n                <Selectors.TimeframeRadio />\n                <Selectors.StartDateSelect />\n                <Selectors.EndDateSelect />\n                { filterStore.resultsFramework &&\n                    <Selectors.GroupingSelect />\n                }\n                <Filters.HiddenColumnSelect />\n            </React.Fragment>\n        );\n    })\n);\n\nconst FilterMiddle = () => {\n    return (\n        <React.Fragment>\n            <Filters.LevelSelect />\n            <Filters.DisaggregationSelect />\n            <Filters.SiteSelect />\n            <Filters.TypeSelect />\n            <Filters.SectorSelect />\n            <Filters.IndicatorSelect />\n        </React.Fragment>\n    );\n}\n\nconst IPTTFilterForm = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return (\n            <nav id=\"id_iptt_report_filter\">\n                <div className=\"p-3\" id=\"filter-top\">\n                    <h3 className=\"filter-title text-title-case\">\n                        {\n                        /* # Translators: Labels a set of filters to select which data to show */\n                         gettext('Report Options') }\n                    </h3>\n                    <FilterTop />\n                </div>\n                <div id=\"filter-middle\" className=\"px-3 pt-3 pb-2\">\n                    <FilterMiddle />\n                </div>\n                <div id=\"filter-bottom\">\n                    <IPTTButton\n                        label={\n                            /* # Translators: clears all filters set on a report */\n                            gettext('Clear filters')\n                        }\n                        action={ filterStore.clearFilters.bind(filterStore) }\n                        isDisabled={ !filterStore.filtersActive }\n                    />\n              </div>\n              { filterStore.programFilterData && (\n              <div id=\"filter-extra\" className=\" d-flex justify-content-between no-gutters p-3\">\n                  <a href={ `/tola_management/audit_log/${filterStore.selectedProgramId}/` }\n                      className=\"btn-link\">\n                      <i className=\"fas fa-history\"></i> {gettext(\"Change log\")}\n                  </a>\n              </div>\n              )}\n            </nav>\n        );\n    })\n);\n\nexport default IPTTFilterForm;\n","import createRouter from 'router5';\nimport browserPlugin from 'router5-plugin-browser';\nimport { observable } from 'mobx';\nimport { TVA, TIMEPERIODS } from '../../constants';\n\nconst goodQueryParams = ['frequency', 'start', 'end', 'levels', 'types', 'sites', 'disaggregations',    \n                         'sectors', 'indicators', 'tiers', 'groupby', 'mr', 'columns'];\nconst oldQueryParams = ['timeframe', 'numrecentperiods', 'numrecentcount', 'start_period', 'end_period'];\n\nconst queryParams = '?' + [...goodQueryParams, ...oldQueryParams].join('&');\n\nconst routes =  [\n    {\n        name: 'iptt',\n        path: '/iptt_report/:programId<\\\\d+>',\n        children: [\n            {\n                name: 'timeperiods',\n                path: '/timeperiods?timeperiods'\n            },\n            {\n                name: 'tva',\n                path: '/targetperiods?targetperiods'\n            }\n        ]\n    },\n    {\n        name: 'ipttExcel',\n        path: '/iptt_api/iptt_excel?fullTVA&reportType&programId'\n    }\n];\n\nconst parseArrayParams = (param) => {\n    if (typeof param === 'string' || param instanceof String) {\n        return [parseInt(param)];\n    } else if (Array.isArray(param)) {\n        return param.map(p => parseInt(p));\n    } else if (Number.isInteger(param)) {\n        return [param];\n    } else if (!isNaN(parseInt(param))) {\n        return [parseInt(param)];\n    }\n    return [];\n}\n\nexport default () => {\n    const router = createRouter(routes, {trailingSlashMode: 'always'});\n    router.setRootPath(queryParams);\n    router.usePlugin(browserPlugin({useHash: false, base: '/indicators'}));\n    router.start();\n    return observable.object({\n        _router: router,\n        get isTVA() {\n            return this._router.getState().name === 'iptt.tva';\n        },\n        get programId() {\n            return this._router.getState().params.programId;\n        },\n        get frequency() {\n            let {frequency, timeperiods, targetperiods, ...params} = this._router.getState().params;\n            if (!isNaN(parseInt(frequency))) { return parseInt(frequency); }\n            if (!isNaN(parseInt(timeperiods))) { return parseInt(timeperiods); }\n            if (!isNaN(parseInt(targetperiods))) { return parseInt(targetperiods); }\n            return null;\n        },\n        get start() {\n            return this._router.getState().params.start;\n        },\n        get end() {\n            return this._router.getState().params.end;\n        },\n        get timeframe() {\n            if (this._router.getState().params.timeframe == 2) {\n                return {mostRecent: this._router.getState().params.numrecentperiods};\n            } else if (this._router.getState().params.timeframe == 1) {\n                return {showAll: true};\n            }\n            return false;\n        },\n        get mr() {\n            return this._router.getState().params.mr == 1;\n        },\n        get groupBy() {\n            return this._router.getState().params.groupby;\n        },\n        get levels() {\n            return parseArrayParams(this._router.getState().params.levels);\n        },\n        get tiers() {\n            return parseArrayParams(this._router.getState().params.tiers);\n        },\n        get sectors() {\n            return parseArrayParams(this._router.getState().params.sectors);\n        },\n        get sites() {\n            return parseArrayParams(this._router.getState().params.sites);\n        },\n        get disaggregations() {\n            return parseArrayParams(this._router.getState().params.disaggregations);\n        },\n        get hiddenCategories() {\n            let disaggParams = this._router.getState().params.disaggregations;\n            return Array.isArray(disaggParams) ? disaggParams.includes('hide-categories') : disaggParams && disaggParams == 'hide-categories';\n        },\n        get columns() {\n            return parseArrayParams(this._router.getState().params.columns);\n        },\n        get types() {\n            return parseArrayParams(this._router.getState().params.types);\n        },\n        get indicators() {\n            return parseArrayParams(this._router.getState().params.indicators);\n        },\n        updateParams({tva, ...params}) {\n            let routeName = tva ? 'iptt.tva' : 'iptt.timeperiods'\n            let path = this._router.buildPath(routeName, params);\n            if (path !== this._router.getState().path) {\n                this._router.navigate(routeName, params, {replace: true});\n            }\n        },\n        get queryParams() {\n            return this._router.getState().params;\n        },\n        getExcelUrl({tva, ...params}) {\n            return this._router.buildUrl('ipttExcel',\n                                         {...params,\n                                         reportType: tva ? TVA : TIMEPERIODS,\n                                         fullTVA: false});\n        },\n        getFullExcelUrl({programId, groupby, ...params}) {\n            return this._router.buildUrl('ipttExcel',\n                                         {programId: programId,\n                                         groupBy: groupby,\n                                         fullTVA: true});\n        },\n    });\n}","import React from 'react';\n\nexport const IPTTButton = ( props ) => {\n    return (\n        <button type=\"reset\" className={ \"btn btn-block btn-reset\" + (props.isDisabled ? \" disabled\" : \"\")}\n             onClick={ props.action }>\n                { props.label }\n        </button>\n    );\n}","import React from 'react';\nimport { observer, inject } from 'mobx-react';\n\nimport { LevelGroup, IndicatorRow } from './tableRows';\n\nconst ReportTableBody = inject('rootStore', 'filterStore')(\n    observer(({ rootStore, filterStore }) => {\n        return (\n        <tbody>\n            {\n                rootStore.levelRows ?\n                    rootStore.levelRows.map(\n                        (levelRow, index) => (\n                            <LevelGroup\n                                level={ levelRow.level }\n                                indicators={ levelRow.indicators }\n                                key={ index } />\n                        )\n                    )\n                :\n                    rootStore.indicatorRows.map(\n                        (indicator, index) => (\n                            <IndicatorRow indicator={ indicator } key={ index } />\n                                            \n                        )\n                    )\n            }\n        </tbody>\n        );\n    })\n);\n\nexport default ReportTableBody;","import { observable } from 'mobx';\n\nimport { getIndicator, withMeasurement } from '../../../models/indicator';\n\n/**\n * IPTT specific indicator model constructor:\n * JSON params:\n *    sector_pk int\n *    indicator_type_pks  [int]\n *    site_pks [int]\n */\n\nexport const forIPTT = (\n    indicatorJSON = {}\n) => ({\n    number: indicatorJSON.number || null,\n    sectorPk: indicatorJSON.sector_pk || null,\n    _typePks: observable(new Set(indicatorJSON.indicator_type_pks || [])),\n    hasIndicatorType(indicatorTypePk) {\n        return !isNaN(parseInt(indicatorTypePk)) && this._typePks.has(parseInt(indicatorTypePk));\n    },\n    _sitePks: observable(new Set(indicatorJSON.site_pks || [])),\n    hasSite(sitePk) {\n        return !isNaN(parseInt(sitePk)) && this._sitePks.has(parseInt(sitePk));\n    },\n    _disaggregationPks: observable(new Set(indicatorJSON.disaggregation_pks || [])),\n    hasDisaggregation(disaggregationPk) {\n        return !isNaN(parseInt(disaggregationPk)) && this._disaggregationPks.has(parseInt(disaggregationPk));\n    },\n    hasDisaggregations(disaggregationsPks) {\n        return disaggregationsPks.filter(pk => this._disaggregationPks.has(pk)).length > 0;\n    }\n});\n\nexport default getIndicator(withMeasurement, forIPTT);","import { observable } from 'mobx';\n\nimport { getProgram, withReportingPeriod, withRFLevelOrdering } from '../../../models/program';\n\nimport { getPeriodDateRange } from '../../../models/periodDateRange';\nimport IPTTIndicator from './ipttIndicator';\nimport IPTTLevel from './ipttLevel';\n\n\nconst IPTTPeriod = (\n    periodJSON = {}\n) => ({\n    _frequency: parseInt(periodJSON.frequency),\n    _name: periodJSON.name,\n    label: periodJSON.label,\n    start: new Date(periodJSON.start),\n    startLabel: periodJSON.start_label,\n    end: new Date(periodJSON.end),\n    endLabel: periodJSON.end_label,\n    past: Boolean(periodJSON.past),\n    year: periodJSON.year,\n    get range() {\n        return [2, 7].includes(this._frequency) ? null : `${this.startLabel} – ${this.endLabel}`;\n    },\n    get name() {\n        return this._frequency == 7 ? `${this._name} ${this.year}` : this._name;\n    }\n});\n\nconst forIPTTDateRange = (\n    rangeJSON = {}\n) => ({\n    periods: rangeJSON.periods.map(periodJSON => IPTTPeriod({...periodJSON, frequency: rangeJSON.frequency})),\n    years: [...new Set(rangeJSON.periods.map(periodJSON => periodJSON.year))].sort(),\n});\n\nconst IPTTPeriodDateRange = getPeriodDateRange(forIPTTDateRange);\n\n\n/**\n * IPTT Report page specific model constructor\n * JSON params:\n *   frequencies [int]\n *   period_date_ranges (IPTTPeriodDateRange)\n * @return {Object}\n */\n\nexport const forIPTT = (\n    programJSON = {}\n) => ({\n    frequencies: observable(new Set((programJSON.frequencies || [])\n                                     .map(frequency => parseInt(frequency))\n                                     .filter(frequency => !isNaN(frequency)))),\n    periodRanges: observable(new Map(Object.entries(programJSON.period_date_ranges || {})\n        .map(([frequency, periodsJSON]) => {\n            let freq = parseInt(frequency);\n            return [freq, IPTTPeriodDateRange({frequency: freq, periods: periodsJSON})];\n        }))),\n    validFrequency(frequency) {\n        return !isNaN(parseInt(frequency)) && this.frequencies.has(parseInt(frequency));\n    },\n    resultChainLabel: programJSON.result_chain_label,\n    indicators: observable(new Map((programJSON.indicators || []).map(\n        indicatorJSON => IPTTIndicator(indicatorJSON)).map(\n        indicator => [indicator.pk, indicator]\n        ))),\n    levels: observable(new Map((programJSON.levels || []).map(levelJSON => IPTTLevel(levelJSON)).map(level => [level.pk, level]))),\n    tiers: observable(new Map((programJSON.tiers || []).map(\n        tierJSON => [parseInt(tierJSON.pk), {pk: parseInt(tierJSON.pk), name: tierJSON.name, depth: tierJSON.tier_depth}]\n        ))),\n    oldLevels: observable(new Map((programJSON.old_levels || []).map(\n        oldLevelJSON => [parseInt(oldLevelJSON.pk), {pk: oldLevelJSON.pk, name: oldLevelJSON.name}]))),\n    sectors: observable(new Map((programJSON.sectors || []).map(\n        sectorJSON => [parseInt(sectorJSON.pk), {pk: parseInt(sectorJSON.pk), name: sectorJSON.name}]\n        ))),\n    sites: observable(new Map((programJSON.sites || []).map(\n        siteJSON => [parseInt(siteJSON.pk), {pk: parseInt(siteJSON.pk), name: siteJSON.name}]\n        ))),\n    disaggregations: observable(new Map((programJSON.disaggregations || []).map(\n        disaggregationJSON => [parseInt(disaggregationJSON.pk), {\n                                   pk: parseInt(disaggregationJSON.pk),\n                                   // Only translate disagg type if it's a global disagg\n                                   name: disaggregationJSON.country ? disaggregationJSON.name : gettext(disaggregationJSON.name),\n                                   country: disaggregationJSON.country || null,\n                                   labels: (disaggregationJSON.labels || []).map(\n                                        labelJSON => ({pk: parseInt(labelJSON.pk), name: labelJSON.name}))\n                               }]\n        ).filter(([disaggregationPk, disaggregation]) => (disaggregation.labels && disaggregation.labels.length > 0)))),\n    indicatorTypes: observable(new Map((programJSON.indicator_types || []).map(\n        indicatorTypeJSON => [parseInt(indicatorTypeJSON.pk), {pk: parseInt(indicatorTypeJSON.pk), name: indicatorTypeJSON.name}]\n        ))),\n    deleteIndicator(indicatorPk) {\n        if (!isNaN(parseInt(indicatorPk))) {\n            return this.updateOrder().then(success => {\n                this.indicators.delete(parseInt(indicatorPk));\n            });\n        }\n        return this.updateOrder();\n    }\n});\n\nexport default getProgram(withReportingPeriod, withRFLevelOrdering, forIPTT);\n","/**\n * entry point for the iptt_report webpack bundle\n */\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'mobx-react';\n\nimport IPTTReportApp from './components/ipttReport';\nimport IPTTRootStore from './models/ipttRootStore';\n\n\nconst rootStore = new IPTTRootStore(reactContext);\n\nReactDOM.render(<Provider rootStore={ rootStore }\n                          filterStore={ rootStore.filterStore }\n                          reportStore={ rootStore.reportStore }>\n                    <IPTTReportApp />\n                </Provider>,\n                document.querySelector('#id_div_content'));\n","import React from 'react';\nimport { observer, inject } from 'mobx-react';\nimport { PinButton, ExcelButton, ExcelPopoverButton } from './buttons';\n\n\nconst IPTTHeader = inject('filterStore', 'rootStore')(\n    observer(({ filterStore, rootStore }) => {\n        return <React.Fragment>\n            <div className=\"page-subheader\">\n                    <div id=\"id_span_iptt_date_range\" className=\"subheader__title\">\n                        <h2 className=\"text-title-case\">{\n                            gettext('Indicator Performance Tracking Table')\n                        }</h2>\n                        <h4>{ (filterStore.startPeriod && filterStore.endPeriod)\n                                               ? filterStore.startPeriod.startLabel + \" - \" + filterStore.endPeriod.endLabel\n                                               : \"\" }</h4>\n                    </div>\n                    <div className=\"subheader__actions\">\n                        <div className=\"btn-row\">\n                            <PinButton />\n                            {filterStore.isTVA ? <ExcelPopoverButton { ...rootStore.excelAPI }/> :\n                                <ExcelButton excelUrl={ rootStore.excelAPI.excelUrl } />}\n                        </div>\n                    </div>\n                </div>\n                { rootStore.currentProgram &&\n                    <h3><a href={ rootStore.currentProgramPageUrl }>\n                    { rootStore.currentProgram.name }</a>\n                    </h3>\n                }\n            </React.Fragment>\n    })\n);\n\n\nexport default IPTTHeader;\n","import { extendObservable } from 'mobx';\n\n/**\n * Bare level constructor\n * JSON params:\n *  pk: (string|number)\n *  name: (str)\n *  ontology: (str)\n *  tier_name ([tr] (str))\n */\n\nconst bareLevel = (\n    levelJSON = {}\n) => ({\n    pk: parseInt(levelJSON.pk),\n    name: levelJSON.name,\n    ontology: levelJSON.ontology || null,\n    tierName: levelJSON.tier_name\n});\n\nexport const getLevel = (\n    ...levelConstructors\n) => ( levelJSON = {} ) => [bareLevel, ...levelConstructors].reduce(\n    (acc, fn) => extendObservable(acc, fn(levelJSON)), {});","import { observable, runInAction } from 'mobx';\nimport getIndicatorReport from './ipttIndicatorReport';\nimport { TIME_AWARE_FREQUENCIES, IRREGULAR_FREQUENCIES } from '../../../constants';\nimport api from '../../../apiv2';\n\n\n\nexport default (\n    reportJSON = {}\n) => {\n    const LOADING = 1;\n    const LOADED = 2;\n    \n    let reportStore = observable({\n        _reportMap: observable.map([...TIME_AWARE_FREQUENCIES, ...IRREGULAR_FREQUENCIES].sort()\n                                    .map(frequency => [frequency, observable.map()])),\n        getReport(frequency) {\n            return this._reportMap.get(frequency);\n        },\n        programStatus: observable.map([...TIME_AWARE_FREQUENCIES, ...IRREGULAR_FREQUENCIES].sort()\n                                      .map(frequency => [frequency, observable.map()])),\n        callForReportData({update, ...params}) {\n            let programPk = parseInt(params.programPk);\n            let frequency = parseInt(params.frequency);\n            if (this.programStatus.get(frequency).get(programPk) === LOADING) {\n                return Promise.resolve(false);\n            }\n            if (!update && this.programStatus.get(frequency).get(programPk) === LOADED) {\n                return Promise.resolve(false);\n            }\n            this.programStatus.get(frequency).set(programPk, LOADING);\n            return api.getIPTTReportData(params)\n                    .then(data => {\n                        runInAction(() => {\n                            this.updateReportData(data);\n                        });\n                    });\n        },\n        updateReportData(reportData) {\n            var frequency = parseInt(reportData.report_frequency);\n            (reportData.report_data || [])\n                .forEach(indicatorReportJSON => {\n                    let indicatorReport = getIndicatorReport(frequency, indicatorReportJSON);\n                    this._reportMap.get(frequency).set(indicatorReport.pk, indicatorReport)\n                });\n            this.programStatus.get(frequency).set(parseInt(reportData.program_pk), LOADED);\n            return reportData;\n        }\n    });\n    if (reportJSON && reportJSON.report_data) {\n        let frequency = parseInt(reportJSON.report_frequency);\n        let initialReportData = reportStore.getReport(frequency);\n        (reportJSON.report_data || [])\n            .map(indicatorReportJSON => getIndicatorReport(frequency, indicatorReportJSON))\n            .forEach(indicatorReport => initialReportData.set(indicatorReport.pk, indicatorReport))\n        reportStore.programStatus.get(frequency).set(parseInt(reportJSON.program_pk), LOADED);\n    }\n    return reportStore;\n}","import { observable } from 'mobx';\n\nimport { getLevel } from '../../../models/level';\n\n/**\n * IPTT specific level model constructor:\n * JSON params:\n *    tier_pk int\n *    chain_pk int\n */\n\nexport const forIPTT = (\n    levelJSON = {}\n) => ({\n    tierPk: !isNaN(parseInt(levelJSON.tier_pk)) ? parseInt(levelJSON.tier_pk) : null,\n    tierDepth: parseInt(levelJSON.tier_depth),\n    showForTier(tierPk) {\n        return !isNaN(parseInt(tierPk)) && parseInt(tierPk) === this.tierPk;\n    },\n    chainPk: !isNaN(parseInt(levelJSON.chain_pk)) ? parseInt(levelJSON.chain_pk) : null,\n    _alwaysShowChain: false, // && levelJSON.chain_pk === 'all',\n    showForChain(chainPk) {\n        return this._alwaysShowChain || (!isNaN(parseInt(chainPk)) && parseInt(chainPk) === this.chainPk);\n    },\n    get isResultChainLevel() {\n        return this.chainPk && this.chainPk == this.pk;\n    },\n    get tierNumber() {\n        return `${this.tierName}` + (this.ontology ? ` ${this.ontology}` : ``);\n    },\n    get resultChainLabel() {\n        /* # Translators: this labels a filter option for a label as including subordinate levels */\n        let labelStr = gettext('%(this_level_number)s and sub-levels: %(this_level_full_name)s');\n        return interpolate(labelStr, {this_level_number: this.tierNumber, this_level_full_name: this.name}, true); \n    }\n});\n\nexport default getLevel(forIPTT);","/* Site-wide constants */\n\n\n/**\n * JS_GLOBALS is in base.html (base Tola template) - delivered by middleware from the backend\n * this function returns the global constant for a given key (i.e. 'reason_for_change_options')\n */\n\nfunction getGlobal(key) {\n    if ((typeof JS_GLOBALS !== 'undefined')  && JS_GLOBALS.hasOwnProperty(key)) {\n        return JS_GLOBALS[key];\n    }\n    return null;\n}\n\n\n/**\n * IPTT Constants:\n */\nconst BLANK_LABEL = '---------';\nconst BLANK_OPTION = {\n    value: null,\n    label: BLANK_LABEL\n};\nconst EM_DASH = \"—\";\nconst BLANK_TABLE_CELL = EM_DASH;\n\n\nconst TVA = 1;\nconst TIMEPERIODS = 2;\n\nconst TIME_AWARE_FREQUENCIES = [3, 4, 5, 6, 7];\nconst IRREGULAR_FREQUENCIES = [1, 2];\n\nconst TVA_FREQUENCY_LABELS = Object.freeze(\n    {\n        1: gettext(\"Life of Program (LoP) only\"),\n        2: gettext(\"Midline and endline\"),\n        3: gettext(\"Annual\"),\n        4: gettext(\"Semi-annual\"),\n        5: gettext(\"Tri-annual\"),\n        6: gettext(\"Quarterly\"),\n        7: gettext(\"Monthly\")\n    }\n);\n\nconst TIMEPERIODS_FREQUENCY_LABELS = Object.freeze(\n    {\n        3: gettext(\"Years\"),\n        4: gettext(\"Semi-annual periods\"),\n        5: gettext(\"Tri-annual periods\"),\n        6: gettext(\"Quarters\"),\n        7: gettext(\"Months\")\n    }\n);\n\nexport { BLANK_OPTION, BLANK_LABEL, BLANK_TABLE_CELL, EM_DASH, TVA, TIMEPERIODS, TIME_AWARE_FREQUENCIES,\n         IRREGULAR_FREQUENCIES, TVA_FREQUENCY_LABELS, TIMEPERIODS_FREQUENCY_LABELS };\n\nconst GROUP_BY_CHAIN = 1;\nconst GROUP_BY_LEVEL = 2;\n\nexport { GROUP_BY_CHAIN, GROUP_BY_LEVEL };\n\nconst _gettext = (typeof gettext !== 'undefined') ?  gettext : (s) => s;\n\nfunction getPeriodLabels() {\n    return {\n        targetperiodLabels: {\n            1: _gettext(\"Life of Program (LoP) only\"),\n            3: _gettext(\"Annual\"),\n            2: _gettext(\"Midline and endline\"),\n            5: _gettext(\"Tri-annual\"),\n            4: _gettext(\"Semi-annual\"),\n            7: _gettext(\"Monthly\"),\n            6: _gettext(\"Quarterly\")\n        },\n        timeperiodLabels: {\n            3: _gettext(\"Years\"),\n            5: _gettext(\"Tri-annual periods\"),\n            4: _gettext(\"Semi-annual periods\"),\n            7: _gettext(\"Months\"),\n            6: _gettext(\"Quarters\")\n        }\n    };\n}\n\nexport {getPeriodLabels};\n\nexport const STATUS_CODES = {\n    NO_INDICATOR_IN_UPDATE: 1\n};\n\nexport const IndicatorFilterType = Object.freeze({\n    noFilter: 0,\n    missingTarget: 1,\n    missingResults: 2,\n    missingEvidence: 3,\n\n    aboveTarget: 5,\n    belowTarget: 6,\n    onTarget: 7,\n    nonReporting: 8\n});\n\nexport const RFC_OPTIONS = getGlobal('reason_for_change_options') ?? [];","import React from 'react';\nimport { observer, inject } from 'mobx-react';\nimport { SingleReactSelect, DateSelect, GroupBySelect } from '../../../../components/selectWidgets';\n\n/**\n * input-ready filtering single-select for Programs available to user in IPTT Report\n * uses SingleSelect in js/components/selectWidgets\n */\n\nconst ProgramSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return (\n            <SingleReactSelect\n                label={ gettext('Program') }\n                options={ filterStore.programOptions }\n                value={ filterStore.selectedProgramOption }\n                update={ selected => { filterStore.selectedProgramOption = selected } }\n            />\n        );\n    })\n);\n\n/**\n * input-ready filtering single-select for Frequencies available for selected program in IPTT Report\n * uses SingleSelect in js/components/selectWidgets\n */\n\nconst FrequencySelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return (\n            <SingleReactSelect\n                label={\n                    filterStore.isTVA ?\n                        gettext('Target periods') :\n                        gettext('Time periods')\n                }\n                options={ filterStore.frequencyOptions }\n                disabled={ filterStore.frequencyDisabled }\n                value={ filterStore.selectedFrequencyOption }\n                update={ selected => { filterStore.selectedFrequencyOption = selected; } }\n            />\n        );\n    })\n);\n\n/**\n * Show All radio / Most Recent radio / number of Most Recent periods input combo component\n * For selecting start and end of IPTT report\n * controlled component - logic to update date selects in filterStore model (../models)\n */\n@inject('filterStore')\n@observer\nclass TimeframeRadio extends React.Component {\n    constructor(props) {\n        super(props);\n        this.mostRecentInputRef = React.createRef();\n        this.state = {\n            focus: false,\n            revert: false,\n            mostRecentValue: this.props.filterStore.mostRecentValue\n        };\n    }\n\n    checkMostRecent = (e) => {\n        let mostRecentCount = isNaN(parseInt(this.state.mostRecentValue)) ? 2 : parseInt(this.state.mostRecentValue);\n        this.setState({mostRecentValue: mostRecentCount});\n        this.mostRecentInputRef.current.focus();\n    }\n\n    handleChange = (e) => {\n        const pattern = /^[0-9]+$/;\n        if (pattern.exec(e.target.value) || !e.target.value) {\n            this.setState({mostRecentValue: e.target.value});\n        }\n    }\n\n    handleBlur = (e) => {\n        if (!this.state.revert) {\n            this.props.filterStore.mostRecentValue = this.state.mostRecentValue;\n        }\n        this.setState({focus: false, revert: false, mostRecentValue: this.props.filterStore.mostRecentValue});\n    }\n\n    handleKeyDown = (e) => {\n        if (e.keyCode === 13) {\n            e.target.blur();\n        } else if (e.keyCode === 27) {\n            this.setState({revert: true},\n                () => {this.mostRecentInputRef.current.blur();});\n        }\n    }\n\n    handleFocus = (e) => {\n        this.setState({focus: true, revert: false, mostRecentValue: this.props.filterStore.mostRecentValue});\n    }\n\n    render() {\n        return (\n            <div className=\"form-row mb-3\">\n                <div className=\"col-sm-4\">\n                    <div className=\"form-check form-check-inline pt-1\">\n                        <span className=\"form-check-input\">\n                            <input type=\"radio\"\n                                   checked={ !this.state.focus && this.props.filterStore.showAll }\n                                   disabled={ this.props.filterStore.periodsDisabled }\n                                   onChange={ e => { this.props.filterStore.showAll = true } }\n                                   />\n                        </span>\n                        <label onClick={ e => {this.props.filterStore.showAll = true} }\n                               className=\"form-check-label text-nowrap\">\n                            {\n                                /* # Translators: option to show all periods for the report */\n                                gettext('Show all')\n                            }\n                        </label>\n                    </div>\n                </div>\n                <div className=\"col-sm-4 p-0\">\n                    <div className=\"form-check form-check-inline mr-1 pt-1 float-right\">\n                        <span className=\"form-check-input\">\n                            <input type=\"radio\"\n                                   checked={ this.state.focus || this.props.filterStore.mostRecentChecked }\n                                   disabled={ this.props.filterStore.periodsDisabled }\n                                   onChange={ this.checkMostRecent }\n                                   />\n                        </span>\n                        <label onClick={ this.checkMostRecent }\n                               className=\"form-check-label text-nowrap\">\n                            {\n                                /* # Translators: option to show a number of recent periods for the report */\n                                gettext('Most recent')\n                            }\n                        </label>\n                    </div>\n                </div>\n                <div className=\"col-sm-3\">\n                    <input className=\"form-control pl-3\"\n                           value={ this.state.focus ? this.state.mostRecentValue : this.props.filterStore.mostRecentValue }\n                           ref={ this.mostRecentInputRef }\n                           disabled={ this.props.filterStore.periodsDisabled }\n                           onChange={ this.handleChange }\n                           onFocus={ this.handleFocus }\n                           onBlur={ this.handleBlur }\n                           onKeyDown={ this.handleKeyDown }\n                           />\n                </div>\n           </div>\n        );\n    }\n}\n\n/**\n * non input-ready dropdown for periods available for Start of IPTT Report select\n * composes DateSelect in components/selectWidgets\n */\nconst StartDateSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <DateSelect\n                    label={\n                        /* # Translators: menu for selecting the start date for a report */\n                        gettext('Start')\n                    }\n                    disabled={ filterStore.periodsDisabled }\n                    value={ filterStore.startPeriodValue || '' }\n                    update={ e => {filterStore.startPeriodValue = e.target.value;} }\n                    options={ filterStore.startOptions }\n                />\n    })\n);\n\n/**\n * non input-ready dropdown for periods available for End of IPTT Report select\n * composes DateSelect in components/selectWidgets\n */\nconst EndDateSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <DateSelect\n                    label={\n                        /* # Translators: menu for selecting the end date for a report */\n                        gettext('End')\n                    }\n                    disabled={ filterStore.periodsDisabled }\n                    value={ filterStore.endPeriodValue || '' }\n                    update={ e => {filterStore.endPeriodValue = e.target.value;} }\n                    options={ filterStore.endOptions }\n                />\n    })\n);\n\n/**\n * single select with non dynamic options (dynamic labeling based on program's name for tier 2)\n * selects \"grouping\" or \"chaining\" based display of indicators in report and filter dropdowns\n */\nconst GroupingSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <GroupBySelect\n                    chainLabel={ filterStore.resultChainFilterLabel }\n                    value={ filterStore.groupBy }\n                    update={ e => { filterStore.groupBy = e.target.value;} }\n                />\n    })\n);\n\n\nexport { ProgramSelect, FrequencySelect, TimeframeRadio, StartDateSelect, EndDateSelect, GroupingSelect };\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AAEA;AACA;AACA;AACA;AAJA;AAQA;AACA;AACA;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAWA;;;;AAlBA;AACA;AAoBA;AACA;AACA;AAAA;AACA;AADA;AAEA;AAAA;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAKA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAKA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAKA;AACA;AAIA;AACA;AACA;AACA;AAOA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AARA;AAFA;AACA;AAWA;AAAA;AACA;AADA;AACA;AADA;AAEA;AAAA;AACA;AAAA;AADA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAFA;AAFA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AA3BA;AA4BA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AACA;AADA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AA1DA;AA4DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9JA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAMA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAMA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAlLA;AACA;AAmLA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1MA;AACA;AACA;AACA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAVA;AAUA;AACA;;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AAAA;AAAA;AAAA;AAEA;;;;AA5BA;AACA;AADA;AA+BA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AA/BA;AAiCA;AACA;AACA;AAnCA;AAAA;AACA;AADA;AAAA;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAJA;AAQA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AAAA;AAAA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAJA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AA7EA;AAkFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrFA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AA3BA;AAHA;AACA;AAkCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AAGA;;;;;AAKA;AAAA;AACA;AADA;AACA;AAAA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAQA;AAAA;AAAA;AACA;AACA;AAVA;AAWA;AACA;AACA;AAbA;AAcA;AAAA;AAAA;AACA;AAAA;AACA;AADA;AAIA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAxBA;AACA;AACA;AAFA;AAFA;AAMA;AACA;;;AAmBA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAOA;AAAA;AACA;AAOA;AACA;AACA;AAAA;AACA;AAOA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AAGA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AACA;AASA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAxDA;AA6DA;AAGA;;;;AAnGA;AACA;AAwGA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAIA;AAEA;AACA;AAAA;AAAA;AAFA;AAKA;AACA;AAXA;AAAA;AACA;AADA;AAAA;AAAA;AAaA;AAGA;AACA;AACA;AAHA;AAIA;AAAA;AAEA;AACA;AAKA;AA3BA;AACA;AADA;AAAA;AACA;AA+BA;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAGA;AAAA;AAAA;AAAA;AAEA;AACA;AAKA;;;;AA7BA;AACA;AAgCA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAIA;AAGA;AACA;AARA;AAAA;AACA;AADA;AAAA;AAAA;AAUA;AAEA;AACA;AACA;AAFA;AAGA;AAAA;AAIA;AAnBA;AACA;AADA;AAAA;AAwBA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAEA;AACA;AACA;AACA;AACA;AANA;AAAA;AACA;AADA;AAAA;AAAA;AAQA;AAEA;AACA;AACA;AAFA;AAGA;AAAA;AAIA;AAjBA;AACA;AADA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AADA;AAEA;AAAA;AAIA;AAIA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AADA;AAEA;AAAA;AAIA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAIA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AAGA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAIA;AAEA;AAIA;AALA;AAOA;AACA;AACA;AAFA;AAKA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AA9BA;AAsCA;AAMA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AAgBA;AAAA;AAAA;AACA;AACA;AAlBA;AAoBA;AAAA;AAAA;AACA;AACA;AAtBA;AAwBA;AAAA;AAAA;AACA;AACA;AAxBA;AACA;AADA;AAFA;AAKA;AACA;;;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;AAcA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAFA;AAUA;;;;AA7FA;AAgGA;AACA;AAAA;AACA;AAEA;AACA;AADA;AAMA;AACA;AAEA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAOA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAKA;AACA;AACA;AACA;AAFA;AADA;AASA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpVA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AAEA;AACA;AACA;AAEA;AAAA;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;AAGA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AALA;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AALA;AAUA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAFA;AADA;AAQA;AACA;AAGA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAlBA;AAoBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAHA;AAAA;AAKA;AAAA;AAEA;AAFA;AAAA;AAPA;AACA;AAWA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AANA;AAWA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AALA;AAQA;;;;;;;;;;;;AC9MA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAOA;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAHA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAHA;AAIA;AARA;AAUA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAPA;AASA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAPA;AASA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAPA;AASA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAPA;AASA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAPA;AASA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAPA;AASA;;;;;;;;;;;;;AChIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AALA;AAFA;AACA;AASA;AAAA;AACA;AADA;AACA;AADA;AAGA;AACA;AAAA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAjCA;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAFA;AACA;AAmBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAhBA;AAkBA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AADA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAFA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAlBA;AAoBA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AADA;AAAA;AAEA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AADA;AAGA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAnrBA;AAorBA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAIA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;AC3wBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAtBA;AAFA;AACA;AAyBA;AAAA;AACA;AADA;AACA;AADA;AAGA;AACA;AAAA;AACA;AALA;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAHA;AAIA;AAAA;AAKA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AAFA;AAIA;AACA;AAFA;AAKA;AAEA;AACA;AACA;AACA;AAJA;AADA;AAYA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAFA;AAGA;AACA;AACA;AAFA;AAGA;AAAA;AAGA;AACA;AACA;AAFA;AAGA;AAAA;AAKA;AADA;AAGA;AAHA;AAMA;AACA;AAMA;AACA;AAAA;AACA;AADA;AADA;AAQA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AALA;AASA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AAAA;AACA;AAAA;AAFA;AAOA;AACA;AAEA;AACA;AASA;AACA;AACA;;;;;;;;;;;;AClMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAaA;AACA;AAEA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAIA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AANA;AAUA;AAAA;AAAA;AACA;AACA;AADA;AAEA;AAAA;AAMA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AARA;AAeA;AACA;AAFA;AACA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAHA;AAIA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAGA;AApFA;AAsFA;;;;;;;;;;;;ACxIA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AADA;AAKA;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAKA;AAEA;AACA;AACA;AAHA;AADA;AASA;AACA;AAAA;AAAA;AADA;AAQA;AAGA;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAjBA;AAFA;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClCA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAhBA;AAFA;AACA;AAmBA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAFA;AACA;AAMA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AANA;AAAA;AAQA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAjDA;AAFA;AAsDA;;;;;;;;;;;;ACrGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AAAA;AACA;AACA;AAFA;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAOA;AAAA;AACA;AAAA;AAGA;AAAA;AAKA;AAAA;AAKA;AAIA;;;;;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAJA;AAFA;AACA;AAQA;AAAA;AACA;AADA;AACA;AADA;AAEA;AAAA;AACA;AAAA;AADA;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAlCA;AACA;AAmCA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;AC1DA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAtBA;AAFA;AA0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrCA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAWA;AAEA;AACA;AACA;AACA;AACA;AALA;AASA;AAGA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AALA;AAVA;AAkBA;AACA;AACA;AAEA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AATA;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAOA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAAA;AAAA;AATA;AAYA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AAWA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAfA;AAiBA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAtBA;AAwBA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AA7BA;AA+BA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAtCA;AAwCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAxCA;AACA;AACA;AACA;AACA;AAHA;AAHA;AAQA;AACA;;;AAkCA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAHA;AAMA;AAAA;AAAA;AACA;AADA;AAGA;AACA;AAKA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAMA;AACA;AADA;AAGA;AACA;AAKA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAYA;;;;AAhGA;AAmGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AARA;AAUA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AARA;AAUA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAHA;AAKA;;;;;A","sourceRoot":""}
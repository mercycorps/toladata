{"version":3,"file":"program_page-70b40cbe02f4b3733945.js","sources":["webpack:///./js/pages/program_page/models/programPageProgram.js","webpack:///./js/models/program.js","webpack:///./js/apiv2.js","webpack:///./js/pages/program_page/pinned_reports.js","webpack:///./js/pages/program_page/components/indicator_list.js","webpack:///./js/date_utils.js","webpack:///./js/models/indicator.js","webpack:///./js/models/formattingUtils.js","webpack:///./js/pages/program_page/models/programPageIndicator.js","webpack:///./js/general_utilities.js","webpack:///./js/pages/program_page/index.js","webpack:///./js/pages/program_page/models/programPageUIStore.js","webpack:///./js/components/indicatorModalComponents.js","webpack:///./js/eventbus.js","webpack:///./js/pages/program_page/components/program_metrics.js","webpack:///./js/pages/program_page/models/programPageRootStore.js","webpack:///./js/constants.js","webpack:///./js/pages/program_page/components/resultsTable.js"],"sourcesContent":["import { observable, runInAction, computed, action } from 'mobx';\n\nimport api from '../../../apiv2';\nimport { getProgram, withReportingPeriod, withProgramLevelOrdering } from '../../../models/program';\nimport ProgramPageIndicator from './programPageIndicator';\n\n/**\n *  Program Page specific model constructor\n *  JSON params:\n *      needs_additional_target_periods (boolean)\n *      indicators (ProgramPageIndicator)\n *  @return {Object}\n */\n\nexport const forProgramPage = (\n    programJSON = {}\n) => ({\n        indicators: programJSON.indicators ? new Map(Object.values(programJSON.indicators).map(indicatorJSON => new ProgramPageIndicator(indicatorJSON))\n                            .map(indicator => [indicator.pk, indicator])) : new Map(),\n        needsAdditionalTargetPeriods: Boolean(programJSON.needs_additional_target_periods),\n        _expandedIndicators: new Set(),\n        isExpanded(indicatorPk) {\n            return this._expandedIndicators.has(parseInt(indicatorPk));\n        },\n        expand: action(function(indicatorPk) {\n            this._expandedIndicators.add(parseInt(indicatorPk));\n        }),\n        collapse: action(function(indicatorPk) {\n            this._expandedIndicators.delete(parseInt(indicatorPk))\n        }),\n        expandAll: action(function() {\n            this._expandedIndicators = new Set(this.indicators.keys());\n        }),\n        collapseAll: action(function() {\n            this._expandedIndicators.clear();\n        }),\n        updateIndicator: action(function(rawIndicatorPk) {\n            let indicatorPk = parseInt(rawIndicatorPk);\n            return api.updateProgramPageIndicator(indicatorPk)\n                   .then(results => {\n                        if (results.indicator) {\n                            let indicator = ProgramPageIndicator(results.indicator);\n                            this.indicators.set(indicator.pk, indicator);\n                        }\n                        return results;\n                    }).then(this._applyOrderUpdate.bind(this));\n        }),\n        reloadIndicators: action(function() {\n            return api.updateAllProgramPageIndicators(this.pk).then(results => {\n                this.indicators = new Map((results.indicators || []).map(ProgramPageIndicator)\n                                          .map(indicator => [indicator.pk, indicator]));\n                return results;\n            }).then(this._applyOrderUpdate.bind(this));\n        }),\n        deleteIndicator: action(function(indicatorPk) {\n            return this.updateOrder().then(success => this.indicators.delete(parseInt(indicatorPk)));\n        }),\n        \n    });\n\nexport default getProgram(withReportingPeriod, withProgramLevelOrdering, forProgramPage);","import { observable, action, runInAction, extendObservable } from 'mobx';\nimport api from '../apiv2';\nconst _gettext = (typeof gettext !== 'undefined') ?  gettext : (s) => s;\n\n/**\n *  Base program constructor\n *  JSON params:\n *      pk (string|number)\n *      name (string)\n *      results_framework (boolean)\n *      by_result_chain (string)\n *  @return {Object}\n */\n\nconst bareProgram = (\n    programJSON = {}\n) => ({\n    pk: parseInt(programJSON.pk),\n    name: programJSON.name,\n    resultsFramework: Boolean(programJSON.results_framework),\n    _resultChainFilterLabel: programJSON.by_result_chain || _gettext(\"by Outcome chain\"),\n    get resultChainFilterLabel() {\n        return this.resultsFramework ? this._resultChainFilterLabel : null\n    }\n});\n\nexport const getProgram = (\n    ...programConstructors\n) => ( programJSON = {} ) => [bareProgram, ...programConstructors].reduce(\n        (acc, fn) => extendObservable(acc, fn(programJSON)), {});\n\n/**\n * Extends program with reporting date start/end processing\n * JSON params:\n *      reporting_period_start_iso (string - ISO date format e.g. \"2018-01-14\")\n *      reporting_period_end_iso (string - ISO date format e.g. \"2018-12-02\")\n */\n\nexport const withReportingPeriod = (\n    programJSON = {}\n) => ({\n        reportingPeriodStart: new Date(programJSON.reporting_period_start_iso),\n        reportingPeriodEnd: new Date(programJSON.reporting_period_end_iso)\n    });\n\n/**\n *  Extends program with program-wide indicator ordering (rf-aware)\n *  JSON params:\n *      indicator_pks_level_order ([int])\n *      indicator_pks_chain_order ([int])\n */\n\nexport const withProgramLevelOrdering = (\n    programJSON = {}\n) => {\n    return {\n        _indicatorsLevelOrder: observable((programJSON.indicator_pks_level_order || [])),\n        _indicatorsChainOrder: observable((programJSON.indicator_pks_chain_order || [])),\n        _applyOrderUpdate(results) {\n            runInAction(() => {\n                this._indicatorsLevelOrder = results.indicator_pks_level_order || [];\n                this._indicatorsChainOrder = results.indicator_pks_chain_order || [];\n                Object.entries(results.indicators || {}).forEach(([pk, indicatorJSON]) => {\n                    if (!isNaN(parseInt(pk)) && this.indicators.has(parseInt(pk))) {\n                        this.indicators.get(parseInt(pk)).updateData(indicatorJSON);\n                    }\n                });\n                return results;\n            });\n        },\n        updateOrder() {\n            return api.programLevelOrdering(this.pk).then(this._applyOrderUpdate.bind(this));\n        },\n        get indicatorsInLevelOrder() {\n            return this._indicatorsLevelOrder.map(pk => this.indicators.get(pk));\n        },\n        get indicatorsInChainOrder() {\n            if (this.hasOwnProperty('resultsFramework') && this.resultsFramework === false) {\n                return this.indicatorsInLevelOrder;   \n            }\n            return this._indicatorsChainOrder.map(pk => this.indicators.get(pk));\n        }\n    };\n}\n\n\n/**\n *  Extends program with level-by-level indicator ordering (rf-aware)\n *  JSON params:\n *      level_pks_level_order ([int])\n *      level_pks_chain_order ([int])\n *      indicator_pks_for_level ([{pk: int, indicator_pks; [int]}])\n *      unassigned_indicator_pks ([int])\n */\n\nexport const withRFLevelOrdering = (\n    programJSON = {}\n) => {\n    return {\n        _levelsLevelOrder: observable((programJSON.level_pks_level_order || [])),\n        _levelsChainOrder: observable((programJSON.level_pks_chain_order || [])),\n        _unassignedIndicators: observable((programJSON.unassigned_indicator_pks || [])),\n        levelIndicators: observable(new Map(\n            (programJSON.indicator_pks_for_level || []).map(\n                levelMapJSON => [levelMapJSON.pk, levelMapJSON.indicator_pks]\n            ))),\n        updateOrder() {\n            return api.rfLevelOrdering(this.pk).then(results => {\n                runInAction(() => {\n                    this._levelsLevelOrder = results.level_pks_level_order || [];\n                    this._levelsChainOrder = results.level_pks_chain_order || [];\n                    this._unassignedIndicators = results.unassigned_indicator_pks || [];\n                    this._updateLevelIndicatorsOrder(results.indicator_pks_for_level);\n                    return true;\n                });\n            });\n        },\n        get levelsInLevelOrder() {\n            return this._levelsLevelOrder.map(pk => this.levels.get(pk)) || [];\n        },\n        get levelsInChainOrder() {\n            if (this.hasOwnProperty('resultsFramework') && this.resultsFramework === false) {\n                return this.levelsInLevelOrder;   \n            }\n            return this._levelsChainOrder.map(pk => this.levels.get(pk)) || [];\n        },\n        get unassignedIndicators() {\n            return this._unassignedIndicators.map(pk => this.indicators.get(pk)) || [];\n        },\n        get indicatorsInLevelOrder() {\n            if (!this.resultsFramework) {\n                return this.unassignedIndicators;\n            }\n            return Array.prototype.concat\n                .apply([], this.levelsInLevelOrder\n                                .map(level => this.levelIndicators.get(level.pk).filter(pk => this.indicators.has(pk))\n                                                            .map(pk => this.indicators.get(pk))))\n                .concat(this.unassignedIndicators);\n        },\n        get indicatorsInChainOrder() {\n            if (!this.resultsFramework) {\n                return this.unassignedIndicators;\n            }\n            return Array.prototype.concat\n                .apply([], this.levelsInChainOrder\n                                .map(level => this.levelIndicators.get(level.pk).filter(pk => this.indicators.has(pk))\n                                                            .map(pk => this.indicators.get(pk))))\n                .concat(this.unassignedIndicators);\n        },\n        _updateLevelIndicatorsOrder(orderByLevel=[]) {\n            runInAction(() => {\n                this.levelIndicators.clear();\n                orderByLevel.forEach(({pk, indicator_pks}) => {\n                    this.levelIndicators.set(pk, indicator_pks);\n                });\n            });\n        }\n    };\n}","import axios from 'axios';\nimport qs from 'qs';\n\nconst api = {\n    apiInstance: axios.create({\n        withCredentials: true,\n        baseURL: '/indicators/api/',\n        responseType: 'json',\n        headers: {\n            \"X-CSRFToken\": document.cookie.replace(/(?:(?:^|.*;\\s*)csrftoken\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\")\n        }\n    }),\n    documentInstance: axios.create({\n        withCredentials: true,\n        baseURL: '/indicators/api/',\n        responseType: 'document',\n        headers: {\n            \"X-CSRFToken\": document.cookie.replace(/(?:(?:^|.*;\\s*)csrftoken\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\")\n        },\n        transformResponse: [response => new XMLSerializer().serializeToString(response)]\n    }),\n    formPostInstance: axios.create({\n        withCredentials: true,\n        baseURL: '/indicators/api/',\n        responseType: 'json',\n        headers: {\n            \"X-CSRFToken\": document.cookie.replace(/(?:(?:^|.*;\\s*)csrftoken\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\"),\n            'content-type': 'application/x-www-form-urlencoded'\n        },\n    }),\n    logFailure(failureMsg) {\n        console.log(\"api call failed:\", failureMsg);\n    },\n    getProgramPageUrl(programPk) {\n        return !isNaN(parseInt(programPk)) ? `/program/${programPk}/` : false;\n    },\n    programLevelOrdering(programPk) {\n        return this.apiInstance.get(`/program/ordering/${programPk}/`)\n        .then(response => response.data)\n        .catch(this.logFailure);\n    },\n    rfLevelOrdering(programPk) {\n        return this.apiInstance.get(`/program/level_ordering/${programPk}/`)\n        .then(response => response.data)\n        .catch(this.logFailure);\n    },\n    indicatorResultsTable(indicatorPk, editable) {\n        return this.documentInstance.get(`/result_table/${indicatorPk}/`, {params: {raw: true, edit: editable}})\n            .then(response => response.data)\n            .catch(this.logFailure);\n    },\n    updateProgramPageIndicator(indicatorPk) {\n        return this.apiInstance.get(`/program_page/indicator/${indicatorPk}/`)\n        .then(response => response.data)\n        .catch(this.logFailure);\n    },\n    updateAllProgramPageIndicators(programPk) {\n        return this.apiInstance.get(`/program_page/${programPk}/`)\n        .then(response => response.data)\n        .catch(this.logFailure);\n    },\n    ipttFilterData(programPk) {\n        return this.apiInstance.get(`/iptt/${programPk}/filter_data/`)\n                    .then(response => response.data)\n                    .catch(this.logFailure);\n    },\n    getIPTTReportData({programPk, frequency, reportType} = {}) {\n        return this.apiInstance.get(`/iptt/${programPk}/report_data/`,\n                                    {params: {frequency: frequency, report_type: reportType}})\n                    .then(response => response.data)\n                    .catch(this.logFailure);\n    },\n    savePinnedReport(reportData) {\n        return this.formPostInstance.post(`/pinned_report/`, qs.stringify(reportData))\n                    .catch(this.logFailure);\n    },\n    updateIPTTIndicator(indicatorPk) {\n        return this.apiInstance.get(`/iptt/indicator/${indicatorPk}/`)\n                    .then(response => response.data)\n                    .catch(this.logFailure);\n    }\n    \n};\n\n\nexport default api;","// On pinned report delete btn click\nexport default function setupPinningDelete(deletePinnedReportURL) {\n    function deleteCallback(e) {\n        e.preventDefault();\n        let prId = $(this).data('deletePinnedReport');\n        let pinnedReport = $(this).closest('.pinned-report');\n    \n        if (deletePinnedReportURL &&\n            window.confirm(gettext('Warning: This action cannot be undone. Are you sure you want to delete this pinned report?'))) {\n            $.ajax({\n                type: \"POST\",\n                url: deletePinnedReportURL,\n                data: {\n                    pinned_report_id: prId,\n                },\n                success: function () {\n                    pinnedReport.remove();\n                }\n            });\n        }\n    }\n    $('[data-delete-pinned-report]').click(deleteCallback);\n}\n","import React from 'react';\nimport classNames from 'classnames';\nimport { observer } from \"mobx-react\";\nimport eventBus from '../../../eventbus';\nimport { AddIndicatorButton, ExpandAllButton, CollapseAllButton } from '../../../components/indicatorModalComponents';\nimport ResultsTable from './resultsTable';\nimport { library } from '@fortawesome/fontawesome-svg-core'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faCaretDown, faCaretRight } from '@fortawesome/free-solid-svg-icons'\nimport {IndicatorFilterType} from \"../../../constants\";\nimport Select from 'react-select';\n\n\nlibrary.add(faCaretDown, faCaretRight);\n\n\nfunction getStatusIndicatorString(filterType, indicatorCount) {\n    let fmts;\n    switch (filterType) {\n        case IndicatorFilterType.missingTarget:\n            // # Translators: The number of indicators that do not have targets defined on them\n            fmts = ngettext(\"%s indicator has missing targets\", \"%s indicators have missing targets\", indicatorCount);\n            return interpolate(fmts, [indicatorCount]);\n        case IndicatorFilterType.missingResults:\n            // # Translators: The number of indicators that no one has entered in any results for\n            fmts = ngettext(\"%s indicator has missing results\", \"%s indicators have missing results\", indicatorCount);\n            return interpolate(fmts, [indicatorCount]);\n        case IndicatorFilterType.missingEvidence:\n            // # Translators: The number of indicators that contain results that are not backed up with evidence\n            fmts = ngettext(\"%s indicator has missing evidence\", \"%s indicators have missing evidence\", indicatorCount);\n            return interpolate(fmts, [indicatorCount]);\n        case IndicatorFilterType.aboveTarget:\n            // # Translators: shows what number of indicators are a certain percentage above target. Example: 3 indicators are >15% above target\n            fmts = ngettext(\"%s indicator is >15% above target\", \"%s indicators are >15% above target\", indicatorCount);\n            return interpolate(fmts, [indicatorCount]);\n        case IndicatorFilterType.belowTarget:\n            // # Translators: shows what number of indicators are a certain percentage below target. Example: 3 indicators are >15% below target\n            fmts = ngettext(\"%s indicator is >15% below target\", \"%s indicators are >15% below target\", indicatorCount);\n            return interpolate(fmts, [indicatorCount]);\n        case IndicatorFilterType.onTarget:\n            // # Translators: shows what number of indicators are within a set range of target. Example: 3 indicators are on track\n            fmts = ngettext(\"%s indicator is on track\", \"%s indicators are on track\", indicatorCount);\n            return interpolate(fmts, [indicatorCount]);\n        case IndicatorFilterType.nonReporting:\n            // # Translators: shows what number of indicators that for various reasons are not being reported for program metrics\n            fmts = ngettext(\"%s indicator is unavailable\", \"%s indicators are unavailable\", indicatorCount);\n            return interpolate(fmts, [indicatorCount]);\n\n        default:\n            // # Translators: the number of indicators in a list. Example: 3 indicators\n            fmts = ngettext(\"%s indicator\", \"%s indicators\", indicatorCount);\n            return interpolate(fmts, [indicatorCount]);\n    }\n}\n\n\n\n@observer\nexport class StatusHeader extends React.Component {\n    constructor(props) {\n        super(props);\n        this.onShowAllClick = (e) => {\n            e.preventDefault();\n            eventBus.emit('nav-clear-all-indicator-filters');\n        };\n    }\n\n    render() {\n        const {\n            indicatorCount,\n            programId,\n            currentIndicatorFilter,\n            filterApplied,\n        } = this.props;\n\n        return <div className=\"indicators-list__header\">\n            <h3 className=\"no-bold\">\n                <span id=\"indicators-list-title\">\n                    {getStatusIndicatorString(currentIndicatorFilter, indicatorCount)}\n                </span>\n                {filterApplied &&\n                    <small className=\"ml-2 text-medium-dark text-nowrap\">|\n                        <a className=\"btn btn-sm btn-link btn-inline ml-2\" href=\"#\" id=\"show-all-indicators\" onClick={this.onShowAllClick}>\n                            {\n                                // # Translators: A link that shows all the indicators, some of which are currently filtered from view\n                                gettext('Show all indicators')\n                            }\n                        </a>\n                    </small>\n                }\n            </h3>\n        </div>\n    }\n}\n\n\n@observer\nexport class IndicatorFilter extends React.Component{\n    onIndicatorSelection = (selected) => {\n        let selectedIndicatorId = selected ? selected.value : null;\n\n        if (selectedIndicatorId) {\n            eventBus.emit('nav-select-indicator-to-filter', selectedIndicatorId);\n        }\n    };\n\n    onGroupingSelection = (selected) => {\n        this.props.uiStore.setGroupBy(selected.value);\n    }\n\n    render() {\n\n        const indicatorSelectOptions = this.props.rootStore.allIndicators.map(i => {\n            return {\n                value: i.pk,\n                label: i.name,\n            }\n        });\n\n        const indicatorSelectValue = this.props.uiStore.selectedIndicatorId ? indicatorSelectOptions.find(i => i.value === this.props.uiStore.selectedIndicatorId) : null;\n\n        const indicatorGroupingOptions = this.props.uiStore.groupByOptions;\n        const groupingValue = this.props.uiStore.selectedGroupByOption;\n\n        return <nav className=\"list__filters list__filters--block-label\" id=\"id_div_indicators\">\n            <div className=\"form-group\">\n                <label className=\"\">\n                    {gettext(\"Find an indicator:\")}\n                </label>\n                <div className=\"\">\n                    <Select\n                        options={indicatorSelectOptions}\n                        value={indicatorSelectValue}\n                        isClearable={false}\n                        placeholder={gettext('None')}\n                        onChange={this.onIndicatorSelection}\n                    />\n                </div>\n            </div>\n            {// show Group By only if program is on results framework AND has two levels (filter label is not false)\n                (this.props.uiStore.resultChainFilterLabel) &&\n            <React.Fragment>\n                <div className=\"form-group\">\n                    <label className=\"\">\n                        {gettext(\"Group indicators:\")}\n                    </label>\n                    <div className=\"\">\n                        <Select\n                               options={indicatorGroupingOptions}\n                               value={groupingValue}\n                               isClearable={false}\n                               onChange={this.onGroupingSelection}\n                        />\n                    </div>\n                </div>\n            </React.Fragment>}\n        </nav>;\n    }\n}\n\n\n@observer\nexport class IndicatorListTable extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.onIndicatorUpdateClick = this.onIndicatorUpdateClick.bind(this);\n        this.onIndicatorResultsToggleClick = this.onIndicatorResultsToggleClick.bind(this);\n    }\n\n    onIndicatorUpdateClick(e, indicatorPk) {\n        e.preventDefault();\n\n        eventBus.emit('open-indicator-update-modal', indicatorPk);\n    }\n\n    onIndicatorResultsToggleClick(e, indicatorPk) {\n        e.preventDefault();\n\n        if (this.props.program.isExpanded(indicatorPk)) {\n            this.props.program.collapse(indicatorPk);\n        } else {\n            this.props.program.expand(indicatorPk);\n        }\n    }\n\n    render() {\n        const indicators = this.props.indicators;\n        const program = this.props.program;\n        const editable = !this.props.readOnly;\n        const resultEditable = !this.props.resultReadOnly;\n        return <table className=\"table indicators-list\">\n            <thead>\n            <tr className=\"table-header\">\n                <th className=\"\" id=\"id_indicator_name_col_header\">{gettext(\"Indicator\")}</th>\n                <th className=\"\" id=\"id_indicator_buttons_col_header\">&nbsp;</th>\n                <th className=\"\" id=\"id_indicator_unit_col_header\">{gettext(\"Unit of measure\")}</th>\n                <th className=\"text-right\" id=\"id_indicator_baseline_col_header\">{gettext(\"Baseline\")}</th>\n                <th className=\"text-right\" id=\"id_indicator_target_col_header\">{gettext(\"Target\")}</th>\n            </tr>\n            </thead>\n\n            <tbody>\n            {indicators.map(indicator => {\n                const targetPeriodLastEndDate = indicator.targetPeriodLastEndDate;\n                const localizeFunc = window.localizeNumber;\n                const displayFunc = indicator.isPercent ?\n                        (val) => val ? `${localizeFunc(val)}%` : '' :\n                        (val) => val ? `${localizeFunc(val)}` : '';\n                const numberCellFunc = (val) => {\n                    if (val == '' || isNaN(parseFloat(val))) {\n                        return '';\n                    }\n                    val = parseFloat(val).toFixed(2);\n                    if (val.slice(-2) == \"00\") {\n                        return displayFunc(val.slice(0, -3));\n                    } else if (val.slice(-1) == \"0\") {\n                        return displayFunc(val.slice(0, -1));\n                    }\n                    return displayFunc(val);\n                }\n                const displayUnassignedWarning = indicator.noTargetResults.length > 0 && indicator.periodicTargets.length > 0\n                const displayMissingTargetsWarning = indicator.periodicTargets.length === 0\n                return <React.Fragment key={indicator.pk}>\n                    <tr className={classNames(\"indicators-list__row\", \"indicators-list__indicator-header\", {\n                        \"is-highlighted\": indicator.wasJustCreated,\n                        \"is-expanded\": program.isExpanded(indicator.pk)\n                    })}>\n                        <td>\n                            <a href=\"#\"\n                               className=\"indicator_results_toggle btn text-action text-left\"\n                               tabIndex=\"0\"\n                               onClick={(e) => this.onIndicatorResultsToggleClick(e, indicator.pk)}\n                            >\n                                <FontAwesomeIcon icon={program.isExpanded(indicator.pk) ? 'caret-down' : 'caret-right'} />\n                                <strong>{ indicator.number ? indicator.number + ':' : '' }</strong>&nbsp;\n                                <span className=\"indicator_name\">{ indicator.name }</span>\n                            </a>\n                            {displayUnassignedWarning &&\n                                <span className=\"text-danger ml-3\"><i className=\"fas fa-bullseye\"/> {\n                                    /* # Translators: Warning provided when a result is not longer associated with any target.  It is a warning about state rather than an action.  The full sentence might read \"There are results not assigned to targets\" rather than \"Results have been unassigned from targets. */\n                                    gettext('Results unassigned to targets')\n                                }</span>\n                            }\n                            {displayMissingTargetsWarning &&\n                                <span className=\"text-danger ml-3\"><i className=\"fas fa-bullseye\"/> {\n                                        // # Translators: Warning message displayed when a critical piece of information (targets) have not been created for an indicator.\n                                        gettext('Indicator missing targets')\n                                }</span>\n                            }\n                            {indicator.isKeyPerformanceIndicator &&\n                            <span className=\"badge\">KPI</span>\n                            }\n\n                            {targetPeriodLastEndDate && program.reportingPeriodEnd > targetPeriodLastEndDate &&\n                            <a href={`/indicators/indicator_update/${indicator.pk}/`}\n                               className=\"indicator-link color-red missing_targets\"\n                               data-toggle=\"modal\" data-target=\"#indicator_modal_div\"\n                               data-tab=\"targets\">\n                                <i className=\"fas fa-bullseye\"/> {\n                                    /* # Translators: Adj: labels this indicator as one which is missing one or more targets */\n                                    gettext('Missing targets')\n                                }\n                            </a>\n                            }\n                        </td>\n                        <td>\n                            <a href=\"#\" className=\"indicator-link\"\n                               onClick={(e) => this.onIndicatorUpdateClick(e, indicator.pk)}><i\n                                className=\"fas fa-cog\"/></a>\n                        </td>\n                        <td>{indicator.unitOfMeasure}</td>\n                        <td className=\"text-right\">{ indicator.baseline === null ? gettext('N/A') : numberCellFunc(indicator.baseline) }</td>\n                        <td className=\"text-right\">{ numberCellFunc(indicator.lopTarget) }</td>\n                    </tr>\n\n                    {program.isExpanded(indicator.pk) &&\n                    <tr className=\"indicators-list__row indicators-list__indicator-body\">\n                        <td colSpan=\"6\">\n                            {/* result_table.html container */}\n                                <ResultsTable indicator={ indicator } editable={editable} resultEditable={ resultEditable }/>\n                        </td>\n                    </tr>\n                    }\n                </React.Fragment>\n\n            })}\n            </tbody>\n        </table>\n    }\n}\n\n\nconst IndicatorListTableButtons = observer(function ({program, rootStore, ...props}) {\n    return (\n        <div className=\"indicator-list__buttons-row\">\n            <div className=\"expand-collapse-buttons\">\n                <ExpandAllButton clickHandler={ () => { program.expandAll(); }} disabled={ rootStore.allExpanded } />\n                <CollapseAllButton clickHandler={ () => {program.collapseAll(); }} disabled={ rootStore.allCollapsed } />\n            </div>\n            <div className=\"indicator-list__add-indicator-button\">\n                {!rootStore.readOnly &&\n                <AddIndicatorButton readonly={rootStore.readOnly} programId={program.pk}/>\n                }\n            </div>\n        </div>\n    );\n})\n\n\nconst IndicatorList = observer(function (props) {\n    const program = props.rootStore.program;\n\n    return <React.Fragment>\n        <StatusHeader indicatorCount={props.rootStore.indicators.length }\n                      programId={program.pk}\n                      currentIndicatorFilter={ props.uiStore.currentIndicatorFilter }\n                      filterApplied={ props.uiStore.filterApplied }\n                      />\n        <IndicatorFilter uiStore={props.uiStore} rootStore={props.rootStore} />\n        <IndicatorListTableButtons program={program} rootStore={props.rootStore} />\n\n        {program.needsAdditionalTargetPeriods &&\n            <div id=\"id_missing_targets_msg\" className=\"color-red\">\n                <i className=\"fas fa-bullseye\"/>&nbsp;\n                {gettext('Some indicators have missing targets. To enter these values, click the target icon near the indicator name.')}\n            </div>\n        }\n\n        <IndicatorListTable indicators={props.rootStore.indicators} program={program}\n                                readOnly={ props.rootStore.readOnly }\n                                resultReadOnly={ props.rootStore.resultReadOnly } />\n    </React.Fragment>\n});\n\nexport default IndicatorList;\n","/*\n  Some nice helper functions to help with date parsing and localization\n\n  In the future it may make sense to use moment.js, luxon, or date-fns,\n  but for now, just get by with the native browser APIs and save some bytes.\n\n  Confusingly, native Date() objects are actually date/time objects.\n\n  Surprisingly, the Django i18n/l10n JS tools do not provide access to the language code\n  of the current language in use.\n */\n\nconst languageCode = window.userLang; // set in base.html by Django\n\nconst n = \"numeric\",\n    s = \"short\",\n    l = \"long\",\n    d2 = \"2-digit\";\n\n\nconst DATE_MED = {\n    year: n,\n    month: s,\n    day: n\n};\n\n\n// Returns native Date()\nexport function dateFromISOString(isoDateStr) {\n    return new Date(isoDateStr);  // modern browsers can just parse it\n}\n\n// \"2017-01-01\" -> Date with local timezone (not UTC)\n// also lives in base.js (localDateFromISOStr)\nexport function localDateFromISOString(dateStr) {\n    let dateInts = dateStr.split('-').map(function(x) {return parseInt(x)});\n    return new Date(dateInts[0], dateInts[1]-1, dateInts[2]);\n}\n\n\n\n// Date() -> \"Oct 2, 2018\" (localized)\n// JS equiv of the Django template filter:   |date:\"MEDIUM_DATE_FORMAT\"\nexport function mediumDateFormatStr(date) {\n    return new Intl.DateTimeFormat(languageCode, DATE_MED).format(date);\n}\n","import { observable, computed, extendObservable } from \"mobx\";\nimport { formatDecimal } from './formattingUtils';\nimport { TIME_AWARE_FREQUENCIES } from '../constants';\n\nconst _gettext = (typeof gettext !== 'undefined') ?  gettext : (s) => s;\n\n/**\n *  Base indicator constructor\n *  JSON params:\n *      pk (string|number)\n *      name (string)\n *      level_pk (number)\n *      old_level_name (string)\n *      means_of_verification (string)\n *  @return {Object}\n */\n\nconst bareIndicator = (\n    indicatorJSON = {}\n) => ({\n    pk: parseInt(indicatorJSON.pk),\n    name: indicatorJSON.name,\n    levelPk: !isNaN(parseInt(indicatorJSON.level_pk)) ? parseInt(indicatorJSON.level_pk) : false,\n    oldLevelDisplay: indicatorJSON.old_level_name || false,\n    meansOfVerification: indicatorJSON.means_of_verification || false\n});\n\nexport const getIndicator = (\n    ...indicatorConstructors\n) => (indicatorJSON) => {\n    return [bareIndicator, ...indicatorConstructors].reduce(\n            (acc, fn) => extendObservable(acc, fn(indicatorJSON)), {});\n}\n\n/**\n *  indicator constructor where unit and measurement figures are recorded\n *  JSON params:\n *      unit_of_measure (string)\n *      is_percent (boolean)\n *      is_cumulative (boolean)\n *      direction_of_change (string)\n *      baseline (number)\n *      lop_target (number)\n *  @return {Object}\n */\n\nexport const withMeasurement = (\n    indicatorJSON = {}\n) => ({\n        _formatDecimal: formatDecimal,\n        frequency: parseInt(indicatorJSON.target_frequency),\n        get timeAware() { return TIME_AWARE_FREQUENCIES.includes(this.frequency);},\n        unitOfMeasure: indicatorJSON.unit_of_measure || false,\n        isPercent: Boolean(indicatorJSON.is_percent),\n        isCumulative: Boolean(indicatorJSON.is_cumulative),\n        directionOfChange: indicatorJSON.direction_of_change || false,\n        baseline: indicatorJSON.baseline || null,\n        _lopTarget: indicatorJSON.lop_target || null,\n        _lopActual: indicatorJSON.lop_actual || null,\n        _lopMet: indicatorJSON.lop_met || null,\n        _lopTargetProgress: indicatorJSON.lop_target_progress || null,\n        _lopActualProgress: indicatorJSON.lop_actual_progress || null,\n        _lopMetProgress: indicatorJSON.lop_met_progress || null,\n        get lopTarget() {\n            return this._formatDecimal(this._lopTarget);\n        },\n        get lopActual() {\n            return this._formatDecimal(this._lopActual);\n        },\n        get lopMet() {\n            return this._formatDecimal(this._lopMet);\n        },\n        get lopTargetProgress() {\n            return this._formatDecimal(this._lopTargetProgress);\n        },\n        get lopActualProgress() {\n            return this._formatDecimal(this._lopActualProgress);\n        },\n        get lopMetProgress() {\n            return this._formatDecimal(this._lopMetProgress);\n        },\n    });","/**\n * Formats a decimal number from the received JSON value to a valid JS model value\n * formatting for user language / percent / etc. is next step, this normalizes nulls, strings, etc.\n * to a float if it has a decimal component, and an int otherwise\n */\nexport const formatDecimal = (value) => {\n    if (isNaN(parseFloat(value))) { return false; }\n    value = parseFloat(value);\n    if (Number.isInteger(value)) { return parseInt(value); }\n    return value;\n};","import { observable } from \"mobx\";\nimport { getIndicator, withMeasurement } from '../../../models/indicator';\nimport { formatDecimal } from '../../../models/formattingUtils';\n\nconst programPageResult = (\n    resultJSON = {}\n) => observable({\n    _formatDecimal: formatDecimal,\n    pk: resultJSON.pk,\n    dateCollected: resultJSON.date_collected,\n    _achieved: resultJSON.achieved,\n    evidenceUrl: resultJSON.evidence_url || false,\n    recordName: resultJSON.record_name || false,\n    get achieved() {return this._formatDecimal(this._achieved)}\n})\n\nconst programPageTarget = (\n    targetJSON = {}\n) => observable({\n    _formatDecimal: formatDecimal,\n    periodName: targetJSON.period_name,\n    dateRange: targetJSON.date_range || null,\n    completed: Boolean(targetJSON.completed),\n    mostRecentlyCompleted: Boolean(targetJSON.most_recently_completed),\n    _target: targetJSON.target,\n    _actual: targetJSON.actual,\n    _percentMet: targetJSON.percent_met,\n    results: (targetJSON.results || []).map(resultJSON => programPageResult(resultJSON)),\n    get target() {return this._formatDecimal(this._target)},\n    get actual() {return this._formatDecimal(this._actual)},\n    get percentMet() {return this._formatDecimal(this._percentMet)},\n})\n\n/**\n *  Program Page specific model constructor\n *  JSON params:\n *      number (str)\n *      was_just_created (boolean)\n *      is_key_performance_indicator (boolean)\n *      is_reporting (boolean)\n *      over_under (number)\n *      has_all_targets_defined (boolean)\n *      results_count (number)\n *      has_results (boolean)\n *      results_with_evidence_count (number)\n *      missing_evidence (boolean)\n *  @return {Object}\n */\n\nexport const forProgramPage = (\n    indicatorJSON = {}\n) => ({\n    number: indicatorJSON.number || false,\n    wasJustCreated: Boolean(indicatorJSON.was_just_created),\n    isKeyPerformanceIndicator: Boolean(indicatorJSON.is_key_performance_indicator),\n    isReporting: Boolean(indicatorJSON.is_reporting),\n    hasAllTargetsDefined: Boolean(indicatorJSON.has_all_targets_defined),\n    resultsCount: !isNaN(parseInt(indicatorJSON.results_count)) ? parseInt(indicatorJSON.results_count) : false,\n    hasResults: Boolean(indicatorJSON.has_results),\n    resultsWithEvidenceCount: !isNaN(parseInt(indicatorJSON.results_with_evidence_count)) ?\n                parseInt(indicatorJSON.results_with_evidence_count) : false,\n    missingEvidence: Boolean(indicatorJSON.missing_evidence),\n    mostRecentlyCompletedTargetEndDate: (indicatorJSON.target_frequency &&\n                                         indicatorJSON.most_recent_completed_target_end_date) ?\n                                            new Date(indicatorJSON.most_recent_completed_target_end_date) : null,\n    targetPeriodLastEndDate: (indicatorJSON.target_frequency &&\n                              indicatorJSON.target_period_last_end_date) ?\n                                new Date(indicatorJSON.target_period_last_end_date) : null,\n    _overUnder: !isNaN(parseInt(indicatorJSON.over_under)) ? parseInt(indicatorJSON.over_under) : false,\n    get belowTarget() { return (this.isReporting && this._overUnder !== false && this._overUnder < 0); },\n    get aboveTarget() { return (this.isReporting && this._overUnder !== false && this._overUnder > 0); },\n    get inScope() { return (this.isReporting && this._overUnder !== false && this._overUnder == 0); },\n    reportingPeriod: indicatorJSON.reporting_period || false,\n    periodicTargets: (indicatorJSON.periodic_targets || []).map(targetJSON => programPageTarget(targetJSON)),\n    noTargetResults: (indicatorJSON.no_target_results || []).map(resultJSON => programPageResult(resultJSON)),\n    get noTargets() { return !(this.frequency && this.periodicTargets && this.periodicTargets.length > 0)},\n    updateData(updateJSON) {\n        if (updateJSON.pk && !isNaN(parseInt(updateJSON.pk)) && parseInt(updateJSON.pk) === this.pk) {\n            this.number = updateJSON.number || false;\n        }\n    }\n});\n\nexport default getIndicator(withMeasurement, forProgramPage);","const SPANISH = 'es';\nconst FRENCH = 'fr';\nconst ENGLISH = 'en';\n\nfunction flattenArray(arr, depth = 1) {\n    if (depth == 5) {\n        return arr;\n    }\n    let flattened = [];\n    arr.forEach(item => {\n        if (Array.isArray(item)) {\n            flattened = flattened.concat(flattenArray(item, depth+1));\n        } else {\n            flattened.push(item);\n        }\n    });\n    return flattened;\n}\n\nfunction ensureNumericArray(value) {\n    if (!Array.isArray(value)) {\n        value = parseInt(value);\n        if (value && !isNaN(value)) {\n            return [value];\n        }\n        return false;\n    }\n    let arr = value.map(x => parseInt(x)).filter(x => !isNaN(x));\n    if (arr && Array.isArray(arr) && arr.length > 0) {\n        return arr;\n    }\n    return false;\n}\n\n/*\n * Are we loading a cached page? If so, reload to avoid displaying stale indicator data\n * See ticket #1423\n */\nfunction reloadPageIfCached() {\n    // moving the cache check to after page load as firefox calculates transfer size at the end\n    $(function () {\n        let isCached = window.performance.getEntriesByType(\"navigation\")[0].transferSize === 0;\n        //adding a second check to ensure that if for whatever reason teh transfersize reads wrong, we don't reload on\n        //a reload:\n        let isReload = window.performance.getEntriesByType(\"navigation\")[0].type === \"reload\";\n        if (isCached && !isReload) {\n            window.location.reload();\n        }\n    });\n}\n\nconst indicatorManualNumberSort = (levelFunc, numberFunc) => {\n    return (indicatorA, indicatorB) => {\n        let levelA = levelFunc(indicatorA);\n        let levelB = levelFunc(indicatorB);\n        if (levelA && !levelB) {\n            return 1;\n        }\n        if (levelB && !levelA) {\n            return -1;\n        }\n        if (levelA != levelB) {\n            return parseInt(levelA) - parseInt(levelB);\n        }\n        let numberA = (numberFunc(indicatorA) || '').split('.');\n        let numberB = (numberFunc(indicatorB) || '').split('.');\n        for (let i=0; i < Math.max(numberA.length, numberB.length); i++) {\n            if (numberA[i] && numberB[i]) {\n                for (let j=0; j < Math.max(numberA[i].length, numberB[i].length); j++) {\n                    if (numberA[i][j] && numberB[i][j]) {\n                        if (numberA[i].charCodeAt(j) != numberB[i].charCodeAt(j)) {\n                            return numberA[i].charCodeAt(j) - numberB[i].charCodeAt(j);\n                        }\n                    } else if (numberA[i][j]) {\n                        return 1;\n                    } else if (numberB[i][j]) {\n                        return -1;\n                    }\n                }\n            } else if (numberA[i]) {\n                return 1;\n            } else if (numberB[i]) {\n                return -1;\n            }\n        }\n        return 0;\n    }\n}\n\nconst localizeNumber = (val) => {\n    if (val === undefined || val === null || isNaN(parseFloat(val))) {\n        return null;\n    }\n    var intPart = val.toString();\n    var floatPart = null;\n    if (val.toString().includes(\",\")) {\n        intPart = val.toString().split(\",\")[0];\n        floatPart = val.toString().split(\",\").length > 1 ? val.toString().split(\",\")[1 ] : null;\n    } else if (val.toString().includes(\".\")) {\n        intPart = val.toString().split(\".\")[0];\n        floatPart = val.toString().split(\".\").length > 1 ? val.toString().split(\".\")[1 ] : null;\n    }\n    floatPart = (floatPart && floatPart.length > 0) ? floatPart : null;\n    var displayValue;\n    switch(window.userLang) {\n        case SPANISH:\n            displayValue = intPart.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \".\");\n            if (floatPart) {\n                displayValue += `,${floatPart}`;\n            }\n        break;\n        case FRENCH:\n            displayValue = intPart.replace(/\\B(?=(\\d{3})+(?!\\d))/g, String.fromCharCode(160)); //nbsp\n            if (floatPart) {\n                displayValue += `,${floatPart}`;\n            }\n        break;\n        case ENGLISH:\n        default:\n            displayValue = intPart.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n            if (floatPart) {\n                displayValue += `.${floatPart}`;\n            }\n        break;\n    }\n    return displayValue;\n};\n\nconst localizePercent = (val) => {\n    if (val === undefined || val === null || isNaN(parseFloat(val))) {\n        return null;\n    }\n    let percent = localizeNumber(Math.round(val * 10000)/100);\n    return (percent === null) ? null : `${percent}%`;\n}\n\nconst sortObjectListByValue = (objects, key='label') => objects.sort((a, b) => {\n    return a[key].toUpperCase() > b[key].toUpperCase() ? 1 : -1\n})\n\nexport { flattenArray, ensureNumericArray, reloadPageIfCached, indicatorManualNumberSort,\n          localizeNumber, localizePercent, sortObjectListByValue };\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport eventBus from '../../eventbus';\nimport createRouter from 'router5';\nimport browserPlugin from 'router5-plugin-browser';\n\nimport IndicatorList from './components/indicator_list';\nimport { ProgramMetrics } from './components/program_metrics';\nimport ProgramPageRootStore from './models/programPageRootStore';\nimport { reloadPageIfCached } from '../../general_utilities';\nimport { IndicatorFilterType } from '../../constants';\n\nimport setupPinningDelete from './pinned_reports';\n\nif (reactContext.deletePinnedReportURL) {\n    setupPinningDelete(reactContext.deletePinnedReportURL);\n}\n\n/*\n * Model/Store setup\n */\nconst rootStore = new ProgramPageRootStore(reactContext);\nconst uiStore = rootStore.uiStore;\n\n\n/*\n * Event Handlers\n */\n\n// open indicator update modal with form loaded from server\neventBus.on('open-indicator-update-modal', (indicatorId) => {\n    // Note: depends on indicator_list_modals.html\n\n    let url = `/indicators/indicator_update/${indicatorId}/`;\n\n    $(\"#indicator_modal_content\").empty();\n    $(\"#modalmessages\").empty();\n\n    $(\"#indicator_modal_content\").load(url);\n    $(\"#indicator_modal_div\").modal('show');\n});\n\n// Indicator filters are controlled through routes\n// these should no longer be called directly from components\n\n// apply a gas gauge filter. Takes in IndicatorFilterType enum value\neventBus.on('apply-gauge-tank-filter', indicatorFilter => {\n    // reset all filters\n    eventBus.emit('clear-all-indicator-filters');\n\n    uiStore.setIndicatorFilter(indicatorFilter);\n});\n\n// clear all gas tank and indicator select filters\neventBus.on('clear-all-indicator-filters', () => {\n    uiStore.clearIndicatorFilter();\n    rootStore.program.collapseAll();\n});\n\n// filter down by selecting individual indicator\neventBus.on('select-indicator-to-filter', (selectedIndicatorPk) => {\n    // clear gauge tank filters\n    uiStore.clearIndicatorFilter();\n\n    uiStore.setSelectedIndicatorId(selectedIndicatorPk);\n});\n\n\n/*\n * React components on page\n */\n\nReactDOM.render(<IndicatorList rootStore={rootStore} uiStore={uiStore} />,\n    document.querySelector('#indicator-list-react-component'));\n\nReactDOM.render(<ProgramMetrics rootStore={rootStore} uiStore={uiStore} />,\n    document.querySelector('#program-metrics-react-component'));\n\n\n/*\n * Copied and modified JS from indicator_list_modals.js to allow modals to work\n * without being completely converted to React\n */\n\nfunction openResultsModal(url) {\n    url += \"?modal=1\";\n    $(\"#indicator_modal_content\").empty();\n    $(\"#modalmessages\").empty();\n\n    $(\"#indicator_results_modal_content\").load(url);\n    $(\"#indicator_results_div\").modal('show');\n}\n\n// Open the CollectDataUpdate (update results) form in a modal\n$(\"#indicator-list-react-component\").on(\"click\", \".results__link\", function(e) {\n    e.preventDefault();\n    let url = $(this).attr(\"href\");\n    openResultsModal(url);\n});\n\n$('#indicator_results_div').on('review.tola.results.warning', (e, params) => {\n    let url = params.url;\n    openResultsModal(url);\n})\n\n\n// Open the IndicatorUpdate (Add targets btn in results section (HTML)) Form in a modal\n$(\"#indicator-list-react-component\").on(\"click\", \".indicator-link[data-tab]\", function(e) {\n    e.preventDefault();\n    let url = $(this).attr(\"href\");\n    url += \"?modal=1\";\n    let tab = $(this).data(\"tab\");\n    if (tab && tab != '' && tab != undefined && tab != 'undefined') {\n        url += \"&targetsactive=true\";\n    }\n    $(\"#indicator_modal_content\").empty();\n    $(\"#modalmessages\").empty();\n\n    $(\"#indicator_modal_content\").load(url);\n    $(\"#indicator_modal_div\").modal('show');\n\n});\n\n// when indicator creation modal form completes a save\n$('#indicator_modal_div').on('created.tola.indicator.save', (e, params) => {\n    rootStore.program.updateIndicator(parseInt(params.indicatorId));\n});\n\n// when indicator update modal form completes a save or change to periodic targets\n$('#indicator_modal_div').on('updated.tola.indicator.save', (e, params) => {\n    let indicatorId = parseInt(params.indicatorId);\n\n    rootStore.program.updateIndicator(indicatorId);\n\n});\n\n// when indicator is deleted from modal\n$('#indicator_modal_div').on('deleted.tola.indicator.save', (e, params) => {\n    rootStore.program.deleteIndicator(params.indicatorId);\n});\n\n// When \"add results\" modal is closed, the targets data needs refreshing\n// the indicator itself also needs refreshing for the gas tank gauge\n$('#indicator_results_div').on('save.tola.result_form', function (e) {\n    let indicatorPk = parseInt($(this).find('form #id_indicator').val());\n    rootStore.program.updateIndicator(indicatorPk);\n});\n\n\n\n\n/*\n * Routes setup:\n */\n\nconst routes = [\n    { name: 'all', path: '/', filterType: IndicatorFilterType.noFilter },\n    { name: 'targets', path: '/targets', filterType: IndicatorFilterType.missingTarget },\n    { name: 'results', path: '/results', filterType: IndicatorFilterType.missingResults },\n    { name: 'evidence', path: '/evidence', filterType: IndicatorFilterType.missingEvidence },\n    { name: 'scope', path: '/scope', forwardTo: 'scope.on' },\n    { name: 'scope.on', path: '/on', filterType: IndicatorFilterType.onTarget },\n    { name: 'scope.above', path: '/above', filterType: IndicatorFilterType.aboveTarget },\n    { name: 'scope.below', path: '/below', filterType: IndicatorFilterType.belowTarget },\n    { name: 'scope.nonreporting', path: '/nonreporting', filterType: IndicatorFilterType.nonReporting },\n    { name: 'indicator', path: '/indicator/:indicator_id<\\\\d+>', filterType: IndicatorFilterType.noFilter }\n];\n\nconst router = createRouter(routes, {\n    defaultRoute: 'all', //unrouted: show all indicators\n    defaultParams: {},\n    trailingSlashMode: 'always'\n});\n\nconst onNavigation = (navRoutes) => {\n    let routeName = navRoutes.route.name;\n    let params = navRoutes.route.params;\n\n    if (routeName === 'indicator') {\n        eventBus.emit('select-indicator-to-filter', parseInt(params.indicator_id));\n        return;\n    }\n\n    let routeObj = routes.find(r => r.name === routeName);\n    eventBus.emit('apply-gauge-tank-filter', routeObj.filterType);\n};\nrouter.usePlugin(browserPlugin({useHash: true, base:'/program/'+rootStore.program.pk+'/'}));\nrouter.subscribe(onNavigation);\nrouter.start();\n\n\n// nav events\n\neventBus.on('nav-apply-gauge-tank-filter', indicatorFilter => {\n    // Find route based on filter type and go\n    let routeObj = routes.find(r => r.filterType === indicatorFilter);\n    router.navigate(routeObj.name);\n});\n\neventBus.on('nav-clear-all-indicator-filters', () => {\n    router.navigate('all')\n});\n\neventBus.on('nav-select-indicator-to-filter', (selectedIndicatorId) => {\n    router.navigate('indicator', {'indicator_id': selectedIndicatorId})\n});\n\n\n\nreloadPageIfCached();\n","import { observable, computed, action } from \"mobx\";\n\nexport default class ProgramPageUIStore {\n    @observable currentIndicatorFilter;  // selected gas gauge filter\n    @observable selectedIndicatorId; // indicators filter\n    @observable groupByChain = true;\n\n    constructor(rootStore) {\n        this.setIndicatorFilter = this.setIndicatorFilter.bind(this);\n        this.clearIndicatorFilter = this.clearIndicatorFilter.bind(this);\n        this.setSelectedIndicatorId = this.setSelectedIndicatorId.bind(this);\n        this.rootStore = rootStore;\n    }\n\n    @action\n    setIndicatorFilter(indicatorFilter) {\n        this.currentIndicatorFilter = indicatorFilter;\n    }\n\n    @action\n    clearIndicatorFilter() {\n        this.currentIndicatorFilter = null;\n        this.selectedIndicatorId = null;\n        this.rootStore.program.collapseAll();\n    }\n\n    @action\n    setSelectedIndicatorId(indicatorPk) {\n        this.clearIndicatorFilter();\n        this.selectedIndicatorId = indicatorPk;\n        this.rootStore.program.expand(indicatorPk);\n    }\n    \n    @computed\n    get filterApplied() {\n        return !(!this.currentIndicatorFilter && !this.selectedIndicatorId);\n    }\n    \n    @computed\n    get resultChainFilterLabel() {\n        return this.rootStore.program.resultChainFilterLabel;\n    }\n    \n    @computed\n    get groupByOptions() {\n        return [\n            {\n                value: 1,\n                label: this.resultChainFilterLabel\n            },\n            {\n                value: 2,\n                label: gettext('by Level')\n            }\n        ];\n    }\n    \n    @computed\n    get selectedGroupByOption() {\n        return this.groupByChain ? this.groupByOptions[0] : this.groupByOptions[1];\n    }\n    \n    @action\n    setGroupBy(value) {\n        this.groupByChain = value == 1;\n    }\n\n}","import React from 'react';\nimport { observer } from 'mobx-react';\n\nexport const AddIndicatorButton = observer(({ readonly, ...params }) => {\n    return (\n            <button\n                type=\"button\"\n                disabled={readonly}\n                className=\"btn btn-sm btn-link px-0 btn-add text-nowrap\"\n                onClick={e => {openCreateIndicatorFormModal(params)}}>\n                <i className=\"fas fa-plus-circle\"/> {gettext(\"Add indicator\")}\n            </button>\n    );\n});\n\n\nexport const UpdateIndicatorButton = observer(({ readonly, label=null, ...params }) => {\n    return (\n            <button\n                type=\"button\"\n                disabled={readonly}\n                className=\"btn btn-link\"\n                onClick={e => {openUpdateIndicatorFormModal(params)}}>\n                <i className=\"fas fa-cog\"/>{label}\n            </button>\n    );\n});\n\n\n\nexport const ExpandAllButton = observer(\n    ({clickHandler, disabled}) => {\n        return <button className=\"btn btn-medium text-action btn-sm\"\n                       onClick={ clickHandler }\n                       disabled={ disabled }>\n            <i className=\"fas fa-plus-square\"></i>\n            {\n                /* # Translators: button label to show the details of all rows in a list */}\n            {gettext('Expand all')}\n        </button>\n    }\n);\n\nexport const CollapseAllButton = observer(\n    ({clickHandler, disabled}) => {\n        return <button className=\"btn btn-medium text-action btn-sm\"\n                       onClick={ clickHandler }\n                       disabled={ disabled }>\n            <i className=\"fas fa-minus-square\"></i>\n            {\n                /* # Translators: button label to hide the details of all rows in a list */}\n            {gettext('Collapse all')}\n        </button>\n    }\n);\n","// A global instance of an event bus\nimport nanobus from 'nanobus';\n\nconst globalEventBus = nanobus();\n\nexport default globalEventBus;\n","import React from 'react';\nimport classNames from 'classnames';\nimport { observer } from \"mobx-react\"\nimport eventBus from '../../../eventbus';\nimport {IndicatorFilterType} from \"../../../constants\";\nimport {localDateFromISOString} from \"../../../date_utils\";\n\n\n@observer\nclass GaugeTank extends React.Component {\n\n    handleClick = (e) => {\n        e.preventDefault();\n        if (! this.props.disabled && this.unfilledPercent != 0) {\n            eventBus.emit('nav-apply-gauge-tank-filter', this.props.filterType);\n        }\n    };\n\n    render() {\n        const tickCount = 10;\n\n        const {allIndicatorsLength, filteredIndicatorsLength, title, filledLabel, unfilledLabel, cta, emptyLabel, disabled} = this.props;\n\n        const filterType = this.props.filterType;\n        const currentIndicatorFilter = this.props.currentIndicatorFilter;\n\n        const isHighlighted = filterType === currentIndicatorFilter;\n\n        // Gauge should only show 100%/0% if filtered == all/0 (absolute 100%, not rounding to 100%)\n        // to accomplish this, added a Math.max and Math.min to prevent rounding to absolute values:\n        const unfilledPercent = (allIndicatorsLength <= 0 || allIndicatorsLength == filteredIndicatorsLength) ? 100 :\n            (filteredIndicatorsLength == 0 ? 0 :\n                Math.max(1, Math.min(Math.round((filteredIndicatorsLength / allIndicatorsLength) * 100), 99)));\n        this.unfilledPercent = unfilledPercent;\n        const filledPercent = 100 - unfilledPercent;\n\n        return <div className={classNames('gauge', {'filter-trigger': unfilledPercent > 0 && !disabled, 'is-highlighted': isHighlighted})}\n                    onClick={this.handleClick} >\n            <h6 className=\"gauge__title\">{title}</h6>\n            <div className=\"gauge__overview\">\n                <div\n                    className={`gauge__graphic gauge__graphic--tank ${filledPercent == 0 ? \"gauge__graphic--empty\" : \"\"}`}>\n                    <div className=\"graphic__tick-marks\">\n                        {[...Array(tickCount)].map((e, i) => <div key={i} className=\"graphic__tick\"/>)}\n                    </div>\n                    <div className=\"graphic__tank--unfilled\" style={{'height': `${unfilledPercent}%`}}/>\n                    <div className=\"graphic__tank--filled\" style={{'height': `${filledPercent}%`}}/>\n                </div>\n                <div className=\"gauge__labels\">\n                    {filledPercent > 0 ?\n\n                        <React.Fragment>\n                            <div className=\"gauge__label text-muted\">\n                                {unfilledPercent}% {unfilledLabel}\n                            </div>\n                            <div className=\"gauge__label\">\n                                <span className=\"gauge__value\">{filledPercent}% {filledLabel}</span>\n                            </div>\n                        </React.Fragment>\n\n                        :\n\n                        <div className=\"gauge__label\">\n                            <span className=\"text-danger\"><strong>{emptyLabel}</strong></span>\n                        </div>\n                    }\n                </div>\n            </div>\n            { unfilledPercent > 0 && !disabled &&\n            <div className=\"gauge__cta\">\n                <span className=\"btn-link btn-inline\"><i className=\"fas fa-exclamation-triangle text-warning\"/> {cta}</span>\n                &nbsp;\n            </div>\n            }\n        </div>;\n    }\n}\n\n\n@observer\nclass GaugeBand extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.handledFilterTypes = new Set([\n            IndicatorFilterType.aboveTarget,\n            IndicatorFilterType.belowTarget,\n            IndicatorFilterType.onTarget,\n            IndicatorFilterType.nonReporting\n        ]);\n    }\n\n    onFilterLinkClick = (e, filterType) => {\n        e.preventDefault();\n        eventBus.emit('nav-apply-gauge-tank-filter', filterType);\n    };\n\n    componentDidUpdate() {\n        // Enable popovers after update (they break otherwise)\n        $(this.el).find('[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n\n    render() {\n        const tickCount = 10;\n\n        const { rootStore, currentIndicatorFilter, program } = this.props;\n\n        const isHighlighted = this.handledFilterTypes.has(currentIndicatorFilter);\n\n        const totalIndicatorCount = rootStore.allIndicators.length;\n        const nonReportingCount = rootStore.getIndicatorsNotReporting.length;\n        const highCount = rootStore.getIndicatorsAboveTarget.length;\n        const lowCount = rootStore.getIndicatorsBelowTarget.length;\n        const onTargetCount = rootStore.getIndicatorsOnTarget.length;\n\n        //100 and 0 should only represent absolute \"all\" and \"none\" values respectively (no round to 100 or to 0)\n        const makePercent = totalIndicatorCount > 0 ?\n            (x) => (x == totalIndicatorCount ? 100 :\n                    (x == 0 ? 0 : Math.max(1, Math.min(Math.round((x / totalIndicatorCount) * 100), 99)))) : (x) => 0;\n\n        const percentHigh = makePercent(highCount);\n        const percentOnTarget = makePercent(onTargetCount);\n        const percentBelow = makePercent(lowCount);\n        const percentNonReporting = makePercent(nonReportingCount);\n\n        const marginPercent = this.props.rootStore.onScopeMargin * 100;\n\n        let programPeriodStartDate = program.reportingPeriodStart;\n\n        let gaugeHasErrors = (rootStore.getIndicatorsReporting.length === 0) || (rootStore.getTotalResultsCount === 0);\n\n        // Top level wrapper of component\n        let Gauge = (props) => {\n            return <div className={classNames('gauge', {'is-highlighted': isHighlighted})} ref={el => this.el = el}>\n                <h6 className=\"gauge__title\">{gettext('Indicators on track')}</h6>\n                <div className=\"gauge__overview\">\n                    {props.children}\n                </div>\n            </div>\n        };\n\n        let GaugeLabels = (props) => { // success case\n            return <div className=\"gauge__labels\">\n                <div className=\"gauge__label\">\n                    <span className=\"text-muted filter-trigger--band\"\n                     onClick={ e => this.onFilterLinkClick(e, IndicatorFilterType.nonReporting) }>\n                        {\n                            /* # Translators: variable %s shows what percentage of indicators have no targets reporting data. Example: 31% unavailable */\n                            interpolate(gettext('%(percentNonReporting)s% unavailable'), {percentNonReporting}, true)\n                        }\n                    </span>\n                    {' '}\n                    <a href=\"#\"\n                       tabIndex=\"0\"\n                       data-toggle=\"popover\"\n                       data-placement=\"right\"\n                       data-trigger=\"focus\"\n                       data-content={\n                           /* # Translators: help text for the percentage of indicators with no targets reporting data. */\n                           gettext(\"The indicator has no targets, no completed target periods, or no results reported.\")\n                       }\n                       onClick={e => e.preventDefault()}\n                    ><i className=\"far fa-question-circle\"/></a>\n                </div>\n                <div className=\"gauge__label\">\n                    <span className=\"gauge__value--above filter-trigger--band\"\n                        onClick={ e => this.onFilterLinkClick(e, IndicatorFilterType.aboveTarget) }\n                        dangerouslySetInnerHTML={ aboveTargetMarkup() }>\n                    </span>\n                </div>\n                <div className=\"gauge__label\">\n                    <span className=\"gauge__value filter-trigger--band\"\n                        onClick={ e => this.onFilterLinkClick(e, IndicatorFilterType.onTarget) }\n                        dangerouslySetInnerHTML={ onTargetMarkup() }>\n                    </span>\n                    {' '}\n                    <a href=\"#\"\n                       tabIndex=\"0\"\n                       data-toggle=\"popover\"\n                       data-placement=\"right\"\n                       data-trigger=\"focus\"\n                       data-content={\n                           /* # Translators: Help text explaining what an \"on track\" indicator is. */\n                           gettext(\"The actual value matches the target value, plus or minus 15%. So if your target is 100 and your result is 110, the indicator is 10% above target and on track.  <br><br>Please note that if your indicator has a decreasing direction of change, then “above” and “below” are switched. In that case, if your target is 100 and your result is 200, your indicator is 50% below target and not on track.<br><br><a href='https://docs.google.com/document/d/1Gl9bxJJ6hdhCXeoOCoR1mnVKZa2FlEOhaJcjexiHzY0' target='_blank'>See our documentation for more information.</a>\")\n                       }\n                       onClick={e => e.preventDefault()}\n                    ><i className=\"far fa-question-circle\"/></a>\n                </div>\n                <div className=\"gauge__label\">\n                    <span className=\"gauge__value--below filter-trigger--band\"\n                        onClick={ e => this.onFilterLinkClick(e, IndicatorFilterType.belowTarget) }\n                        dangerouslySetInnerHTML={belowTargetMarkup()}>\n                    </span>\n                </div>\n            </div>\n        }\n\n\n        // Handle strings containing HTML markup\n\n        const aboveTargetMarkup = () => {\n            /* # Translators: variable %(percentHigh)s shows what percentage of indicators are a certain percentage above target percent %(marginPercent)s. Example: 31% are >15% above target */\n            let s = gettext('<strong>%(percentHigh)s%</strong> are >%(marginPercent)s% above target');\n            return {__html: interpolate(s, {percentHigh, marginPercent}, true)};\n        };\n\n        const onTargetMarkup = () => {\n            /* # Translators: variable %s shows what percentage of indicators are within a set range of target. Example: 31%  are on track */\n            let s = gettext('<strong>%s%</strong> are on track');\n            return {__html: interpolate(s, [percentOnTarget])};\n        };\n\n        const belowTargetMarkup = () => {\n            /* # Translators: variable %(percentBelow)s shows what percentage of indicators are a certain percentage below target. The variable %(marginPercent)s is that percentage. Example: 31% are >15% below target */\n            let s = gettext('<strong>%(percentBelow)s%</strong> are >%(marginPercent)s% below target');\n            return {__html: interpolate(s, {percentBelow, marginPercent}, true)};\n        };\n\n\n        return <Gauge>\n            <div className={`gauge__graphic gauge__graphic--performance-band ${gaugeHasErrors ? \"gauge__graphic--empty\" : \"\"}`}>\n                <div className=\"graphic__tick-marks\">\n                    {[...Array(tickCount)].map((e, i) => <div key={i} className=\"graphic__tick\" />)}\n                </div>\n                <div className=\"graphic__performance-band--above-target\"\n                     style={{'height': `${percentHigh}%`}}/>\n                <div className=\"graphic__performance-band--on-target\"\n                     style={{'height': `${percentOnTarget}%`}}/>\n                <div className=\"graphic__performance-band--below-target\"\n                     style={{'height': `${percentBelow}%`}}/>\n            </div>\n            { gaugeHasErrors ?\n                <div className=\"gauge__labels\">\n                    <div className=\"gauge__label\">\n                        {\n                            /* # Translators: message describing why this display does not show any data. # */}\n                        <p className=\"text-muted\">{gettext(\"Unavailable until the first target period ends with results reported.\")}</p>\n                    </div>\n                </div>\n            : <GaugeLabels />}\n        </Gauge>;\n    }\n}\n\n\nexport const ProgramMetrics = observer(function (props) {\n    const program = props.rootStore.program;\n    const indicators = props.rootStore.allIndicators;\n\n    const currentIndicatorFilter = props.uiStore.currentIndicatorFilter;\n\n    const indicatorOnScopeMargin = props.rootStore.indicatorOnScopeMargin;\n\n    // Use objs for labels below to allow for translator notes to be added\n\n    const targetLabels = {\n        /* # Translators: title of a graphic showing indicators with targets */\n        title: gettext(\"Indicators with targets\"),\n\n        /* # Translators: a label in a graphic. Example: 31% have targets */\n        filledLabel: gettext(\"have targets\"),\n\n        /* # Translators: a label in a graphic. Example: 31% no targets */\n        unfilledLabel: gettext(\"no targets\"),\n\n        /* # Translators: a link that displays a filtered list of indicators which are missing targets */\n        cta: gettext(\"Indicators missing targets\"),\n\n        emptyLabel: gettext(\"No targets\"),\n    };\n\n    const resultsLabels = {\n        /* # Translators: title of a graphic showing indicators with results */\n        title: gettext(\"Indicators with results\"),\n\n        /* # Translators: a label in a graphic. Example: 31% have results */\n        filledLabel: gettext(\"have results\"),\n\n        /* # Translators: a label in a graphic. Example: 31% no results */\n        unfilledLabel: gettext(\"no results\"),\n\n        /* # Translators: a link that displays a filtered list of indicators which are missing results */\n        cta: gettext(\"Indicators missing results\"),\n\n        emptyLabel: gettext(\"No results\"),\n    };\n\n    const evidenceLabels = {\n        /* # Translators: title of a graphic showing results with evidence */\n        title: gettext(\"Results with evidence\"),\n\n        /* # Translators: a label in a graphic. Example: 31% have evidence */\n        filledLabel: gettext(\"have evidence\"),\n\n        /* # Translators: a label in a graphic. Example: 31% no evidence */\n        unfilledLabel: gettext(\"no evidence\"),\n\n        /* # Translators: a link that displays a filtered list of indicators which are missing evidence */\n        cta: gettext(\"Indicators missing evidence\"),\n\n        emptyLabel: gettext(\"No evidence\"),\n    };\n\n    // Are some targets defined on any indicators?\n    const someTargetsDefined = indicators.map(i => i.hasAllTargetsDefined).some(b => b);\n    // Do any indicators have results?\n    const someResults = indicators.map(i => i.resultsCount).some(count => count > 0);\n    // Do not display on pages with no indicators\n    if (indicators.length === 0) return null;\n\n    return <div className=\"status__gauges\">\n\n            <GaugeBand currentIndicatorFilter={currentIndicatorFilter}\n                       indicatorOnScopeMargin={indicatorOnScopeMargin}\n                       rootStore={props.rootStore}\n                       program={program}\n            />\n\n            <GaugeTank filterType={IndicatorFilterType.missingTarget}\n                       currentIndicatorFilter={currentIndicatorFilter}\n                       allIndicatorsLength={indicators.length}\n                       filteredIndicatorsLength={props.rootStore.getIndicatorsNeedingTargets.length}\n                       {...targetLabels}\n\n                       />\n\n            <GaugeTank filterType={IndicatorFilterType.missingResults}\n                       currentIndicatorFilter={currentIndicatorFilter}\n\n                       allIndicatorsLength={indicators.length}\n                       filteredIndicatorsLength={props.rootStore.getIndicatorsNeedingResults.length}\n\n                       disabled={! someTargetsDefined}\n\n                       {...resultsLabels}\n\n                       />\n\n            <GaugeTank filterType={IndicatorFilterType.missingEvidence}\n                       currentIndicatorFilter={currentIndicatorFilter}\n                       // The names below are misleading as this gauge is measuring *results*, not indicators\n                       allIndicatorsLength={props.rootStore.getTotalResultsCount}\n                       filteredIndicatorsLength={props.rootStore.getTotalResultsCount - props.rootStore.getTotalResultsWithEvidenceCount}\n\n                       disabled={! someTargetsDefined || ! someResults}\n\n                       {...evidenceLabels}\n                       />\n\n        </div>\n});\n","import { observable, action, computed } from 'mobx';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport getProgramStore from './programPageProgram';\nimport ProgramPageUIStore from './programPageUIStore';\nimport { IndicatorFilterType } from '../../../constants';\n\nexport default class ProgramPageRootStore {\n    @observable program;\n    @observable uiStore;\n\n    constructor(\n        {\n            programJSON = {},\n            onScopeMargin = 0.15,\n            deletePinnedReportURL = null,\n            readOnly = true,\n            resultReadOnly = true,\n        } = {}\n    ) {\n        this.readOnly = readOnly;\n        this.resultReadOnly = resultReadOnly;\n        this.onScopeMargin = onScopeMargin;\n        this.deletePinnedReportURL = deletePinnedReportURL;\n        this.program = getProgramStore(programJSON);\n        this.uiStore = new ProgramPageUIStore(this);\n    }\n\n    @computed\n    get _sortedIndicators() {\n        if (this.program.resultsFramework && this.uiStore.groupByChain) {\n            return this.program.indicatorsInChainOrder;\n        }\n        return this.program.indicatorsInLevelOrder;\n    }\n    \n    @computed\n    get getIndicatorsNeedingTargets() {\n        return this._sortedIndicators.filter(i => !i.hasAllTargetsDefined);\n    }\n    @computed\n    get getIndicatorsNeedingResults() {\n        return this._sortedIndicators.filter(i => !i.hasResults);\n    }\n    @computed\n    get getIndicatorsNeedingEvidence() {\n        return this._sortedIndicators.filter(i => i.missingEvidence);\n    }\n    @computed\n    get getIndicatorsNotReporting() {\n        return this._sortedIndicators.filter(i => !i.isReporting);\n    }\n    @computed\n    get getIndicatorsAboveTarget() {\n        return this._sortedIndicators.filter(i => i.aboveTarget);\n    }\n    @computed\n    get getIndicatorsBelowTarget() {\n        return this._sortedIndicators.filter(i => i.belowTarget);\n    }\n    @computed\n    get getIndicatorsOnTarget() {\n        return this._sortedIndicators.filter(i => i.inScope);\n    }\n    @computed\n    get getIndicatorsReporting() {\n        return this._sortedIndicators.filter(i => i.isReporting);\n    }\n    \n    @computed\n    get getTotalResultsCount() {\n        return this.allIndicators.reduce((acc, i) => acc + i.resultsCount, 0);\n    }\n    \n    @computed\n    get getTotalResultsWithEvidenceCount() {\n        return this.allIndicators.reduce((acc, i) => acc + i.resultsWithEvidenceCount, 0);\n    }\n    \n    @computed\n    get indicators() {\n        return this.filterIndicators(this.uiStore.currentIndicatorFilter, this.uiStore.selectedIndicatorId);\n    }\n\n    @computed\n    get allExpanded() {\n        return this.indicators.every(indicator => this.program.isExpanded(indicator.pk));\n    }\n\n    @computed\n    get allCollapsed() {\n        return this.indicators.every(indicator => !this.program.isExpanded(indicator.pk));\n    }\n    \n    @computed\n    get allIndicators() {\n        return this._sortedIndicators;\n    }\n    \n    filterIndicators(filterType, indicatorPk=null) {\n        let indicators;\n\n        switch (filterType) {\n            case IndicatorFilterType.missingTarget:\n                indicators = this.getIndicatorsNeedingTargets;\n                break;\n            case IndicatorFilterType.missingResults:\n                indicators = this.getIndicatorsNeedingResults;\n                break;\n            case IndicatorFilterType.missingEvidence:\n                indicators = this.getIndicatorsNeedingEvidence;\n                break;\n            case IndicatorFilterType.aboveTarget:\n                indicators = this.getIndicatorsAboveTarget;\n                break;\n            case IndicatorFilterType.belowTarget:\n                indicators = this.getIndicatorsBelowTarget;\n                break;\n            case IndicatorFilterType.onTarget:\n                indicators = this.getIndicatorsOnTarget;\n                break;\n            case IndicatorFilterType.nonReporting:\n                indicators = this.getIndicatorsNotReporting;\n                break;\n            case IndicatorFilterType.noFilter:\n            default:\n                indicators = this._sortedIndicators;\n        }\n        \n        if (indicatorPk && !isNaN(parseInt(indicatorPk))) {\n            indicators = indicators.filter(i => i.pk == parseInt(indicatorPk))\n        }\n        return indicators\n    }\n    \n}","/* Site-wide constants */\n\n\n/**\n * JS_GLOBALS is in base.html (base Tola template) - delivered by middleware from the backend\n * this function returns the global constant for a given key (i.e. 'reason_for_change_options')\n */\n\nfunction getGlobal(key) {\n    if ((typeof JS_GLOBALS !== 'undefined')  && JS_GLOBALS.hasOwnProperty(key)) {\n        return JS_GLOBALS[key];\n    }\n    return null;\n}\n\n\n/**\n * IPTT Constants:\n */\nconst BLANK_LABEL = '---------';\nconst BLANK_OPTION = {\n    value: null,\n    label: BLANK_LABEL\n};\nconst EM_DASH = \"—\";\nconst BLANK_TABLE_CELL = EM_DASH;\n\n\nconst TVA = 1;\nconst TIMEPERIODS = 2;\n\nconst TIME_AWARE_FREQUENCIES = [3, 4, 5, 6, 7];\nconst IRREGULAR_FREQUENCIES = [1, 2];\n\nconst TVA_FREQUENCY_LABELS = Object.freeze(\n    {\n        1: gettext(\"Life of Program (LoP) only\"),\n        2: gettext(\"Midline and endline\"),\n        3: gettext(\"Annual\"),\n        4: gettext(\"Semi-annual\"),\n        5: gettext(\"Tri-annual\"),\n        6: gettext(\"Quarterly\"),\n        7: gettext(\"Monthly\")\n    }\n);\n\nconst TIMEPERIODS_FREQUENCY_LABELS = Object.freeze(\n    {\n        3: gettext(\"Years\"),\n        4: gettext(\"Semi-annual periods\"),\n        5: gettext(\"Tri-annual periods\"),\n        6: gettext(\"Quarters\"),\n        7: gettext(\"Months\")\n    }\n);\n\nexport { BLANK_OPTION, BLANK_LABEL, BLANK_TABLE_CELL, EM_DASH, TVA, TIMEPERIODS, TIME_AWARE_FREQUENCIES,\n         IRREGULAR_FREQUENCIES, TVA_FREQUENCY_LABELS, TIMEPERIODS_FREQUENCY_LABELS };\n\nconst GROUP_BY_CHAIN = 1;\nconst GROUP_BY_LEVEL = 2;\n\nexport { GROUP_BY_CHAIN, GROUP_BY_LEVEL };\n\nconst _gettext = (typeof gettext !== 'undefined') ?  gettext : (s) => s;\n\nfunction getPeriodLabels() {\n    return {\n        targetperiodLabels: {\n            1: _gettext(\"Life of Program (LoP) only\"),\n            3: _gettext(\"Annual\"),\n            2: _gettext(\"Midline and endline\"),\n            5: _gettext(\"Tri-annual\"),\n            4: _gettext(\"Semi-annual\"),\n            7: _gettext(\"Monthly\"),\n            6: _gettext(\"Quarterly\")\n        },\n        timeperiodLabels: {\n            3: _gettext(\"Years\"),\n            5: _gettext(\"Tri-annual periods\"),\n            4: _gettext(\"Semi-annual periods\"),\n            7: _gettext(\"Months\"),\n            6: _gettext(\"Quarters\")\n        }\n    };\n}\n\nexport {getPeriodLabels};\n\nexport const STATUS_CODES = {\n    NO_INDICATOR_IN_UPDATE: 1\n};\n\nexport const IndicatorFilterType = Object.freeze({\n    noFilter: 0,\n    missingTarget: 1,\n    missingResults: 2,\n    missingEvidence: 3,\n\n    aboveTarget: 5,\n    belowTarget: 6,\n    onTarget: 7,\n    nonReporting: 8\n});\n\nexport const RFC_OPTIONS = getGlobal('reason_for_change_options') ?? [];","import React, { useContext } from 'react';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faBullseye, faPlusCircle } from '@fortawesome/free-solid-svg-icons'\nimport { localizeNumber, localizePercent } from '../../../general_utilities';\nimport { EM_DASH } from '../../../constants';\n\n\n// # Translators: short for Not Applicable\nconst N_A = gettext(\"N/A\");\n\n\n/* For passing the localizer function down to the various parts of the results table, we need a context item.\n * Note: this replaces the <provider>/@inject methods from mobx-react with a less-opinionated context.\n * Default value (just localizenumber, no percent) is only used for testing (when no Provider) exists.\n * Docs: https://reactjs.org/docs/context.html\n */\nconst LocalizerContext = React.createContext(localizeNumber);\n\n\n/*\n * Creates a <span class=\"badge\">xx%</span> component that when clicked pops up help text\n * using bootstraps popover library\n */\nclass ProgressPopover extends React.Component {\n    componentDidMount() {\n        // Enable popovers after mount (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n    render() {\n        const percent = localizePercent(this.props.val);\n        var badgeClass, onTrackMsg, msg;\n\n        msg = interpolate(\n            // # Translators: Explains how performance is categorized as close to the target or not close to the target\n            gettext(\"<p><strong>The actual value is %(percent)s of the target value.</strong> An indicator is on track if the result is no less than 85% of the target and no more than 115% of the target.</p><p><em>Remember to consider your direction of change when thinking about whether the indicator is on track.</em></p>\"),\n            {percent: percent}, true);\n\n        if (percent && this.props.val > 0.85 && this.props.val < 1.15) {\n            badgeClass = \"badge-success-light\";\n            // # Translators: Label for an indicator that is within a target range\n            onTrackMsg = gettext(\"On track\");\n        } else {\n            badgeClass = \"badge-warning-light\";\n            // # Translators: Label for an indicator that is above or below the target value\n            onTrackMsg = gettext(\"Not on track\");\n        }\n        const content = `<h4 class=\"badge ${badgeClass}\">${onTrackMsg}</h4>${msg}`;\n        return (\n            <strong>\n                <span tabIndex=\"0\" className={`badge ${badgeClass}`} data-toggle=\"popover\"\n                    data-placement=\"right\" data-trigger=\"focus\" data-content={content}>\n                    {percent}\n                </span>\n            </strong>\n        )\n    }\n}\n\n/**\n * the cells in the results table containing result date, value, and evidence link, with formatting\n */\nconst ResultCells = ({ result, noTarget, ...props }) => {\n    const localizer = useContext(LocalizerContext);\n    let noTargetsClass = noTarget ? \" bg-danger-lighter\" : \"\";\n    return (\n        <React.Fragment>\n            <td className={`results__result--date ${noTargetsClass}`} >\n                <a href={`/indicators/result_update/${ result.pk }/`} className=\"results__link\">\n                    { result.dateCollected }\n                </a>\n            </td>\n            <td className={`results__result--value ${noTargetsClass}`}>\n                { localizer(result.achieved) }\n            </td>\n            <td className=\"td--stretch results__result--url\">\n                {result.evidenceUrl &&\n                    <a href={ result.evidenceUrl } target=\"_blank\">{ result.recordName || result.evidenceUrl }</a>\n                }\n            </td>\n        </React.Fragment>\n    );\n}\n\n/**\n * row(s) in the results table\n *  - one instance per target period\n *  - includes supplemental result rows if more than one result for this target period\n *  - includes progress summation row if this target period is the most recently completed one\n */\nconst TargetPeriodRows = ({target, indicator, ...props}) => {\n    const localizer = useContext(LocalizerContext);\n    let rowspan = target.results.length || 1;\n    return (\n        <React.Fragment>\n            {/* First row has target period info, and first result (if there is a first result)\n              * rowSpan property on target period info cells so they are the height of all associated result rows\n              **/}\n            <tr className={(indicator.timeAware && target.completed) ? \"results__row--main pt-ended\" : \"results__row--main\"} >\n                <td rowSpan={ rowspan } className=\"results__row__target-period\">\n                    <div>\n                        <strong className=\"text-uppercase\">{target.periodName}</strong>\n                    </div>\n                    {target.dateRange &&\n                        <div className=\"text-nowrap\">\n                            <small>{target.dateRange}</small>\n                        </div>\n                    }\n                </td>\n                <td rowSpan={ rowspan } className=\"text-right\">\n                    { localizer(target.target) || EM_DASH }\n                </td>\n                <td rowSpan={ rowspan } className=\"text-right\">\n                    { localizer(target.actual) || EM_DASH }\n                </td>\n                <td rowSpan={ rowspan } className=\"text-right td--pad\">\n                {(target.percentMet && target.completed) ?\n                    <ProgressPopover val={ target.percentMet } /> :\n                    <span className=\"badge\">{ localizePercent(target.percentMet) || N_A }</span>\n                }\n                </td>\n                {(target.results && target.results.length > 0) ?\n                    <ResultCells result={ target.results[0] } noTarget={ false }/> :\n                    <React.Fragment>\n                        <td className=\"results__result--nodata\" colSpan=\"2\">\n                        {\n                            // # Translators: Shown in a results cell when there are no results to display\n                            gettext(\"No results reported\")\n                        }\n                        </td>\n                        <td></td>\n                    </React.Fragment>\n                }\n\n            </tr>\n            {/* If there are multiple results, add \"supplemental\" rows - target period cells are rowspan'd to\n              * fill this row also, so just add the result cells for the 2nd->nth results\n              **/}\n            {target.results.length > 1 && target.results.slice(1).map((result, idx) => (\n                <tr key={idx} className={(indicator.timeAware && target.completed) ? \"results__row--supplemental pt-ended\" : \"results__row--supplemental\"} >\n                    <ResultCells result={ result } noTarget={ false } />\n                </tr>\n            ))}\n            {/* If this was the \"most recently completed\" target period, add a progress row\n              * Note: rules for what period is considered \"most recently completed\" to show progress row in\n              * only the correct (time-aware, program not completed, etc.) situations all done at the back-end\n              * (in the program page indicator serializer)\n              * */}\n            {target.mostRecentlyCompleted &&\n                <tr className=\"results__row--subtotal\">\n                    <td>\n                        <div><em><strong>{\n                            // # Translators: Label for a row showing totals from program start until today\n                            gettext(\"Program to date\")\n                        }</strong></em></div>\n                        <div className=\"text-nowrap\"><small>{ indicator.reportingPeriod }</small></div>\n                    </td>\n                    <td className=\"text-right\"><strong>\n                        { localizer(indicator.lopTargetProgress) || EM_DASH }\n                    </strong></td>\n                    <td className=\"text-right\"><strong>\n                        { localizer(indicator.lopActualProgress) || EM_DASH }\n                    </strong></td>\n                    <td className=\"text-right\">{indicator.lopMetProgress ?\n                        <ProgressPopover val={indicator.lopMetProgress} /> :\n                        <span className=\"badge\">{ N_A }</span>\n                    }</td>\n                    <td colSpan=\"3\" className=\"bg-medium\"></td>\n                </tr>\n            }\n        </React.Fragment>\n    )\n}\n\n/*\n * Row for orphaned results - target period cells are blank, Result cells render with a warning background\n *  - noTarget={true} produces the warning background\n */\nconst NoTargetResultRow = ({result, ...props}) => {\n    return (\n        <tr>\n            <td></td>\n            <td></td>\n            <td></td>\n            <td></td>\n            <ResultCells result={ result } noTarget={ true }/>\n        </tr>\n    );\n}\n\n\n/*\n *  Summative row at the bottom of a results table.  Always shown if table is shown, even if all cells are blank\n *  Contains a message (stretched across result/evidence columns) explaining summation rules\n */\nconst LoPRow = ({indicator, ...props}) => {\n    const localizer = useContext(LocalizerContext);\n    var lopMessage;\n    if (indicator.noTargets) {\n        // if no targets, don't explain summing, it competes with the \"add targets\" messaging\n        lopMessage = \"\";\n    }\n    else if (indicator.isPercent || indicator.isCumulative) {\n        // # Translators: explanation of the summing rules for the totals row on a list of results\n        lopMessage = gettext(\"Results are cumulative. The Life of Program result mirrors the latest period result.\");\n    } else {\n        // # Translators: explanation of the summing rules for the totals row on a list of results\n        lopMessage = gettext(\"Results are non-cumulative. The Life of Program result is the sum of target period results.\");\n    }\n    return (\n        <tr className=\"bg-white\">\n            <td><strong>{\n                // # Translators: identifies a results row as summative for the entire life of the program\n                gettext('Life of Program')\n                }</strong></td>\n            <td className=\"text-right\"><strong>{ localizer(indicator.lopTarget) || EM_DASH }</strong></td>\n            <td className=\"text-right\"><strong>{ localizer(indicator.lopActual) || EM_DASH }</strong></td>\n            <td className=\"text-right\"><span className=\"badge\">{ localizePercent(indicator.lopMet) || N_A }</span></td>\n            <td colSpan=\"3\"><div className=\"help-text\">{ lopMessage }</div></td>\n        </tr>\n    )\n}\n\n/*\n * Table section of the results table (rows are results)\n *  - Header (column headers)\n *  - Periodic Target row(s) for each target period provided (not shown if no targets assigned)\n *      - this includes supplemental rows for multiple results on one target period\n *      - this includes the \"progress row\" after the most recently completed period if applicable\n *  - Summative \"LoP\" row for life of program totals\n */\nconst ResultsTableTable = ({indicator, editable, ...props}) => {\n    const localizer = (val) => {\n        let localized = localizeNumber(val);\n        if (localized && indicator.isPercent) {\n            return `${localized}%`;\n        }\n        return localized;\n    }\n    return (\n        <LocalizerContext.Provider value={ localizer }>\n            <table className=\"table results-table\">\n                <thead>\n                    <tr className=\"table-header\">\n                        <th>{\n                            // # Translators: Header for a column listing periods in which results are grouped\n                            gettext('Target period')\n                        }</th>\n                        <th className=\"text-right\">{\n                            // # Translators: Header for a column listing values defined as targets for each row\n                            gettext('Target')\n                        }</th>\n                        <th className=\"text-right\">{\n                            // # Translators: Header for a column listing actual result values for each row\n                            pgettext('table (short) header', 'Actual')\n                        }</th>\n                        <th className=\"td--pad text-right\">{\n                            // # Translators: Header for a column listing the progress towards the target value\n                            gettext('% Met')\n                        }</th>\n                        <th colSpan=\"2\">{\n                            // # Translators: Header for a column listing actual results for a given period\n                            gettext('Results')\n                        }</th>\n                        <th className=\"td--stretch\">{\n                            // # Translators: Header for a column listing supporting documents for results\n                            gettext('Evidence')\n                        }</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    {indicator.periodicTargets.map((periodicTarget, idx) => <TargetPeriodRows key={`targetrow-${idx}`} target={periodicTarget} indicator={indicator} />)}\n                    {indicator.noTargetResults.map((result, idx) => <NoTargetResultRow key={`notarget-${idx}`} result={ result } />)}\n                    <LoPRow indicator={indicator} />\n                </tbody>\n            </table>\n        </LocalizerContext.Provider>\n    );\n}\n\n/*\n *  Actions/Messages section under the results table (shows even if no table is displayed)\n *      Actions:\n *          - add targets button (shown if targets are not set up && \"editable\" is true (permissions to edit))\n *          - add result button (shown if editable is true, disabled if targets are not set up)\n *      Messages:\n *          - \"This indicator has no targets\" - shown if true\n */\nconst ResultsTableActions = ({indicator, editable, resultEditable, ...props}) => {\n    return (\n        <div className=\"results-table__actions\">\n            <div className=\"cd-actions__message\">\n            {indicator.noTargets &&\n                <div className=\"text-danger\">\n\n                    { editable &&\n                        <a href={`/indicators/indicator_update/${indicator.pk}/`}\n                           data-tab=\"#targets\" className=\"indicator-link btn btn-success\">\n                           <FontAwesomeIcon icon={ faPlusCircle } />\n                           {\n                                // # Translators: Button label which opens a form to add targets to a given indicator\n                                gettext('Add targets')\n                           }\n                        </a>\n                    }\n                </div>\n            }\n            </div>\n            {resultEditable &&\n                <div className={indicator.noTargets ? \"cd-actions__button disable-span\" : \"cd-actions__button\"}>\n                    <a href={`/indicators/result_add/${indicator.pk}/`}\n                        className=\"btn-link btn-add results__link\">\n                        <FontAwesomeIcon icon={ faPlusCircle } />\n                        {\n                            // # Translators: a button that lets the user add a new result\n                            gettext('Add result')\n                        }\n                    </a>\n                </div>\n            }\n        </div>\n    );\n}\n\n\n/*\n * Results table consists of a table with rows for each target period, and an \"Actions/messages\" section below\n *  Table only shows if there are targets and/or results (an indicator with no targets and no results recorded\n *  only gets the \"actions\" section)\n */\nexport default class ResultsTable extends React.Component {\n    render() {\n        let showTable = (!this.props.indicator.noTargets || this.props.indicator.noTargetResults.length > 0);\n        return (\n            <div className=\"results-table__wrapper\">\n                {showTable &&\n                    <ResultsTableTable indicator={this.props.indicator} editable={this.props.editable} />\n                }\n                <ResultsTableActions indicator={this.props.indicator} editable={this.props.editable}\n                    resultEditable={ this.props.resultEditable } />\n            </div>\n        );\n    }\n}\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAxCA;AAFA;AA8CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AARA;AAFA;AACA;AAWA;AAAA;AACA;AADA;AACA;AADA;AAEA;AAAA;AACA;AAAA;AADA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAFA;AAFA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AA3BA;AA4BA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AACA;AADA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AA1DA;AA4DA;;;;;;;;;;;;AC9JA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAJA;AAQA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AAAA;AAAA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAJA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AA7EA;AAkFA;;;;;;;;;;;;ACrFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AARA;AAUA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjCA;AAmCA;AACA;AAIA;AAAA;AACA;AADA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AANA;AAMA;AACA;AARA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAOA;AAlCA;AACA;AADA;AAAA;AAuCA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AAZA;AAAA;AACA;AADA;AAAA;AAAA;AAaA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AALA;AAUA;AAEA;AAAA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AAUA;AA5DA;AACA;AADA;AAAA;AAiEA;AAAA;AACA;AADA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AAJA;AAKA;AACA;AAPA;AAAA;AAAA;AASA;AAEA;AACA;AAZA;AAAA;AAAA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;AAAA;AAAA;AAwBA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAFA;AAAA;AAKA;AACA;AACA;AACA;AAAA;AAAA;AAHA;AAKA;AAAA;AAEA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AAAA;AAAA;AAAA;AAEA;AAIA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AAHA;AAIA;AAAA;AACA;AACA;AAMA;AAAA;AACA;AAAA;AAAA;AADA;AAEA;AADA;AAIA;AAAA;AACA;AAAA;AAIA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAMA;AAGA;AA/HA;AACA;AADA;AAAA;AAmIA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAKA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAKA;AAAA;AACA;AACA;AAFA;AAIA;AAEA;;;;;;;;;;;;AC/UA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AAHA;AACA;AAOA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AALA;AAFA;AACA;AASA;AAAA;AACA;AADA;AACA;AADA;AAGA;AACA;AAAA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAjCA;AAFA;;;;;;;;;;;;AC9CA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AARA;AAFA;AACA;AAWA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAbA;AAFA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AA7BA;AAFA;AAkCA;;;;;;;;;;;;ACnFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAnBA;AACA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAFA;AACA;;;;;;;;;;;;;ACzIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjNA;AAEA;AACA;AACA;AAGA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAgCA;AACA;AACA;;;AA/BA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;;;AAGA;AACA;AACA;;;;AAzDA;;;;;AACA;;;;;AACA;;;;;AAAA;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;ACdA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAKA;AAAA;AAGA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAKA;AAAA;AAGA;AAIA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AAGA;AAAA;AAKA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AAGA;AAAA;AAKA;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AAEA;AAGA;AACA;AAAA;AAGA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAEA;AAAA;AACA;AAAA;AAEA;AADA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAIA;AAAA;AAGA;AAAA;AACA;AAAA;AAMA;AAAA;AACA;AAAA;AAMA;AAAA;AACA;AAAA;AAAA;AAAA;AAKA;;;;AAlEA;AACA;AAsEA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AAYA;AACA;AACA;AACA;AAZA;AAHA;AASA;AACA;;;AAMA;AACA;AACA;AACA;AADA;AAGA;;;AAGA;AAAA;AACA;AAAA;AADA;AAAA;AAAA;AAAA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AATA;AAUA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAFA;AAKA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AATA;AAUA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAFA;AAMA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AADA;AAEA;AACA;AAAA;AAAA;AADA;AAEA;AACA;AAAA;AAAA;AADA;AAIA;AAAA;AACA;AAAA;AAGA;AAAA;AAKA;;;;AApKA;AACA;AAuKA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAbA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAbA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAbA;AACA;AAgBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AAHA;AAQA;AACA;AAEA;AACA;AAEA;AANA;AAYA;AACA;AADA;AAGA;AACA;AAEA;AANA;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjWA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAwEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAxBA;AACA;AA0BA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;AAxGA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAGA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAGA;AACA;AAAA;AAAA;AACA;;;AAGA;AACA;AAAA;AAAA;AACA;;;AAGA;AACA;AACA;;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;AAGA;AACA;AACA;;;;AAzFA;;;;;AACA;;;;;AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAWA;AAEA;AACA;AACA;AACA;AACA;AALA;AASA;AAGA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AALA;AAVA;AAkBA;AACA;AACA;AAEA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AATA;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AADA;AAGA;;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AADA;AAMA;;;;AAnCA;AAsCA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AAGA;AAAA;AAEA;AAAA;AAAA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAKA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAGA;AAAA;AAKA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAIA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AAWA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAWA;AAAA;AAIA;AAEA;AAAA;AAEA;AAAA;AAGA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AACA;AAAA;AAMA;AAAA;AAAA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAGA;AAEA;AAAA;AAEA;AAEA;AAAA;AAEA;AAEA;AAAA;AAEA;AAEA;AAAA;AAEA;AAEA;AAAA;AAEA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AAAA;AADA;AAEA;AAAA;AAGA;AAQA;AAAA;AACA;AACA;AADA;AAEA;AAAA;AAGA;AAOA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AACA;AADA;AAIA;;;;AAZA;AACA;;;;;A","sourceRoot":""}
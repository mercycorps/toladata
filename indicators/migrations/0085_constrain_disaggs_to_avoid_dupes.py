# Generated by Django 2.2.9 on 2020-02-13 18:10

from django.db import migrations
from django.db.models import Count, Q
import logging

logger = logging.getLogger('django')


def remove_duplicate_types_and_labels(apps, schema_editor):
    logger.error("Starting disagg de-duplication migration that will precede application of database constraints.")
    DType = apps.get_model("indicators", "DisaggregationType")
    DLabel = apps.get_model("indicators", "DisaggregationLabel")
    DValue = apps.get_model("indicators", "DisaggregatedValue")

    duplicated_types = DType.objects \
        .values('disaggregation_type', 'country')\
        .annotate(disagg_count=Count('pk'))\
        .distinct()\
        .filter(disagg_count__gt=1)

    for dtype in duplicated_types:
        dupe_group = DType.objects\
            .filter(disaggregation_type=dtype['disaggregation_type'], country__id=dtype['country'])\
            .annotate(num_indicators=Count('indicator', distinct=True))\
            .annotate(num_values=Count(
                'disaggregationlabel__disaggregatedvalue',
                filter=Q(disaggregationlabel__disaggregatedvalue__value__isnull=False),
                distict=True))\
            .order_by('-num_values', '-num_indicators')

        type_to_keep = dupe_group[0]
        types_to_delete = dupe_group[1:]

        if sum([doomed_type.num_values for doomed_type in types_to_delete]) > 0:
            raise NotImplementedError(
                """
                "There are duplicate disaggregation types and more than one has values associated with it.
                Please eliminate duplicated disaggregation types manually and rerun migrations.
                """
            )

        logger.error(f"Preserving disaggregation type \"{type_to_keep.disaggregation_type}\"({type_to_keep.id})")
        for doomed_type in types_to_delete:
            deleted_text = f"Deleted the \"{doomed_type.disaggregation_type}\"({doomed_type.id}) disaggregation type"
            doomed_type.delete()
            logger.error(deleted_text)

    duplicated_labels = DLabel.objects \
        .values("label", "disaggregation_type") \
        .annotate(label_count=Count("pk")) \
        .distinct() \
        .filter(label_count__gt=1) \
        .order_by("label")

    for dlabel in duplicated_labels:
        dupe_group = DLabel.objects \
            .filter(label=dlabel["label"], disaggregation_type__id=dlabel["disaggregation_type"]) \
            .annotate(num_values=Count(
                "disaggregatedvalue__value",
                filter=Q(disaggregatedvalue__value__isnull=False),
                distict=True)) \
            .order_by("-num_values", "id")

        label_to_keep = dupe_group[0]
        labels_to_delete = dupe_group[1:]

        logger.error(f"Preserving disaggregation label \"{label_to_keep.label}\"({label_to_keep.id})")
        for doomed_label in labels_to_delete:
            if doomed_label.num_values > 0:
                for doomed_value in DValue.objects.filter(category=doomed_label, value__isnull=False):

                    preserved_value, was_created = DValue.objects.get_or_create(
                        result=doomed_value.result, category=label_to_keep, defaults={"value": 0}
                    )
                    logger.error("Adding value of {} from dupe Disagg Value({}) to preserverd value({}) of {}".format(
                        doomed_value.value, doomed_value.id, preserved_value.id, preserved_value.value))
                    preserved_value.value += doomed_value.value
                    logger.error(f"New preserved value = {preserved_value.value}")
                    preserved_value.save()

            deleted_text = f"Deleted the \"{doomed_label.label}\"({doomed_label.id}) disaggregation label."
            doomed_label.delete()
            logger.error(deleted_text)
    logger.error("End of disagg de-duplication data migration.")


class Migration(migrations.Migration):

    """
    Django automatically created a workflow dependency on 0057, however this causes an error when running migrations
    on an empty database (as Travis does).  The error occurs because workflow 0053 deletes Project modules that early
    indicator migrations need in order to run.  Setting the dependency to 0052 causes the migration engine to
    run workflow migrations up to 0052, then switch to indicator migrations, then go back to workflow migrations.
    This pattern allows all migrations to be run on an empty DB.
    """
    dependencies = [
        ("workflow", "0052_delete_tolasites"),
        ("indicators", "0084_update_verbose_result_sites_name"),
    ]

    operations = [
        migrations.RunPython(remove_duplicate_types_and_labels, None),

        migrations.AlterUniqueTogether(
            name="disaggregationlabel",
            unique_together={("disaggregation_type", "label")},
        ),
        migrations.AlterUniqueTogether(
            name="disaggregationtype",
            unique_together={("disaggregation_type", "country")},
        ),
    ]

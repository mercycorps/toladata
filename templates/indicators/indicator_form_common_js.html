{% load i18n %}

<script>
    /*
     * Global state for indicator form
     *
     * These values are single instance and not re-created on each
     * form load. As such, they need to be reset when the form is reset
     *
     */

    let validation_msgs = {};
    let initialTrackedFieldsFormState;
    let initialLevelFormValue;  // level field is tracked independent of initialTrackedFieldsFormState
    // this variable is set to TRUE meaning by default any modal that attempts to close can close
    // in the Indicator Form Open function it is set to false to allow validation to proceed normally
    let allowModalToClose = true;  // Can the create modal be closed without prompting the user?

    const DELETE_ALL_TARGETS_MESSAGE = "{% trans 'Any results assigned to these targets will need to be reassigned. For future reference, please provide a reason for deleting these targets.' %}"
    const DELETE_INDICATOR_MESSAGE = "{% trans 'All details about this indicator and results recorded to the indicator will be permanently removed. For future reference, please provide a reason for deleting this indicator.' %}"
    const MODIFY_TARGETS_MESSAGE = "{% trans 'Modifying target values will affect program metrics for this indicator. For future reference, please provide a reason for modifying target values.' %}"
    const DESTRUCTIVE_PREAMBLE = "{% trans 'This action cannot be undone.' %}"
    const DELETE_INDICATOR_PREAMBLE = "{% trans 'All details about this indicator will be permanently removed.' %}"
    const DELETE_INDICATOR_NO_RATIONALE = "{% trans 'Are you sure you want to delete this indicator?' %}"
    const DELETE_TARGETS_NO_RATIONALE = "{% trans 'Are you sure you want to remove all targets?' %}"
    const DELETE_TARGET_NO_RATIONALE = "{% trans 'Are you sure you want to remove this target?' %}"
    const DELETE_TARGET_MESSAGE = "{% trans 'For future reference, please provide a reason for deleting this target.' %}"

    const CLOSE_BEFORE_SAVING_WARNING_PREAMBLE = "{% trans 'This indicator is missing required details and cannot be saved.' %}";
    const CLOSE_BEFORE_SAVING_WARNING_MESSAGE = "{% trans 'Are you sure you want to continue?' %}";

    // Indicator fields tracked in the admin changelog, which require prompting for a rationale if modified
    let TRACKED_FIELDS = new Set([
        'name',
        'unit_of_measure',
        'unit_of_measure_type',
        'is_cumulative',
        'lop_target',
        'direction_of_change',
        'baseline',
        'baseline_na',
        'periodic_targets',
        'target_frequency',
    ]);

    function showSuccessNotifiction(message) {
        PNotify.success({
            title: "{% trans 'Success' %}",
            text: message,
            type: 'success',
            width: '350px',
            minHeight: '150px',
            delay: 3000,
            stack: {
                'dir1': 'right',
                'dir2': 'up',
                'firstpos1': 0,
                'firstpos2': 0
            },
            modules: {
                Buttons: {
                    closer: true,
                    closerHover: false,
                    sticker: false
                }
            }
        });
    }

    // Open the modal with a create form (as opposed to an update form)
    // form isn't loaded yet, so programId must come from somewhere else
    function openCreateIndicatorFormModal({programId, levelId = null}) {
        let url = `/indicators/indicator_create/${programId}/`;
        // in cases (such as rf builder) where the levelID is prepopulated, add as get parameter to request:
        if (levelId !== null) {
            url += `?levelId=${levelId}`;
        }
        openIndicatorFormModal(url);
    }

    function openUpdateIndicatorFormModal({indicatorId}) {
        let url = `/indicators/indicator_update/${indicatorId}/`;
        openIndicatorFormModal(url);
    }

    function openIndicatorFormModal(url){

        $("#indicator_modal_content").empty();
        $("#modalmessages").empty();
        allowModalToClose = false;
        $("#indicator_modal_content").load(url);
        $("#indicator_modal_div").modal('show');
    }

    // Close the modal window
    function closeIndicatorFormModal() {
        $('#indicator_modal_div').modal('hide');
    }

    // reload the create form (modal remains open)
    function reloadCreateIndicatorForm() {
        let url = `/indicators/indicator_create/${programId()}/`;

        let levelId = initialLevelId();
        if (levelId) {
            url += `?levelId=${levelId}`;
        }

        //$("#indicator_modal_content").empty();
        $("#modalmessages").empty();

        $("#indicator_modal_content").load(url);
    }


    $("#indicator_modal_div").on('shown.bs.modal', function() {

    });


    $("#indicator_modal_div").on('hide.bs.modal', function(e) {

        // Prompt user if closing a create form without saving
        if (isCreateForm() && ! allowModalToClose) {
            // prevent the modal from actually closing
            e.preventDefault();

            // prompt the user if they actually want to close
            window.create_no_rationale_changeset_notice({
                preamble: CLOSE_BEFORE_SAVING_WARNING_PREAMBLE,
                message_text: CLOSE_BEFORE_SAVING_WARNING_MESSAGE,
                context: document.getElementById('indicator_update_form'),
                on_submit: () => {
                    allowModalToClose = true;
                    closeIndicatorFormModal();
                }
            });

            scrollToIndicatorFormBottom();
        }

    });


    // auto scroll either a modal or the whole page to the top
    function scrollToTop() {
        $("#indicator_modal_div").animate({ scrollTop: 0 }, 'slow');
    }

    function scrollToIndicatorFormBottom() {
        // Handle either full page form or modal
        let $el = $('#indicator_modal_div').length ? $('#indicator_modal_div') : $('html');
        scrollToBottom($el);
    }

    /*
     * Data accessors about an instance of the form/indicator
     */

    function indicatorHasResults() {
        return parseInt($('#numDataPoints').text()) > 0;
    }

    function indicatorId() {
        return $('#indicatorId').text() ? parseInt($('#indicatorId').text()) : undefined;
    }

    function isResultsForm() {
        return ($('#indicator_results_modal_content form').length > 0 ||
            $('#indicator_modal_div .results-table__wrapper').length > 0);
    }

    function programId() {
        return $('#programId').text() ? parseInt($('#programId').text()) : undefined;
    }

    function initialLopTarget() {
        return $('#initialLopTarget').numericVal();
    }

    function initialLevelId() {
        return $('#initialLevelId').text() ? parseInt($('#initialLevelId').text()) : undefined;
    }

    function saveEventParams() {
        return {
            programId: programId(),
            indicatorId: indicatorId(),
            indicatorName: $("#id_name").val(),
            levelId: parseInt($("#id_level").val())
        };
    }

    // differentiate between create and update form
    function isCreateForm() {
        return !indicatorId() && !isResultsForm();
    }

    // delete indicator helper
    function confirmAndRedirect(delete_indicator) {
        if(! indicatorHasResults()) {
            create_no_rationale_changeset_notice({
                preamble: [DESTRUCTIVE_PREAMBLE, DELETE_INDICATOR_PREAMBLE].join(' '),
                message_text: DELETE_INDICATOR_NO_RATIONALE,
                context: document.getElementById('indicator_update_form'),
                on_submit: delete_indicator
            });
        } else {
            create_destructive_changeset_notice({
                message_text: DELETE_INDICATOR_MESSAGE,
                context: document.getElementById('indicator_update_form'),
                on_submit: delete_indicator,
                showCloser: true
            });
        }
        scrollToIndicatorFormBottom();
    }

    // delete indicator on click
    $('#indicator_modal_content').on("click", "#id_delete_indicator_btn", function(e) {
        e.preventDefault();
        var url = $(this).attr('href');
        var delete_indicator = (rationale) => {
            $.post(url, {rationale: rationale})
             .done(function(data, textStatus, jqXHR){
                 if (data.status == "success") {
                    showSuccessNotifiction(data.msg);

                    $('#indicator_modal_div').trigger('deleted.tola.indicator.save', saveEventParams());

                    closeIndicatorFormModal();
                 } else {
                     createAlert("danger", data.msg, true, "#modalmessages");
                     $('#indicator_modal_div').animate({ scrollTop: 0 }, 'slow');
                 }
             });
        };
        confirmAndRedirect(delete_indicator);
    });


    // on delete event target
    $('#indicator_modal_content').on('click', '.event-target-delete-button', function(e) {
        e.preventDefault();
        const updateIfLastEvent = () => {
            if ($('.periodic-target').length === 0) {
                clearPeriodicTargetsForm();
            }
        };
        let url = $(this).attr('href');
        let row = $(e.currentTarget).closest('.periodic-target');
        let numResultsLinkedToEventTarget = parseInt(row.data('collected-count'));

        // if no other periodic target values have changed, update the snapshot to reflect new server state
        // there's a missed edge case here if the PT being deleted also had a value change, but meh
        const updateSnapshot = ! hasTargetsChanged();

         /* If target is new, delete means just remove row,
         * If target is saved, delete means call to delete
         */
        const delete_callback = url === '#' ?
            (url, row) => () => {
                row.remove();
                updateIfLastEvent();
                updateLopTargetDisplay();
            } :
            (url, row) => (rationale) => {
                $.post(url, {rationale: rationale})
                    .done((data) => {
                        if (data.status === "success") {
                            $('#indicator_modal_div').trigger('updated.tola.indicator.save', saveEventParams());
                            row.remove();
                            if (updateSnapshot) {
                                updatePTsAndLopTargetOnSnapshot();
                            }
                            updateIfLastEvent();
                            updateLopTargetDisplay();
                        }
                    });
            };
        let hasResults = indicatorHasResults();
        /* If target has results, message refers to number of results,
         * Otherwise, if indicator has results and target is not brand new, record rationale
         * otherwise merely confirm:
         */
        const preamble = numResultsLinkedToEventTarget == 0 ? DESTRUCTIVE_PREAMBLE :
            window.target_with_results_text(numResultsLinkedToEventTarget);
        const message_text = (url == '#' || !hasResults) ?
                DELETE_TARGET_NO_RATIONALE :
                DELETE_TARGET_MESSAGE;
        /* If the indicator has any results linked to it, we prompt for a rationale,
         * otherwise we do not.
         */
        const changeset_notice_function = (url === '#' || !hasResults) ?
                window.create_no_rationale_changeset_notice :
                window.create_destructive_changeset_notice;
        changeset_notice_function({
            preamble: preamble,
            message_text: message_text,
            context: document.getElementById('indicator_update_form'),
            on_submit: (rationale = null) => {
                delete_callback(url, row)(rationale);
            }
        });
        scrollToIndicatorFormBottom();
    });


    // delete periodic_target (delete ALL targets)
    $("#indicator_modal_content").on("click", "#id_delete_targets_btn", function(e) {
        e.preventDefault();

        const actionCb = isCreateForm() ? clearPeriodicTargetsForm :
            (rationale) => {
                $.post('/indicators/periodic_target_deleteall/' + indicatorId() + '/',
                       {rationale},
                       clearPeriodicTargetsForm).done(
                            (data) => {
                            if (data.status === "success") {
                                $('#indicator_modal_div').trigger('updated.tola.indicator.save', saveEventParams());
                            }
                        });
            };


        if(indicatorHasResults()) {
            window.create_destructive_changeset_notice({
                message_text: DELETE_ALL_TARGETS_MESSAGE,
                context: document.getElementById('indicator_update_form'),
                on_submit: actionCb
            });
            scrollToIndicatorFormBottom();
        } else {
            window.create_no_rationale_changeset_notice({
                preamble: DESTRUCTIVE_PREAMBLE,
                message_text: DELETE_TARGETS_NO_RATIONALE,
                context: document.getElementById('indicator_update_form'),
                on_submit: actionCb
            });
        }
        scrollToIndicatorFormBottom();

        updateLopTargetDisplay();
    });


    // Button click handler for UPDATE form
    $("#indicator_modal_content").on("click", "#id_update_indicator_btn", function(e){
        if (validateForm() === false) {
            showValidations("#modalmessages");
            return;
        }

        if(indicatorHasResults() && hasTrackedFieldsChanged()) {
            if(hasTargetsChanged()) {
                window.create_destructive_changeset_notice({
                    message_text: MODIFY_TARGETS_MESSAGE,
                    no_preamble: true,
                    context: document.getElementById('indicator_update_form'),
                    on_submit: (rationale) => {
                        submitFormUpdate(rationale);
                    }
                });
            } else {
                window.create_unified_changeset_notice({
                    header: "Reason for change",
                    show_icon: false,
                    message_text: window.DEFAULT_NONDESTRUCTIVE_MESSAGE,
                    rationale_required: true,
                    include_rationale: true,
                    rfc_required: true,
                    rfc_options: ['first', 'second'],
                    validation_type: 1,
                    showCloser: false,
                    no_preamble: true,
                    context: document.getElementById('indicator_update_form'),
                    on_submit: (rationale, reason_for_change) => {
                        submitFormUpdate(rationale);
                    }
                });
            }
            scrollToIndicatorFormBottom();
        } else if (hasLevelBeenUpdatedOrCleared()) {
            window.create_nondestructive_changeset_notice({
                context: document.getElementById('indicator_update_form'),
                on_submit: (rationale) => {
                    submitFormUpdate(rationale);
                }
            });
        } else {
            submitFormUpdate('');
        }
    });

    // Button click handler for CREATE form (save and close)
    $("#indicator_modal_content").on("click", "#id_save_and_close_indicator_btn", function(e){
        if (validateForm() === false) {
            showValidations("#modalmessages");
            return;
        }

        submitFormCreate().done(() => {
            closeIndicatorFormModal();
        });
    });

    // Button click handler for CREATE form (save and add another)
    $("#indicator_modal_content").on("click", "#id_save_and_add_another_indicator_btn", function(e){
        if (validateForm() === false) {
            showValidations("#modalmessages");
            return;
        }

        submitFormCreate().done(() => {
            reloadCreateIndicatorForm();
        });
    });

    // Cancel button
    $("#indicator_modal_content").on("click", "#id_cancel_btn", closeIndicatorFormModal);


    // Disable default handling of ENTER key
    /*
    $("#indicator_modal_content").on("keyup keypress", "#indicator_update_form", function(e){
        var keyCode = e.keyCode || e.which;
        if (keyCode === 13 ){
            e.preventDefault();
            return false;
        }
    });
    */

    // Insert periodic target form template into indicator form DOM
    function insertPeriodicTargetForm(content) {
        $("#id_div_periodic_tables_placeholder").html(content);

        disable_target_frequency_field(true);

        if ($("#id_unit_of_measure_type_1").is(":checked")) {
            show_hide_cummulative_inputs('percent')
        }
        else {
            show_hide_cummulative_inputs('number')
        }

        updateLopTargetDisplay();
    }

    // remove the periodic targets from from form UI and reset target frequency
    function clearPeriodicTargetsForm() {
        $("#id_div_periodic_tables_placeholder").empty();
        enable_target_frequecy_field();
    }

    // Ask server for periodic targets form template, to insert into the indicator form
    function getPeriodicTargetsForm() {
        let formObj = getIndicatorFormAsObject();

        $.ajax({
            method: 'POST',
            url: "/indicators/periodic_targets_form/" + programId() + "/",
            data: formObj,
        }).done(function (data, textStatus, jqXHR) {
            insertPeriodicTargetForm(data['content']);

        });
    }

    // When adding an event, a row may need to be dynamically inserted
    function createPeriodicTargetRow() {
        return `
                <li class="periodic-target list-group-item item--event" data-collected-count="0" data-ptid="0">
                    <div class="item__label">
                        <a href="#" class="btn-delete btn btn-sm event-target-delete-button">
                            <i class="fas fa-times text-danger"></i>
                        </a>
                        <input type="text" placeholder="{% trans 'Enter event name' %}" class="form-control input-text target-label">
                                <span style="margin:0px;" class="help-block"> </span>
                    </div>

                    <div class="item__value">
                        <span class=${ $("#id_unit_of_measure_type_1").is(":checked")?"input-symbol-percent":""}>
                            <input
                                type="number"
                                id="pt-0"
                                data-periodictarget="pt"
                                placeholder="{% trans 'Enter target' %}"
                                class="form-control input-value periodic-target-input">
                        </span>
                        <span id="hint_id_pt_0" style="margin:0px;" class="help-block"> </span>
                    </div>
                </li>
            `;
    }

    // add new event periodic target markup to PT form
    $("#indicator_modal_content").on("click", "#addNewPeriodicTarget", function(e) {
        e.preventDefault();

        let markup = createPeriodicTargetRow();
        $("#periodic_targets_table li:nth-last-child(1)").before(markup);
    });

    // submits form - returns a jQuery deferred obj to attached callbacks onto
    // only has code shared by both CREATE and UPDATE
    function submitForm(rationale = '') {
        // clear any success/failure messages
        let alertElement = "#modalmessages";
        $(alertElement).html('');

        let $form = $('#indicator_update_form');
        let form_url = $form.attr('action');

        let formArr = $form.serializeArray();
        let periodic_targets_to_submit = JSON.stringify(getFormPeriodicTargets());

        formArr.push({"name": "periodic_targets", "value": periodic_targets_to_submit});

        if (formArr.find(e => e.name === 'is_cumulative') === undefined) {
            formArr.push({name: 'is_cumulative', value: 3});
        }

        // user entered rationale for change
        formArr.push({name: 'rationale', value: rationale});

        // If LoP target not explicit, submit computed value
        if (formArr.find(e => e.name === 'lop_target') === undefined) {
            formArr.push({name: 'lop_target', value: computeLopTarget()});
        }

        return $.ajax({
            method: 'POST',
            url: form_url,
            data: formArr,
        }).done(function(data, textStatus, jqXHR) {
            insertPeriodicTargetForm(data["content"]);
        });
    }

    // Submit the CREATE form
    function submitFormCreate() {
        return submitForm().done((data) => {
            $('#indicator_modal_div').trigger('created.tola.indicator.save', Object.assign(
                saveEventParams(),
                {indicatorId: data.id}
            ));

            // remember such that the user can close the modal without a prompt
            allowModalToClose = true;

            // success msg
            showSuccessNotifiction(data.save_success_msg);
        });
    }

    // Submit the UPDATE form
    function submitFormUpdate(rationale = '') {
        return submitForm(rationale).done((data) => {
            $('#indicator_modal_div').trigger('updated.tola.indicator.save', saveEventParams());

            // Clear any validation error messages
            let alertElement = "#modalmessages";
            $(alertElement).html('');

            // update the header
            $('#id_title').text(data.title_str);
            $('#id_subtitle').text(data.subtitle_str);

            // success msg
            showSuccessNotifiction(data.save_success_msg);

            // Since it's "Save and close" now, we should probably close
            closeIndicatorFormModal();

            // this is our new base state
            //recordTrackedFieldsSnapshot();
        });
    }


    function enable_target_frequecy_field() {
        $("#id_target_frequency").val('');
        $("#id_target_frequency option:not(:selected)").attr("disabled", false);
        $("#id_target_frequency").attr("readonly", false);
    }


    function disable_target_frequency_field(lock = false) {
        // set the text for the 'create new target' button.
        if (lock || $('#id_target_frequency').attr('readonly')) {
            $("#id_target_frequency option:not(:selected)").attr("disabled", true);
            $("#id_target_frequency").attr("readonly", true);
        }
    }

    $("#indicator_modal_content").on("change", "#id_target_frequency", function (e) {
        // if not default value of no-select
        if ($("#id_target_frequency option:selected").text().indexOf("---") < 0) {
            $("#id_target_frequency").removeClass('is-invalid');
            $("#validation_id_target_frequency").text(" ");
            $("#div_id_target_frequency").removeClass('marginbottom-225');
            $("#div_id_target_frequency").addClass('mb-3');

            getPeriodicTargetsForm();
        } else {
            $("#div_id_target_frequency").addClass('marginbottom-225');
            $("#div_id_target_frequency").removeClass('mb-3');
        }
        disable_target_frequency_field();
    });


    /*
     * Copied from indicator form template
     */



    /*
    Adds/removes the percent symbol in several places
    */
    function togglePercentSymbol(unit_of_measure_type) {
        if (unit_of_measure_type == 2) {
            // toggle % sign on sum values
            $(".periodic-targets__sum__value").addClass('input-symbol-percent')

            // toggle % sign on LoP target input
            $("#span_id_lop_target").addClass('input-symbol-percent')

            // toggle % sign on baseline input
            $("#span_id_baseline").addClass('input-symbol-percent')

            // toggle % sign to target inputs
            $("#periodic_targets_table input[data-periodictarget]").each(function (index, element) {
                $(element).parent().addClass('input-symbol-percent');
            });
        } else {
            // toggle % sign on sum values
            $(".periodic-targets__sum__value").removeClass('input-symbol-percent')

            // toggle % sign on LoP target input
            $("#span_id_lop_target").removeClass('input-symbol-percent')

            // toggle % sign on baseline input
            $("#span_id_baseline").removeClass('input-symbol-percent')

            // toggle % sign to target inputs
            $("#periodic_targets_table input[data-periodictarget]").each(function (index, element) {
                $(element).parent().removeClass('input-symbol-percent');
            });
        }


    }

    /*
    toggles the label text of the is_cumulative radio inputs depending on
    whether the unit_of_measure_type of the indicator.
    params:
        - unit_of_measure_type: it can have two possible values
            1 = Number (#)
            2 = Percentage (%)

    This function also uses is_cumulative, which has one of these values:
        - 1 = None
        - 2 = Cumulative
        - 3 = Non-cumulative
    */
    function toggleCummulativeOptions(unit_of_measure_type) {
        // the top option is always the default option
        if (unit_of_measure_type == 2) {
            show_hide_cummulative_inputs('percent')
            $("#id_is_cumulative_1").prop("checked", false);
            // Although it's not displayed, when the measurement type is cumulative, the input should be set to true
            // so the is_cumulative input can be submitted with the correct value
            $("#id_is_cumulative_2").prop("checked", true);
        } else {
            show_hide_cummulative_inputs('number')
            $("#id_is_cumulative_1").prop("checked", true);
            $("#id_is_cumulative_2").prop("checked", false);
        }
    }

    function show_hide_cummulative_inputs(type) {
        //d-flex overrides display settings, so we need to apply and unapply depending on visibility
        if (type == 'number') {
            $("#id_span_is_cumulative_header").text("{% trans 'Options for number (#) indicators'|escapejs %}");
            $("#id_div_is_cumulative_section1").show();
            $("#id_div_is_cumulative_section2").show();
            $("#id_div_is_cumulative_section3").hide();
        } else {
            {# Translators: This is the title of some informational text describing what it means when an indicator is being measured as a percentage e.g. % of population with access to water  #}
            $("#id_span_is_cumulative_header").text("{% trans 'Percentage (%) indicators'|escapejs %}");
            $("#id_div_is_cumulative_section3").show();
            $("#id_div_is_cumulative_section1").hide();
            $("#id_div_is_cumulative_section2").hide();
            $("#id_is_cumulative_2").prop("checked", true);
        }
    }

    // returns true if "is cumulative" radio button is selected on the form
    // as a reminder, this is a null boolean field where
    // 1 - null
    // 2 - cumulative
    // 3 - non-cumulative
    function getIsCumulative() {
        return $("input[name='is_cumulative']:checked").val() === "2";
    }

    // Is units of measure a percentage?
    function getIsPercentage() {
        return $("#id_unit_of_measure_type_1").is(":checked");
    }

    function cleanFloat(value) {
        if (isNaN(parseFloat(value))) {
            return value;
        }
        value = parseFloat(value).toFixed(2);
        if (value.slice(-2) === "00") {
            return value.slice(0, -3);
        }
        else if (value.slice(-1) === "0") {
            return value.slice(0, -1);
        }
        return value;
    }

    /*
    Calculates the sum and count of all targets
    */
    function computeLopTarget() {
        let values = [];

        $("#periodic_targets_table input[data-periodictarget]").each(function () {
            values.push($(this).numericVal());
        });

        let validValues = values.filter(n => (!isNaN(n) && n !== null));

        if (validValues.length === 0) {
            return null;
        }

        let sum = validValues.reduce((total, n) => total + n)

        // the last value is the target when cumulative
        let value = getIsCumulative() ? validValues[validValues.length - 1] : sum;
        return cleanFloat(value);
    }

    /*
    Update the LoP total row to display total based off of Periodic Targets
    */
    function updateLopTargetDisplay() {
        let targetsSum = computeLopTarget();
        $("#id_span_loptarget").displayVal(targetsSum);
        // also show any validation errors related to a 0 LoP
        validateComputedLopTarget();
    }

    /*
    Listen for change event of the UNIT_OF_MEASURE_TYPE radio buttons and
    toggle Percent sign and cumulative options accordingly.
    #id_fieldgroup_unit_of_measure
    */
    $("#indicator_modal_content").on("change", ":input[name='unit_of_measure_type']", function (e) {
        var unit_of_measure_type = parseInt(e.target.value);
        togglePercentSymbol(unit_of_measure_type);
        toggleCummulativeOptions(unit_of_measure_type);
        updateLopTargetDisplay();
    });


    /*
    Listen for change event of the IS_CUMULATIVE radio buttons and toggle the
    targets_sum row accordingly.
    #id_div_is_cumulative
    */
    $("#indicator_modal_content").on("change", ":input[type='radio'][name='is_cumulative']", function (e) {
        updateLopTargetDisplay(e.target.value);
    });


    /*
     * Form validation
     */

    // does the periodic targets form exist in the modal?
    // if not, assume no PTs have been created
    function hasPeriodicTargetsForm() {
        return $('#id_div_periodic_tables_placeholder').children().length > 0;
    }


    /*
     * If the manually entered in LoP target of an indicator currently saved in the DB
     * does not matched the computed LoP target, based on periodic target values
     * then show a warning to the user
     */
    function warnIfLopTargetDoesNotMatchComputed() {
        let dbTarget = initialLopTarget();
        let calculatedTarget = computeLopTarget();
        let msg;
        // either create form - or very old indicator w/ no LoP set
        if (dbTarget === undefined) return;

        let percentStr = getIsPercentage() ? '%' : '';

        // PTs exist, and are not of type LoP only
        if (calculatedTarget != null) {
            // DB value doesn't match PTs

            // compare num to str here...
            if (dbTarget == calculatedTarget) return;

            {# Translators: warning to user that manually entered in value doesn't match computed value, %s is a number or percentage #}
            msg = "{% trans 'Life of Program (LoP) targets are now automatically displayed. The current LoP target does not match what was manually entered in the past -- %s. You may need to update your target values.' %}";
            msg = interpolate(msg, [dbTarget + percentStr]);
        } else if (! hasPeriodicTargetsForm()) {
            // DB value but no PTs
            {# Translators: warning to user that manually entered in value doesn't match computed value, %s is a number or percentage #}
            msg = "{% trans 'This program previously had a LoP target of %s. Life of Program (LoP) targets are now automatically displayed.' %}";
            msg = interpolate(msg, [dbTarget + percentStr]);
        } else {
            // lop only - should always match DB value
            return;
        }

        validation_msgs['lop_target_not_matching'] = msg;
        showValidations('#modalmessages');
    }

    function validateName() {
        const $nameField = $('#id_name');
        const $nameValidation = $('#validation_id_name');
        let errMsg = null;
        if (!$nameField.val() || $nameField.val().length == 0) {
            errMsg = "{% trans 'Please complete this field.'|escapejs %}";
        } else if ($nameField.val().length > 500) {
            errMsg = "{% trans 'Please enter an indicator with fewer than 500 characters.'|escapejs %}";
        }
        if (errMsg) {
            $("#div_id_name").removeClass("mb-3");
            $("#div_id_name").addClass("marginbottom-225");
            $nameField.addClass('is-invalid');
            $nameValidation.html(errMsg);
            return false;
        } else {
            $nameField.removeClass('is-invalid');
            $nameValidation.html("");
            $("#div_id_name").addClass("mb-3");
            $("#div_id_name").removeClass("marginbottom-225");
            return true;
        }
    }


    function reset_baseline_errors(){
        $("#id_baseline").removeClass('is-invalid');
        $("#id_baseline_na").removeClass('is-invalid');
        $("#validation_id_baseline").html("");
    }

    function validate_baseline() {
        const baseline = $("#id_baseline");
        const baseline_na = $("#id_baseline_na");
        let errMsg = undefined;

        if (baseline_na.is(':checked') == true) {
            reset_baseline_errors();
            return true;
        }

        if (baseline.val() === '') {
            errMsg = "{% trans 'Please enter a number greater than or equal to zero.'|escapejs %}";
        } else if (baseline.numericVal() === null) {
            errMsg = "{% trans 'Please enter a number greater than or equal to zero.'|escapejs %}";
        }
        if (errMsg){
            baseline.addClass('is-invalid');
            // baseline_na.addClass('is-invalid');
            $("#validation_id_baseline").html(`<small>${errMsg}</small>`);
            return false;
        } else {
            reset_baseline_errors();
            errMsg = undefined;
            return true;
        }
    }

    // this validates the lop target form field (as opposed to the computed lop target value)
    function validate_loptarget() {
        const lop = $("#id_lop_target");

        // The LoP field only exists if LoP is selected
        if (lop.length === 0) {
            return true;
        }

        let errMsg = undefined;

        if (lop.numericVal() === 0) {
            errMsg = "{% trans 'The Life of Program (LoP) target cannot be zero.'|escapejs %}";
        }
        if (lop.numericVal() === null) {
            errMsg = "{% trans 'Please enter a target.'|escapejs %}";
        }
        if (errMsg) {
            lop.addClass('is-invalid');
            showTargetErrors(errMsg);
            return false;
        } else {
            lop.removeClass('is-invalid');
            clearTargetErrors();
            return true;
        }
    }

    function validateForEmptyField(fieldName) {
        var field = $("#" + fieldName);
        if (fieldName == 'id_level') {
            if (!$('label[for="id_level"]').hasClass('label--required')) {
                // id_level is not required in some cases (have not switched to RF)
                return true;
            }
        }
        if ((fieldName == "id_level" || fieldName == "id_old_level") && field.length == 0) {
            //skip nonexistant fields
            return true;
        }
        if ($.isEmptyObject(field.val())) {
            $(field).addClass('is-invalid');
            $("#validation_" + fieldName).text("{% trans 'Please complete this field.'|escapejs %}");
            return false;
        } else {
            $(field).removeClass('is-invalid');
            $("#validation_" + fieldName).text(" ");
            return true;
        }
    }


    function validatePeriodicTargets(){
        let errorFlag = false;
        // validate target values (number fields)
        $("#periodic_targets_table input.periodic-target-input").each(function(){
            if ($(this).attr('id').substr(0, 2) == "pt" ) {
                let val = $(this).numericVal();
                if (val !== null) {
                    $(this).removeClass('is-invalid');
                } else {
                    $(this).addClass('is-invalid');
                    errorFlag = true;
                }
            }
        });

        // validate target labels (text fields)
        $("#periodic_targets_table .target-label").each(function(){
            if ($(this).val()) {
                $(this).removeClass('is-invalid');
            } else {
                $(this).addClass('is-invalid');
                errorFlag = true;
            }
        });
        if (errorFlag) {
            showTargetErrors(getPTMessage());
            return false;
        }

        return true;
    }

    function validateComputedLopTarget() {
        // Only check computed LoP target if all the PTs are filled in, otherwise don't bother
        let allValid = true;

        // validate target values (number fields)
        $("#periodic_targets_table input.periodic-target-input").each(function(){
            if ($(this).attr('id').substr(0, 2) == "pt" ) {
                let val = $(this).numericVal();
                if (val === null) {
                    allValid = false;
                }
            }
        });
        $("#periodic_targets_table .target-label").each(function(){
            if (!$(this).val()) {
                allValid = false;
            }
        });
        if (allValid) {
            clearTargetErrors();
        }

        // If all the inputs exist and are legit, try validating the LoP target now

        let computedLop = computeLopTarget();
        if (allValid && computedLop != null && computedLop < 0.01) {
            let msg = "{% trans 'The Life of Program (LoP) target cannot be zero.  Please update targets.'|escapejs %}";
            showTargetErrors(msg);
            return false;
        }

        return true;
    }


    function getPTMessage () {
        if ($("#periodic_targets_table input.target-label").length > 0){
            return ("{% trans 'Please complete all event names and targets.'|escapejs %}");
        }
        else {
            return ("{% trans 'Please complete targets.'|escapejs %}");
        }
    }

    function showTargetErrors(msg) {
        $("#id_pt_errors").html(`<span class="target-value-error"><small>${msg}</small></span>`);
    }

    function clearTargetErrors() {
        $("#id_pt_errors").empty();
    }


    function showValidations(messagesDiv) {
        if (!validation_msgs || Object.entries(validation_msgs).length ==  0) {
            return;
        }
        var msg = '';
        $.each(validation_msgs, function(k,v) {
            msg += v + '<br>';
        });
        $(messagesDiv).empty();
        if (!jQuery.isEmptyObject(validation_msgs)) {
            createAlert('danger', msg, false, messagesDiv);
            scrollToTop();
        }
        validation_msgs = {};
    }

    function validateForm() {
        // Clear any existing messages
        validation_msgs = {};

        var validationsTargetTab = true;
        var validationsSummaryTab = true;
        var validationsPerformanceTab = true;
        var noMessageValidations = true;

        if  (validate_baseline() === false ) {
            validationsTargetTab = false
        }
        if (validateForEmptyField("id_unit_of_measure") === false ) {
            validationsTargetTab = false;
        }
        if (validateForEmptyField("id_target_frequency") === false) {
            validationsTargetTab = false;
            $("#div_id_target_frequency").addClass("marginbottom-225");
            $("#div_id_target_frequency").removeClass("mb-3")
        }
        var periodicTargetsValidated = true;
        if (validatePeriodicTargets() === false) {
            periodicTargetsValidated = false;
            validationsTargetTab = false;
        }
        if (periodicTargetsValidated && validateComputedLopTarget() === false) {
            validationsTargetTab = false;
        }
        if (validate_loptarget() === false ) {
            validationsTargetTab = false;
        }
        // validate periodic targets
        if ($("#id_div_periodic_tables_placeholder input").hasClass('is-invalid')) {
            validationsTargetTab = false;
        }

        if (validationsTargetTab === false) {
            validation_msgs['target'] = '{% trans "Please complete all required fields in the Targets tab."|escapejs %}';
        }

        /* validate fields from the summary tab */
        if (validateName() === false) {
            noMessageValidations = false;
        }

        /* validate fields from the Performance tab */
        if (validateForEmptyField("id_level") === false) {
            validationsSummaryTab = false;
        }

        if (validationsSummaryTab === false) {
            validation_msgs['summary'] = '{% trans "Please complete all required fields in the Summary tab."|escapejs %}';
        }



        if (validateForEmptyField("id_old_level") === false) {
            validationsPerformanceTab = false;
        }

        if (validationsPerformanceTab === false) {
            validation_msgs['performance'] = '{% trans "Please complete all required fields in the Performance tab."|escapejs %}';
        }

        // return all tab validations
        return validationsTargetTab && validationsSummaryTab && validationsPerformanceTab && noMessageValidations;
    }

    $("#indicator_modal_content").on("keypress", "input[type=number]", function(e){
        if (e.which == 69 || e.which == 101){ //69 = e | 101 = E
            e.preventDefault();
        }
    });

    /*
     * On change of events and periodic target numeric values, but NOT LoP only value
     */
    $("#indicator_modal_content").on("input", "#periodic_targets_table input[data-periodictarget]", function(e){
        clearTargetErrors();

        if ($(this).numericVal() !== null) {
            $(this).removeClass('is-invalid');
        } else {
            $(this).addClass('is-invalid');
        }

        if ($("#id_div_periodic_tables_placeholder input[type=number], input[type=text]").hasClass("is-invalid") ) {
            showTargetErrors(getPTMessage());
        }

        // Update calculated display
        updateLopTargetDisplay();
    });

    $("#indicator_modal_content").on("input", "#periodic_targets_table input.target-label", function(e){
        clearTargetErrors();

        if ($(this).val()) {
            $(this).removeClass('is-invalid');
        } else {
            $(this).addClass('is-invalid');
        }

        if ($("#id_div_periodic_tables_placeholder input[type=text], input[type=number]").hasClass("is-invalid") ) {
            showTargetErrors(getPTMessage());
        }
    });

    $("#indicator_modal_content").on("blur", "#id_unit_of_measure", function(e){
        validateForEmptyField("id_unit_of_measure");
    });

    $("#indicator_modal_content").on("blur", "#id_level", function(e){
        validateForEmptyField("id_level");
    });

    $("#indicator_modal_content").on("blur", "#id_target_frequency", function(e){
        validateForEmptyField("id_target_frequency");
    });

    $("#indicator_modal_content").on("blur", "#id_old_level", function(e){
        validateForEmptyField("id_old_level");
    });

    $("#indicator_modal_content").on("keyup", "#id_lop_target", function(e){
        validate_loptarget();
    });

    $("#indicator_modal_content").on("blur", "#id_baseline", function(e){
        $("#id_baseline_na").prop('checked', false);
        validate_baseline();
    });

    $("#indicator_modal_content").on("keyup", "#id_name", function(e){
        validateName();
    });

    $("#indicator_modal_content").on("input", "#id_baseline", function(e){
        $("#id_baseline_na").prop('checked', false);
    });

    $("#indicator_modal_content").on("change", "#id_baseline_na", function(e){
        $("#id_baseline").val('');
        if (!$(this).is(':checked')){
            validate_baseline()
        } else {
            reset_baseline_errors();
        }
    });


    /*
     * Change tracking functions
     */

    // Returns an array of objects of periodic target form values
    // can be called with a row to exclude from the list (to check if _other_ targets have changed)
    function getFormPeriodicTargets() {
        let periodic_targets = [];

        // Collect all existing periodic_targets into an array.
        $('#periodic_targets_table .periodic-target').each(function () {
            let $this = $(this);
            let eventNameElement = $($this.find('input.target-label'));
            let targetValueSelector = $($this.find('input.periodic-target-input'));

            let pt_id;
            let pt_name;
            try {
                pt_id = parseInt(targetValueSelector.attr('id').split('-')[1]);
                if (!$.isNumeric(pt_id)) {
                    pt_id = 0;
                }
            } catch (err) {
                pt_id = 0;
            }

            if (eventNameElement.length > 0) {
                pt_name = eventNameElement.val();
            } else {
                pt_name = targetValueSelector.attr('name');
            }

            let pt_value = targetValueSelector.val();
            let start_date = targetValueSelector.data("startDate");
            let end_date = targetValueSelector.data("endDate");

            periodic_targets.push({
                'id': pt_id,
                'period': pt_name,
                'target': pt_value,
                'start_date': start_date,
                'end_date': end_date
            });
        });

        return periodic_targets;
    }

    // just the level value from the form
    function getLevelFormValue() {
        return $('#id_level').val();
    }

    // return a JS obj of key/vals of indicator form
    // WARNING: this totally doesn't work correctly with multi-selects (or any key w/ multiple values)
    function getIndicatorFormAsObject() {
        let $form = $('#indicator_update_form');
        let formObj = {};

        // Turns out this is not great as serializeArray() will return multiple objs for a single name
        // in the case of form fields with multiple values (like multi-selects)
        // This causes data loss to occur. I've left it for now as no TRACKED_FIELDS currently have multiple values
        // and hopefully this code will be redone soon anyways
        $form.serializeArray().forEach(function (x) {
            formObj[x.name] = x.value;
        });

        // Set is_cumulative if it's not already set
        // This is a null boolean in the DB. Django has:
        // 1: null
        // 2: true
        // 3: false
        if (formObj['is_cumulative'] === undefined) {
            formObj['is_cumulative'] = 3;
        }

        // Compute LoP if not explicit in form
        if (formObj['lop_target'] === undefined) {
            formObj['lop_target'] = computeLopTarget();
        }

        let periodic_targets = getFormPeriodicTargets();

        formObj['periodic_targets'] = JSON.stringify(periodic_targets);

        return formObj;
    }

    // same as getIndicatorFormAsObject() but containing only tracked fields
    // can be used to snapshot form state for later comparison
    function getTrackedFieldsObject() {
        let formObj = getIndicatorFormAsObject();
        let trackFieldsObj = {};

        Object.keys(formObj).forEach(function(key) {
            if (TRACKED_FIELDS.has(key)) {
                trackFieldsObj[key] = formObj[key];
            }
        });

        return trackFieldsObj;
    }

    // remember the initial state of tracked fields on the form
    function recordTrackedFieldsSnapshot(useDBLopTarget = false) {
        initialTrackedFieldsFormState = getTrackedFieldsObject();

        // The LoP target in the DB may be out of sync with the client
        // side calculated LoP target. The snapshot reflects the client value
        // by default, but may need to reflect the DB value to prompt for rationale
        if (useDBLopTarget) {
            initialTrackedFieldsFormState['lop_target'] = cleanFloat(initialLopTarget());
        }

        initialLevelFormValue = getLevelFormValue();
    }

    // update targets and indicator LoP target of the initial form snapshot
    function updatePTsAndLopTargetOnSnapshot() {
        let formObj = getIndicatorFormAsObject();
        initialTrackedFieldsFormState.periodic_targets = formObj.periodic_targets;
        initialTrackedFieldsFormState.lop_target = formObj.lop_target;
    }

    // have any tracked fields changed in the form?
    function hasTrackedFieldsChanged() {
        let prevState = JSON.stringify(initialTrackedFieldsFormState);
        let currState = JSON.stringify(getTrackedFieldsObject());
        return prevState !== currState;
    }

    // have targets or target values changed in the form?
    function hasTargetsChanged() {
        let currTrackedFieldsFormState = getTrackedFieldsObject();

        // look at values of targets in table
        let prevTargetFieldsState = initialTrackedFieldsFormState.periodic_targets;
        let currTargetFieldsState = currTrackedFieldsFormState.periodic_targets;

        // LoP has no values, so look at changes in the target type itself
        let prevTargetType = initialTrackedFieldsFormState.target_frequency;
        let currTargetType = currTrackedFieldsFormState.target_frequency;

        return prevTargetFieldsState !== currTargetFieldsState || prevTargetType !== currTargetType;
    }

    // has `level` changed in a way we care about (as opposed to any way possible)?
    // the rules here are that we don't care of a level goes from nothing -> something
    // only if it goes from something -> something or something -> nothing
    function hasLevelBeenUpdatedOrCleared() {
        let currLevelFormValue = getLevelFormValue();

        // empty string if nothing selected
        if (! initialLevelFormValue) {
            // don't bother prompting using if they are setting a level
            // where a level wasn't set in the past
            return false;
        }

        return initialLevelFormValue !== currLevelFormValue;
    }
</script>
